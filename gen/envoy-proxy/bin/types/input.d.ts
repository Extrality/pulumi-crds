import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
export declare namespace gateway {
    namespace v1alpha1 {
        /**
         * Backend allows the user to configure the endpoints of a backend and
         * the behavior of the connection from Envoy Proxy to the backend.
         */
        interface Backend {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Backend">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.BackendStatus>;
        }
        /**
         * Spec defines the desired state of Backend.
         */
        interface BackendSpec {
            /**
             * AppProtocols defines the application protocols to be supported when connecting to the backend.
             */
            appProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Endpoints defines the endpoints to be used when connecting to the backend.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpoints>[]>;
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecTls>;
            /**
             * Type defines the type of the backend. Defaults to "Endpoints"
             */
            type?: pulumi.Input<string>;
        }
        /**
         * BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
         * corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
         */
        interface BackendSpecEndpoints {
            fqdn?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsFqdn>;
            /**
             * Hostname defines an optional hostname for the backend endpoint.
             */
            hostname?: pulumi.Input<string>;
            ip?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsIp>;
            unix?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsUnix>;
            /**
             * Zone defines the service zone of the backend endpoint.
             */
            zone?: pulumi.Input<string>;
        }
        /**
         * FQDN defines a FQDN endpoint
         */
        interface BackendSpecEndpointsFqdn {
            /**
             * Hostname defines the FQDN hostname of the backend endpoint.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Port defines the port of the backend endpoint.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * FQDN defines a FQDN endpoint
         */
        interface BackendSpecEndpointsFqdnPatch {
            /**
             * Hostname defines the FQDN hostname of the backend endpoint.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Port defines the port of the backend endpoint.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.
         */
        interface BackendSpecEndpointsIp {
            /**
             * Address defines the IP address of the backend endpoint.
             * Supports both IPv4 and IPv6 addresses.
             */
            address?: pulumi.Input<string>;
            /**
             * Port defines the port of the backend endpoint.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * IP defines an IP endpoint. Supports both IPv4 and IPv6 addresses.
         */
        interface BackendSpecEndpointsIpPatch {
            /**
             * Address defines the IP address of the backend endpoint.
             * Supports both IPv4 and IPv6 addresses.
             */
            address?: pulumi.Input<string>;
            /**
             * Port defines the port of the backend endpoint.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendEndpoint describes a backend endpoint, which can be either a fully-qualified domain name, IP address or unix domain socket
         * corresponding to Envoy's Address: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address
         */
        interface BackendSpecEndpointsPatch {
            fqdn?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsFqdnPatch>;
            /**
             * Hostname defines an optional hostname for the backend endpoint.
             */
            hostname?: pulumi.Input<string>;
            ip?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsIpPatch>;
            unix?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsUnixPatch>;
            /**
             * Zone defines the service zone of the backend endpoint.
             */
            zone?: pulumi.Input<string>;
        }
        /**
         * Unix defines the unix domain socket endpoint
         */
        interface BackendSpecEndpointsUnix {
            /**
             * Path defines the unix domain socket path of the backend endpoint.
             * The path length must not exceed 108 characters.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Unix defines the unix domain socket endpoint
         */
        interface BackendSpecEndpointsUnixPatch {
            /**
             * Path defines the unix domain socket path of the backend endpoint.
             * The path length must not exceed 108 characters.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Spec defines the desired state of Backend.
         */
        interface BackendSpecPatch {
            /**
             * AppProtocols defines the application protocols to be supported when connecting to the backend.
             */
            appProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Endpoints defines the endpoints to be used when connecting to the backend.
             */
            endpoints?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendSpecEndpointsPatch>[]>;
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.BackendSpecTlsPatch>;
            /**
             * Type defines the type of the backend. Defaults to "Endpoints"
             */
            type?: pulumi.Input<string>;
        }
        /**
         * TLS defines the TLS settings for the backend.
         * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
         * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
         * take precedence.
         */
        interface BackendSpecTls {
            /**
             * CACertificateRefs contains one or more references to Kubernetes objects that
             * contain TLS certificates of the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the backend.
             *
             * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
             * with the CA certificate in a key named `ca.crt` is currently supported.
             *
             * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
             * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
             * not both.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendSpecTlsCaCertificateRefs>[]>;
            /**
             * InsecureSkipVerify indicates whether the upstream's certificate verification
             * should be skipped. Defaults to "false".
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * WellKnownCACertificates specifies whether system CA certificates may be used in
             * the TLS handshake between the gateway and backend pod.
             *
             * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
             * must be specified with at least one entry for a valid configuration. Only one of
             * CACertificateRefs or WellKnownCACertificates may be specified, not both.
             */
            wellKnownCACertificates?: pulumi.Input<string>;
        }
        /**
         * LocalObjectReference identifies an API object within the namespace of the
         * referrer.
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface BackendSpecTlsCaCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * LocalObjectReference identifies an API object within the namespace of the
         * referrer.
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface BackendSpecTlsCaCertificateRefsPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * TLS defines the TLS settings for the backend.
         * If TLS is specified here and a BackendTLSPolicy is also configured for the backend, the final TLS settings will
         * be a merge of both configurations. In case of overlapping fields, the values defined in the BackendTLSPolicy will
         * take precedence.
         */
        interface BackendSpecTlsPatch {
            /**
             * CACertificateRefs contains one or more references to Kubernetes objects that
             * contain TLS certificates of the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the backend.
             *
             * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
             * with the CA certificate in a key named `ca.crt` is currently supported.
             *
             * If CACertificateRefs is empty or unspecified, then WellKnownCACertificates must be
             * specified. Only one of CACertificateRefs or WellKnownCACertificates may be specified,
             * not both.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendSpecTlsCaCertificateRefsPatch>[]>;
            /**
             * InsecureSkipVerify indicates whether the upstream's certificate verification
             * should be skipped. Defaults to "false".
             */
            insecureSkipVerify?: pulumi.Input<boolean>;
            /**
             * WellKnownCACertificates specifies whether system CA certificates may be used in
             * the TLS handshake between the gateway and backend pod.
             *
             * If WellKnownCACertificates is unspecified or empty (""), then CACertificateRefs
             * must be specified with at least one entry for a valid configuration. Only one of
             * CACertificateRefs or WellKnownCACertificates may be specified, not both.
             */
            wellKnownCACertificates?: pulumi.Input<string>;
        }
        /**
         * Status defines the current status of Backend.
         */
        interface BackendStatus {
            /**
             * Conditions describe the current conditions of the Backend.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendStatusConditions>[]>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface BackendStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * BackendTrafficPolicy allows the user to configure the behavior of the connection
         * between the Envoy Proxy listener and the backend service.
         */
        interface BackendTrafficPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackendTrafficPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicyStatus>;
        }
        /**
         * spec defines the desired state of BackendTrafficPolicy.
         */
        interface BackendTrafficPolicySpec {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCircuitBreaker>;
            /**
             * The compression config for the http streams.
             */
            compression?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCompression>[]>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecDns>;
            faultInjection?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjection>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttp2>;
            /**
             * HTTPUpgrade defines the configuration for HTTP protocol upgrades.
             * If not specified, the default upgrade configuration(websocket) will be used.
             */
            httpUpgrade?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttpUpgrade>[]>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancer>;
            /**
             * MergeType determines how this configuration is merged with existing BackendTrafficPolicy
             * configurations targeting a parent resource. When set, this configuration will be merged
             * into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
             * This field cannot be set when targeting a parent resource (Gateway).
             * If unset, no merging occurs, and only the most specific configuration takes effect.
             */
            mergeType?: pulumi.Input<string>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecProxyProtocol>;
            rateLimit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimit>;
            requestBuffer?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRequestBuffer>;
            /**
             * ResponseOverride defines the configuration to override specific responses with a custom one.
             * If multiple configurations are specified, the first one to match wins.
             */
            responseOverride?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverride>[]>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetry>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetRef>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetRefs>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetSelectors>[]>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTcpKeepalive>;
            telemetry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetry>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeout>;
            /**
             * UseClientProtocol configures Envoy to prefer sending requests to backends using
             * the same HTTP protocol that the incoming request used. Defaults to false, which means
             * that Envoy will use the protocol indicated by the attached BackendRef.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface BackendTrafficPolicySpecCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface BackendTrafficPolicySpecCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface BackendTrafficPolicySpecCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface BackendTrafficPolicySpecCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Compression defines the config of enabling compression.
         * This can help reduce the bandwidth at the expense of higher CPU.
         */
        interface BackendTrafficPolicySpecCompression {
            /**
             * The configuration for Brotli compressor.
             */
            brotli?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * The configuration for GZIP compressor.
             */
            gzip?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CompressorType defines the compressor type to use for compression.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Compression defines the config of enabling compression.
         * This can help reduce the bandwidth at the expense of higher CPU.
         */
        interface BackendTrafficPolicySpecCompressionPatch {
            /**
             * The configuration for Brotli compressor.
             */
            brotli?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * The configuration for GZIP compressor.
             */
            gzip?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CompressorType defines the compressor type to use for compression.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface BackendTrafficPolicySpecConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface BackendTrafficPolicySpecConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface BackendTrafficPolicySpecDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface BackendTrafficPolicySpecDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
         * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
         */
        interface BackendTrafficPolicySpecFaultInjection {
            abort?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjectionAbort>;
            delay?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjectionDelay>;
        }
        /**
         * If specified, the request will be aborted if it meets the configuration criteria.
         */
        interface BackendTrafficPolicySpecFaultInjectionAbort {
            /**
             * GrpcStatus specifies the GRPC status code to be returned
             */
            grpcStatus?: pulumi.Input<number>;
            /**
             * StatusCode specifies the HTTP status code to be returned
             */
            httpStatus?: pulumi.Input<number>;
            /**
             * Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%.
             */
            percentage?: pulumi.Input<number>;
        }
        /**
         * If specified, the request will be aborted if it meets the configuration criteria.
         */
        interface BackendTrafficPolicySpecFaultInjectionAbortPatch {
            /**
             * GrpcStatus specifies the GRPC status code to be returned
             */
            grpcStatus?: pulumi.Input<number>;
            /**
             * StatusCode specifies the HTTP status code to be returned
             */
            httpStatus?: pulumi.Input<number>;
            /**
             * Percentage specifies the percentage of requests to be aborted. Default 100%, if set 0, no requests will be aborted. Accuracy to 0.0001%.
             */
            percentage?: pulumi.Input<number>;
        }
        /**
         * If specified, a delay will be injected into the request.
         */
        interface BackendTrafficPolicySpecFaultInjectionDelay {
            /**
             * FixedDelay specifies the fixed delay duration
             */
            fixedDelay?: pulumi.Input<string>;
            /**
             * Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%.
             */
            percentage?: pulumi.Input<number>;
        }
        /**
         * If specified, a delay will be injected into the request.
         */
        interface BackendTrafficPolicySpecFaultInjectionDelayPatch {
            /**
             * FixedDelay specifies the fixed delay duration
             */
            fixedDelay?: pulumi.Input<string>;
            /**
             * Percentage specifies the percentage of requests to be delayed. Default 100%, if set 0, no requests will be delayed. Accuracy to 0.0001%.
             */
            percentage?: pulumi.Input<number>;
        }
        /**
         * FaultInjection defines the fault injection policy to be applied. This configuration can be used to
         * inject delays and abort requests to mimic failure scenarios such as service failures and overloads
         */
        interface BackendTrafficPolicySpecFaultInjectionPatch {
            abort?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjectionAbortPatch>;
            delay?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjectionDelayPatch>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface BackendTrafficPolicySpecHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface BackendTrafficPolicySpecHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface BackendTrafficPolicySpecHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface BackendTrafficPolicySpecHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface BackendTrafficPolicySpecHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface BackendTrafficPolicySpecHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface BackendTrafficPolicySpecHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface BackendTrafficPolicySpecHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface BackendTrafficPolicySpecHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * ProtocolUpgradeConfig specifies the configuration for protocol upgrades.
         */
        interface BackendTrafficPolicySpecHttpUpgrade {
            connect?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttpUpgradeConnect>;
            /**
             * Type is the case-insensitive type of protocol upgrade.
             * e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Connect specifies the configuration for the CONNECT config.
         * This is allowed only when type is CONNECT.
         */
        interface BackendTrafficPolicySpecHttpUpgradeConnect {
            /**
             * Terminate the CONNECT request, and forwards the payload as raw TCP data.
             */
            terminate?: pulumi.Input<boolean>;
        }
        /**
         * Connect specifies the configuration for the CONNECT config.
         * This is allowed only when type is CONNECT.
         */
        interface BackendTrafficPolicySpecHttpUpgradeConnectPatch {
            /**
             * Terminate the CONNECT request, and forwards the payload as raw TCP data.
             */
            terminate?: pulumi.Input<boolean>;
        }
        /**
         * ProtocolUpgradeConfig specifies the configuration for protocol upgrades.
         */
        interface BackendTrafficPolicySpecHttpUpgradePatch {
            connect?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttpUpgradeConnectPatch>;
            /**
             * Type is the case-insensitive type of protocol upgrade.
             * e.g. `websocket`, `CONNECT`, `spdy/3.1` etc.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface BackendTrafficPolicySpecLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface BackendTrafficPolicySpecLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface BackendTrafficPolicySpecLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface BackendTrafficPolicySpecLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface BackendTrafficPolicySpecLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface BackendTrafficPolicySpecLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface BackendTrafficPolicySpecLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * spec defines the desired state of BackendTrafficPolicy.
         */
        interface BackendTrafficPolicySpecPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCircuitBreakerPatch>;
            /**
             * The compression config for the http streams.
             */
            compression?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecCompressionPatch>[]>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecDnsPatch>;
            faultInjection?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecFaultInjectionPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttp2Patch>;
            /**
             * HTTPUpgrade defines the configuration for HTTP protocol upgrades.
             * If not specified, the default upgrade configuration(websocket) will be used.
             */
            httpUpgrade?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecHttpUpgradePatch>[]>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecLoadBalancerPatch>;
            /**
             * MergeType determines how this configuration is merged with existing BackendTrafficPolicy
             * configurations targeting a parent resource. When set, this configuration will be merged
             * into a parent BackendTrafficPolicy (i.e. the one targeting a Gateway or Listener).
             * This field cannot be set when targeting a parent resource (Gateway).
             * If unset, no merging occurs, and only the most specific configuration takes effect.
             */
            mergeType?: pulumi.Input<string>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecProxyProtocolPatch>;
            rateLimit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitPatch>;
            requestBuffer?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRequestBufferPatch>;
            /**
             * ResponseOverride defines the configuration to override specific responses with a custom one.
             * If multiple configurations are specified, the first one to match wins.
             */
            responseOverride?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverridePatch>[]>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryPatch>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetRefPatch>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetRefsPatch>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetSelectorsPatch>[]>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTcpKeepalivePatch>;
            telemetry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetryPatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeoutPatch>;
            /**
             * UseClientProtocol configures Envoy to prefer sending requests to backends using
             * the same HTTP protocol that the incoming request used. Defaults to false, which means
             * that Envoy will use the protocol indicated by the attached BackendRef.
             */
            useClientProtocol?: pulumi.Input<boolean>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface BackendTrafficPolicySpecProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface BackendTrafficPolicySpecProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * RateLimit allows the user to limit the number of incoming requests
         * to a predefined value based on attributes within the traffic flow.
         */
        interface BackendTrafficPolicySpecRateLimit {
            global?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobal>;
            local?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocal>;
            /**
             * Type decides the scope for the RateLimits.
             * Valid RateLimitType values are "Global" or "Local".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Global defines global rate limit configuration.
         */
        interface BackendTrafficPolicySpecRateLimitGlobal {
            /**
             * Rules are a list of RateLimit selectors and limits. Each rule and its
             * associated limit is applied in a mutually exclusive way. If a request
             * matches multiple rules, each of their associated limits get applied, so a
             * single request might increase the rate limit counters for multiple rules
             * if selected. The rate limit service will return a logical OR of the individual
             * rate limit decisions of all matching rules. For example, if a request
             * matches two rules, one rate limited and one not, the final decision will be
             * to rate limit the request.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRules>[]>;
        }
        /**
         * Global defines global rate limit configuration.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalPatch {
            /**
             * Rules are a list of RateLimit selectors and limits. Each rule and its
             * associated limit is applied in a mutually exclusive way. If a request
             * matches multiple rules, each of their associated limits get applied, so a
             * single request might increase the rate limit counters for multiple rules
             * if selected. The rate limit service will return a logical OR of the individual
             * rate limit decisions of all matching rules. For example, if a request
             * matches two rules, one rate limited and one not, the final decision will be
             * to rate limit the request.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesPatch>[]>;
        }
        /**
         * RateLimitRule defines the semantics for matching attributes
         * from the incoming requests, and setting limits for them.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRules {
            /**
             * ClientSelectors holds the list of select conditions to select
             * specific clients using attributes from the traffic flow.
             * All individual select conditions must hold True for this rule
             * and its limit to be applied.
             *
             * If no client selectors are specified, the rule applies to all traffic of
             * the targeted Route.
             *
             * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
             * Please note that each Route has its own rate limit counters. For example,
             * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
             * each Route will have its own 10rps limit.
             */
            clientSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors>[]>;
            cost?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCost>;
            limit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesLimit>;
            /**
             * Shared determines whether this rate limit rule applies across all the policy targets.
             * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
             * Default: false.
             */
            shared?: pulumi.Input<boolean>;
        }
        /**
         * RateLimitSelectCondition specifies the attributes within the traffic flow that can
         * be used to select a subset of clients to be ratelimited.
         * All the individual conditions must hold True for the overall condition to hold True.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectors {
            /**
             * Headers is a list of request headers to match. Multiple header values are ANDed together,
             * meaning, a request MUST match all the specified headers.
             * At least one of headers or sourceCIDR condition must be specified.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders>[]>;
            sourceCIDR?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDR>;
        }
        /**
         * HeaderMatch defines the match attributes within the HTTP Headers of the request.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeaders {
            /**
             * Invert specifies whether the value match result will be inverted.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            invert?: pulumi.Input<boolean>;
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value within the HTTP header.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * HeaderMatch defines the match attributes within the HTTP Headers of the request.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeadersPatch {
            /**
             * Invert specifies whether the value match result will be inverted.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            invert?: pulumi.Input<boolean>;
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value within the HTTP header.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * RateLimitSelectCondition specifies the attributes within the traffic flow that can
         * be used to select a subset of clients to be ratelimited.
         * All the individual conditions must hold True for the overall condition to hold True.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPatch {
            /**
             * Headers is a list of request headers to match. Multiple header values are ANDed together,
             * meaning, a request MUST match all the specified headers.
             * At least one of headers or sourceCIDR condition must be specified.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsHeadersPatch>[]>;
            sourceCIDR?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDRPatch>;
        }
        /**
         * SourceCIDR is the client IP Address range to match on.
         * At least one of headers or sourceCIDR condition must be specified.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDR {
            type?: pulumi.Input<string>;
            /**
             * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
             * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
             * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * SourceCIDR is the client IP Address range to match on.
         * At least one of headers or sourceCIDR condition must be specified.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsSourceCIDRPatch {
            type?: pulumi.Input<string>;
            /**
             * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
             * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
             * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Cost specifies the cost of requests and responses for the rule.
         *
         * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
         * the request path and do not reduce the rate limit counters on the response path.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCost {
            request?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse>;
        }
        /**
         * Cost specifies the cost of requests and responses for the rule.
         *
         * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
         * the request path and do not reduce the rate limit counters on the response path.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostPatch {
            request?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestPatch>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponsePatch>;
        }
        /**
         * Request specifies the number to reduce the rate limit counters
         * on the request path. If this is not specified, the default behavior
         * is to reduce the rate limit counters by 1.
         *
         * When Envoy receives a request that matches the rule, it tries to reduce the
         * rate limit counters by the specified number. If the counter doesn't have
         * enough capacity, the request is rate limited.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequest {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadata {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadataPatch {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Request specifies the number to reduce the rate limit counters
         * on the request path. If this is not specified, the default behavior
         * is to reduce the rate limit counters by 1.
         *
         * When Envoy receives a request that matches the rule, it tries to reduce the
         * rate limit counters by the specified number. If the counter doesn't have
         * enough capacity, the request is rate limited.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestPatch {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostRequestMetadataPatch>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Response specifies the number to reduce the rate limit counters
         * after the response is sent back to the client or the request stream is closed.
         *
         * The cost is used to reduce the rate limit counters for the matching requests.
         * Since the reduction happens after the request stream is complete, the rate limit
         * won't be enforced for the current request, but for the subsequent matching requests.
         *
         * This is optional and if not specified, the rate limit counters are not reduced
         * on the response path.
         *
         * Currently, this is only supported for HTTP Global Rate Limits.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponse {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadata {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadataPatch {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Response specifies the number to reduce the rate limit counters
         * after the response is sent back to the client or the request stream is closed.
         *
         * The cost is used to reduce the rate limit counters for the matching requests.
         * Since the reduction happens after the request stream is complete, the rate limit
         * won't be enforced for the current request, but for the subsequent matching requests.
         *
         * This is optional and if not specified, the rate limit counters are not reduced
         * on the response path.
         *
         * Currently, this is only supported for HTTP Global Rate Limits.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesCostResponsePatch {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostResponseMetadataPatch>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Limit holds the rate limit values.
         * This limit is applied for traffic flows when the selectors
         * compute to True, causing the request to be counted towards the limit.
         * The limit is enforced and the request is ratelimited, i.e. a response with
         * 429 HTTP status code is sent back to the client when
         * the selected requests have reached the limit.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesLimit {
            requests?: pulumi.Input<number>;
            /**
             * RateLimitUnit specifies the intervals for setting rate limits.
             * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
             */
            unit?: pulumi.Input<string>;
        }
        /**
         * Limit holds the rate limit values.
         * This limit is applied for traffic flows when the selectors
         * compute to True, causing the request to be counted towards the limit.
         * The limit is enforced and the request is ratelimited, i.e. a response with
         * 429 HTTP status code is sent back to the client when
         * the selected requests have reached the limit.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesLimitPatch {
            requests?: pulumi.Input<number>;
            /**
             * RateLimitUnit specifies the intervals for setting rate limits.
             * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
             */
            unit?: pulumi.Input<string>;
        }
        /**
         * RateLimitRule defines the semantics for matching attributes
         * from the incoming requests, and setting limits for them.
         */
        interface BackendTrafficPolicySpecRateLimitGlobalRulesPatch {
            /**
             * ClientSelectors holds the list of select conditions to select
             * specific clients using attributes from the traffic flow.
             * All individual select conditions must hold True for this rule
             * and its limit to be applied.
             *
             * If no client selectors are specified, the rule applies to all traffic of
             * the targeted Route.
             *
             * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
             * Please note that each Route has its own rate limit counters. For example,
             * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
             * each Route will have its own 10rps limit.
             */
            clientSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesClientSelectorsPatch>[]>;
            cost?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesCostPatch>;
            limit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalRulesLimitPatch>;
            /**
             * Shared determines whether this rate limit rule applies across all the policy targets.
             * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
             * Default: false.
             */
            shared?: pulumi.Input<boolean>;
        }
        /**
         * Local defines local rate limit configuration.
         */
        interface BackendTrafficPolicySpecRateLimitLocal {
            /**
             * Rules are a list of RateLimit selectors and limits. If a request matches
             * multiple rules, the strictest limit is applied. For example, if a request
             * matches two rules, one with 10rps and one with 20rps, the final limit will
             * be based on the rule with 10rps.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRules>[]>;
        }
        /**
         * Local defines local rate limit configuration.
         */
        interface BackendTrafficPolicySpecRateLimitLocalPatch {
            /**
             * Rules are a list of RateLimit selectors and limits. If a request matches
             * multiple rules, the strictest limit is applied. For example, if a request
             * matches two rules, one with 10rps and one with 20rps, the final limit will
             * be based on the rule with 10rps.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesPatch>[]>;
        }
        /**
         * RateLimitRule defines the semantics for matching attributes
         * from the incoming requests, and setting limits for them.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRules {
            /**
             * ClientSelectors holds the list of select conditions to select
             * specific clients using attributes from the traffic flow.
             * All individual select conditions must hold True for this rule
             * and its limit to be applied.
             *
             * If no client selectors are specified, the rule applies to all traffic of
             * the targeted Route.
             *
             * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
             * Please note that each Route has its own rate limit counters. For example,
             * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
             * each Route will have its own 10rps limit.
             */
            clientSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors>[]>;
            cost?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCost>;
            limit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesLimit>;
            /**
             * Shared determines whether this rate limit rule applies across all the policy targets.
             * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
             * Default: false.
             */
            shared?: pulumi.Input<boolean>;
        }
        /**
         * RateLimitSelectCondition specifies the attributes within the traffic flow that can
         * be used to select a subset of clients to be ratelimited.
         * All the individual conditions must hold True for the overall condition to hold True.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectors {
            /**
             * Headers is a list of request headers to match. Multiple header values are ANDed together,
             * meaning, a request MUST match all the specified headers.
             * At least one of headers or sourceCIDR condition must be specified.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders>[]>;
            sourceCIDR?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDR>;
        }
        /**
         * HeaderMatch defines the match attributes within the HTTP Headers of the request.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeaders {
            /**
             * Invert specifies whether the value match result will be inverted.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            invert?: pulumi.Input<boolean>;
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value within the HTTP header.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * HeaderMatch defines the match attributes within the HTTP Headers of the request.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeadersPatch {
            /**
             * Invert specifies whether the value match result will be inverted.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            invert?: pulumi.Input<boolean>;
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against the value of the header.
             */
            type?: pulumi.Input<string>;
            /**
             * Value within the HTTP header.
             * Do not set this field when Type="Distinct", implying matching on any/all unique
             * values within the header.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * RateLimitSelectCondition specifies the attributes within the traffic flow that can
         * be used to select a subset of clients to be ratelimited.
         * All the individual conditions must hold True for the overall condition to hold True.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPatch {
            /**
             * Headers is a list of request headers to match. Multiple header values are ANDed together,
             * meaning, a request MUST match all the specified headers.
             * At least one of headers or sourceCIDR condition must be specified.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsHeadersPatch>[]>;
            sourceCIDR?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDRPatch>;
        }
        /**
         * SourceCIDR is the client IP Address range to match on.
         * At least one of headers or sourceCIDR condition must be specified.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDR {
            type?: pulumi.Input<string>;
            /**
             * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
             * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
             * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * SourceCIDR is the client IP Address range to match on.
         * At least one of headers or sourceCIDR condition must be specified.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsSourceCIDRPatch {
            type?: pulumi.Input<string>;
            /**
             * Value is the IP CIDR that represents the range of Source IP Addresses of the client.
             * These could also be the intermediate addresses through which the request has flown through and is part of the  `X-Forwarded-For` header.
             * For example, `192.168.0.1/32`, `192.168.0.0/24`, `001:db8::/64`.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Cost specifies the cost of requests and responses for the rule.
         *
         * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
         * the request path and do not reduce the rate limit counters on the response path.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCost {
            request?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequest>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponse>;
        }
        /**
         * Cost specifies the cost of requests and responses for the rule.
         *
         * This is optional and if not specified, the default behavior is to reduce the rate limit counters by 1 on
         * the request path and do not reduce the rate limit counters on the response path.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostPatch {
            request?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequestPatch>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponsePatch>;
        }
        /**
         * Request specifies the number to reduce the rate limit counters
         * on the request path. If this is not specified, the default behavior
         * is to reduce the rate limit counters by 1.
         *
         * When Envoy receives a request that matches the rule, it tries to reduce the
         * rate limit counters by the specified number. If the counter doesn't have
         * enough capacity, the request is rate limited.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequest {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadata {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadataPatch {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Request specifies the number to reduce the rate limit counters
         * on the request path. If this is not specified, the default behavior
         * is to reduce the rate limit counters by 1.
         *
         * When Envoy receives a request that matches the rule, it tries to reduce the
         * rate limit counters by the specified number. If the counter doesn't have
         * enough capacity, the request is rate limited.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostRequestPatch {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostRequestMetadataPatch>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Response specifies the number to reduce the rate limit counters
         * after the response is sent back to the client or the request stream is closed.
         *
         * The cost is used to reduce the rate limit counters for the matching requests.
         * Since the reduction happens after the request stream is complete, the rate limit
         * won't be enforced for the current request, but for the subsequent matching requests.
         *
         * This is optional and if not specified, the rate limit counters are not reduced
         * on the response path.
         *
         * Currently, this is only supported for HTTP Global Rate Limits.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponse {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadata {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Metadata specifies the per-request metadata to retrieve the usage number from.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadataPatch {
            /**
             * Key is the key to retrieve the usage number from the filter metadata.
             */
            key?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the dynamic metadata.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * Response specifies the number to reduce the rate limit counters
         * after the response is sent back to the client or the request stream is closed.
         *
         * The cost is used to reduce the rate limit counters for the matching requests.
         * Since the reduction happens after the request stream is complete, the rate limit
         * won't be enforced for the current request, but for the subsequent matching requests.
         *
         * This is optional and if not specified, the rate limit counters are not reduced
         * on the response path.
         *
         * Currently, this is only supported for HTTP Global Rate Limits.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesCostResponsePatch {
            /**
             * From specifies where to get the rate limit cost. Currently, only "Number" and "Metadata" are supported.
             */
            from?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostResponseMetadataPatch>;
            /**
             * Number specifies the fixed usage number to reduce the rate limit counters.
             * Using zero can be used to only check the rate limit counters without reducing them.
             */
            number?: pulumi.Input<number>;
        }
        /**
         * Limit holds the rate limit values.
         * This limit is applied for traffic flows when the selectors
         * compute to True, causing the request to be counted towards the limit.
         * The limit is enforced and the request is ratelimited, i.e. a response with
         * 429 HTTP status code is sent back to the client when
         * the selected requests have reached the limit.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesLimit {
            requests?: pulumi.Input<number>;
            /**
             * RateLimitUnit specifies the intervals for setting rate limits.
             * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
             */
            unit?: pulumi.Input<string>;
        }
        /**
         * Limit holds the rate limit values.
         * This limit is applied for traffic flows when the selectors
         * compute to True, causing the request to be counted towards the limit.
         * The limit is enforced and the request is ratelimited, i.e. a response with
         * 429 HTTP status code is sent back to the client when
         * the selected requests have reached the limit.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesLimitPatch {
            requests?: pulumi.Input<number>;
            /**
             * RateLimitUnit specifies the intervals for setting rate limits.
             * Valid RateLimitUnit values are "Second", "Minute", "Hour", "Day", "Month" and "Year".
             */
            unit?: pulumi.Input<string>;
        }
        /**
         * RateLimitRule defines the semantics for matching attributes
         * from the incoming requests, and setting limits for them.
         */
        interface BackendTrafficPolicySpecRateLimitLocalRulesPatch {
            /**
             * ClientSelectors holds the list of select conditions to select
             * specific clients using attributes from the traffic flow.
             * All individual select conditions must hold True for this rule
             * and its limit to be applied.
             *
             * If no client selectors are specified, the rule applies to all traffic of
             * the targeted Route.
             *
             * If the policy targets a Gateway, the rule applies to each Route of the Gateway.
             * Please note that each Route has its own rate limit counters. For example,
             * if a Gateway has two Routes, and the policy has a rule with limit 10rps,
             * each Route will have its own 10rps limit.
             */
            clientSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesClientSelectorsPatch>[]>;
            cost?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesCostPatch>;
            limit?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalRulesLimitPatch>;
            /**
             * Shared determines whether this rate limit rule applies across all the policy targets.
             * If set to true, the rule is treated as a common bucket and is shared across all policy targets (xRoutes).
             * Default: false.
             */
            shared?: pulumi.Input<boolean>;
        }
        /**
         * RateLimit allows the user to limit the number of incoming requests
         * to a predefined value based on attributes within the traffic flow.
         */
        interface BackendTrafficPolicySpecRateLimitPatch {
            global?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitGlobalPatch>;
            local?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRateLimitLocalPatch>;
            /**
             * Type decides the scope for the RateLimits.
             * Valid RateLimitType values are "Global" or "Local".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
         * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
         * as any requests larger than the buffer size will be rejected.
         *
         * This can have a negative performance impact so should only be enabled when necessary.
         *
         * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
         * increase in memory usage for Envoy that should be accounted for in your deployment settings.
         */
        interface BackendTrafficPolicySpecRequestBuffer {
            /**
             * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
             * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
             *
             * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
             */
            limit?: pulumi.Input<number | string>;
        }
        /**
         * RequestBuffer allows the gateway to buffer and fully receive each request from a client before continuing to send the request
         * upstream to the backends. This can be helpful to shield your backend servers from slow clients, and also to enforce a maximum size per request
         * as any requests larger than the buffer size will be rejected.
         *
         * This can have a negative performance impact so should only be enabled when necessary.
         *
         * When enabling this option, you should also configure your connection buffer size to account for these request buffers. There will also be an
         * increase in memory usage for Envoy that should be accounted for in your deployment settings.
         */
        interface BackendTrafficPolicySpecRequestBufferPatch {
            /**
             * Limit specifies the maximum allowed size in bytes for each incoming request buffer.
             * If exceeded, the request will be rejected with HTTP 413 Content Too Large.
             *
             * Accepts values in resource.Quantity format (e.g., "10Mi", "500Ki").
             */
            limit?: pulumi.Input<number | string>;
        }
        /**
         * ResponseOverride defines the configuration to override specific responses with a custom one.
         */
        interface BackendTrafficPolicySpecResponseOverride {
            match?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatch>;
            redirect?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirect>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponse>;
        }
        /**
         * Match configuration.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatch {
            /**
             * Status code to match on. The match evaluates to true if any of the matches are successful.
             */
            statusCodes?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodes>[]>;
        }
        /**
         * Match configuration.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatchPatch {
            /**
             * Status code to match on. The match evaluates to true if any of the matches are successful.
             */
            statusCodes?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodesPatch>[]>;
        }
        /**
         * StatusCodeMatch defines the configuration for matching a status code.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodes {
            range?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange>;
            /**
             * Type is the type of value.
             * Valid values are Value and Range, default is Value.
             */
            type?: pulumi.Input<string>;
            /**
             * Value contains the value of the status code.
             */
            value?: pulumi.Input<number>;
        }
        /**
         * StatusCodeMatch defines the configuration for matching a status code.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodesPatch {
            range?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRangePatch>;
            /**
             * Type is the type of value.
             * Valid values are Value and Range, default is Value.
             */
            type?: pulumi.Input<string>;
            /**
             * Value contains the value of the status code.
             */
            value?: pulumi.Input<number>;
        }
        /**
         * Range contains the range of status codes.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRange {
            /**
             * End of the range, including the end value.
             */
            end?: pulumi.Input<number>;
            /**
             * Start of the range, including the start value.
             */
            start?: pulumi.Input<number>;
        }
        /**
         * Range contains the range of status codes.
         */
        interface BackendTrafficPolicySpecResponseOverrideMatchStatusCodesRangePatch {
            /**
             * End of the range, including the end value.
             */
            end?: pulumi.Input<number>;
            /**
             * Start of the range, including the start value.
             */
            start?: pulumi.Input<number>;
        }
        /**
         * ResponseOverride defines the configuration to override specific responses with a custom one.
         */
        interface BackendTrafficPolicySpecResponseOverridePatch {
            match?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideMatchPatch>;
            redirect?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirectPatch>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponsePatch>;
        }
        /**
         * Redirect configuration
         */
        interface BackendTrafficPolicySpecResponseOverrideRedirect {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             */
            hostname?: pulumi.Input<string>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirectPath>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             * If redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.
             * Specifically "http" to port 80 and "https" to port 443. If the redirect scheme does not have a
             * well-known port or redirect scheme is empty, the listener port of the Gateway will be used.
             *
             * Port will not be added in the 'Location' header if scheme is HTTP and port is 80
             * or scheme is HTTPS and port is 443.
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Redirect configuration
         */
        interface BackendTrafficPolicySpecResponseOverrideRedirectPatch {
            /**
             * Hostname is the hostname to be used in the value of the `Location`
             * header in the response.
             * When empty, the hostname in the `Host` header of the request is used.
             */
            hostname?: pulumi.Input<string>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideRedirectPathPatch>;
            /**
             * Port is the port to be used in the value of the `Location`
             * header in the response.
             *
             * If redirect scheme is not-empty, the well-known port associated with the redirect scheme will be used.
             * Specifically "http" to port 80 and "https" to port 443. If the redirect scheme does not have a
             * well-known port or redirect scheme is empty, the listener port of the Gateway will be used.
             *
             * Port will not be added in the 'Location' header if scheme is HTTP and port is 80
             * or scheme is HTTPS and port is 443.
             */
            port?: pulumi.Input<number>;
            /**
             * Scheme is the scheme to be used in the value of the `Location` header in
             * the response. When empty, the scheme of the request is used.
             */
            scheme?: pulumi.Input<string>;
            /**
             * StatusCode is the HTTP status code to be used in response.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         * Only ReplaceFullPath path modifier is supported currently.
         */
        interface BackendTrafficPolicySpecResponseOverrideRedirectPath {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Path defines parameters used to modify the path of the incoming request.
         * The modified path is then used to construct the `Location` header. When
         * empty, the request path is used as-is.
         * Only ReplaceFullPath path modifier is supported currently.
         */
        interface BackendTrafficPolicySpecResponseOverrideRedirectPathPatch {
            /**
             * ReplaceFullPath specifies the value with which to replace the full path
             * of a request during a rewrite or redirect.
             */
            replaceFullPath?: pulumi.Input<string>;
            /**
             * ReplacePrefixMatch specifies the value with which to replace the prefix
             * match of a request during a rewrite or redirect. For example, a request
             * to "/foo/bar" with a prefix match of "/foo" and a ReplacePrefixMatch
             * of "/xyz" would be modified to "/xyz/bar".
             *
             * Note that this matches the behavior of the PathPrefix match type. This
             * matches full path elements. A path element refers to the list of labels
             * in the path split by the `/` separator. When specified, a trailing `/` is
             * ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
             * match the prefix `/abc`, but the path `/abcd` would not.
             *
             * ReplacePrefixMatch is only compatible with a `PathPrefix` HTTPRouteMatch.
             * Using any other HTTPRouteMatch type on the same HTTPRouteRule will result in
             * the implementation setting the Accepted Condition for the Route to `status: False`.
             *
             * Request Path | Prefix Match | Replace Prefix | Modified Path
             */
            replacePrefixMatch?: pulumi.Input<string>;
            /**
             * Type defines the type of path modifier. Additional types may be
             * added in a future release of the API.
             *
             * Note that values may be added to this enum, implementations
             * must ensure that unknown values will not cause a crash.
             *
             * Unknown values here must result in the implementation setting the
             * Accepted Condition for the Route to `status: False`, with a
             * Reason of `UnsupportedValue`.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Response configuration.
         */
        interface BackendTrafficPolicySpecResponseOverrideResponse {
            body?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBody>;
            /**
             * Content Type of the response. This will be set in the Content-Type header.
             */
            contentType?: pulumi.Input<string>;
            /**
             * Status Code of the Custom Response
             * If unset, does not override the status of response.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Body of the Custom Response
         * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
         */
        interface BackendTrafficPolicySpecResponseOverrideResponseBody {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef>;
        }
        /**
         * Body of the Custom Response
         * Supports Envoy command operators for dynamic content (see https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators).
         */
        interface BackendTrafficPolicySpecResponseOverrideResponseBodyPatch {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBodyValueRefPatch>;
        }
        /**
         * ValueRef contains the contents of the body
         * specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         *
         * The value of key `response.body` in the ConfigMap will be used as the response body.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface BackendTrafficPolicySpecResponseOverrideResponseBodyValueRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ValueRef contains the contents of the body
         * specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         *
         * The value of key `response.body` in the ConfigMap will be used as the response body.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface BackendTrafficPolicySpecResponseOverrideResponseBodyValueRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Response configuration.
         */
        interface BackendTrafficPolicySpecResponseOverrideResponsePatch {
            body?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecResponseOverrideResponseBodyPatch>;
            /**
             * Content Type of the response. This will be set in the Content-Type header.
             */
            contentType?: pulumi.Input<string>;
            /**
             * Status Code of the Custom Response
             * If unset, does not override the status of response.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface BackendTrafficPolicySpecRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface BackendTrafficPolicySpecRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface BackendTrafficPolicySpecRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface BackendTrafficPolicySpecRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface BackendTrafficPolicySpecRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface BackendTrafficPolicySpecRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface BackendTrafficPolicySpecRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface BackendTrafficPolicySpecRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface BackendTrafficPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface BackendTrafficPolicySpecTargetRefPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface BackendTrafficPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface BackendTrafficPolicySpecTargetRefsPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        interface BackendTrafficPolicySpecTargetSelectors {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetSelectorsMatchExpressions>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface BackendTrafficPolicySpecTargetSelectorsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface BackendTrafficPolicySpecTargetSelectorsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        interface BackendTrafficPolicySpecTargetSelectorsPatch {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTargetSelectorsMatchExpressionsPatch>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface BackendTrafficPolicySpecTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface BackendTrafficPolicySpecTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
         * This will override the telemetry settings in the EnvoyProxy resource.
         */
        interface BackendTrafficPolicySpecTelemetry {
            tracing?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetryTracing>;
        }
        /**
         * Telemetry configures the telemetry settings for the policy target (Gateway or xRoute).
         * This will override the telemetry settings in the EnvoyProxy resource.
         */
        interface BackendTrafficPolicySpecTelemetryPatch {
            tracing?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetryTracingPatch>;
        }
        /**
         * Tracing configures the tracing settings for the backend or HTTPRoute.
         */
        interface BackendTrafficPolicySpecTelemetryTracing {
            /**
             * CustomTags defines the custom tags to add to each span.
             * If provider is kubernetes, pod name and namespace are added by default.
             */
            customTags?: pulumi.Input<{
                [key: string]: pulumi.Input<{
                    [key: string]: pulumi.Input<string>;
                }>;
            }>;
            samplingFraction?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSamplingFraction>;
        }
        /**
         * Tracing configures the tracing settings for the backend or HTTPRoute.
         */
        interface BackendTrafficPolicySpecTelemetryTracingPatch {
            /**
             * CustomTags defines the custom tags to add to each span.
             * If provider is kubernetes, pod name and namespace are added by default.
             */
            customTags?: pulumi.Input<{
                [key: string]: pulumi.Input<{
                    [key: string]: pulumi.Input<string>;
                }>;
            }>;
            samplingFraction?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTelemetryTracingSamplingFractionPatch>;
        }
        /**
         * SamplingFraction represents the fraction of requests that should be
         * selected for tracing if no prior sampling decision has been made.
         *
         * This will take precedence over sampling fraction on EnvoyProxy if set.
         */
        interface BackendTrafficPolicySpecTelemetryTracingSamplingFraction {
            denominator?: pulumi.Input<number>;
            numerator?: pulumi.Input<number>;
        }
        /**
         * SamplingFraction represents the fraction of requests that should be
         * selected for tracing if no prior sampling decision has been made.
         *
         * This will take precedence over sampling fraction on EnvoyProxy if set.
         */
        interface BackendTrafficPolicySpecTelemetryTracingSamplingFractionPatch {
            denominator?: pulumi.Input<number>;
            numerator?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface BackendTrafficPolicySpecTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface BackendTrafficPolicySpecTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface BackendTrafficPolicySpecTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface BackendTrafficPolicySpecTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicySpecTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface BackendTrafficPolicySpecTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface BackendTrafficPolicySpecTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * status defines the current status of BackendTrafficPolicy.
         */
        interface BackendTrafficPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicyStatusAncestors>[]>;
        }
        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        interface BackendTrafficPolicyStatusAncestors {
            ancestorRef?: pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicyStatusAncestorsAncestorRef>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.BackendTrafficPolicyStatusAncestorsConditions>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             * Example: "example.net/gateway-controller".
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName?: pulumi.Input<string>;
        }
        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        interface BackendTrafficPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             * There are two kinds of parent resources with "Core" support:
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             * Support: Core
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             * <gateway:experimental:description>
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             * </gateway:experimental:description>
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             * <gateway:experimental:description>
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             * </gateway:experimental:description>
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface BackendTrafficPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ClientTrafficPolicy allows the user to configure the behavior of the connection
         * between the downstream client and Envoy Proxy listener.
         */
        interface ClientTrafficPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"ClientTrafficPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicyStatus>;
        }
        /**
         * Spec defines the desired state of ClientTrafficPolicy.
         */
        interface ClientTrafficPolicySpec {
            clientIPDetection?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetection>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecConnection>;
            /**
             * EnableProxyProtocol interprets the ProxyProtocol header and adds the
             * Client Address into the X-Forwarded-For header.
             * Note Proxy Protocol must be present when this field is set, else the connection
             * is closed.
             *
             * Deprecated: Use ProxyProtocol instead.
             */
            enableProxyProtocol?: pulumi.Input<boolean>;
            headers?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeaders>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHealthCheck>;
            http1?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp1>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp2>;
            /**
             * HTTP3 provides HTTP/3 configuration on the listener.
             */
            http3?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecPath>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecProxyProtocol>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetRef>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetRefs>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetSelectors>[]>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeout>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTls>;
        }
        /**
         * ClientIPDetectionSettings provides configuration for determining the original client IP address for requests.
         */
        interface ClientTrafficPolicySpecClientIPDetection {
            customHeader?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetectionCustomHeader>;
            xForwardedFor?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetectionXForwardedFor>;
        }
        /**
         * CustomHeader provides configuration for determining the client IP address for a request based on
         * a trusted custom HTTP header. This uses the custom_header original IP detection extension.
         * Refer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto
         * for more details.
         */
        interface ClientTrafficPolicySpecClientIPDetectionCustomHeader {
            /**
             * FailClosed is a switch used to control the flow of traffic when client IP detection
             * fails. If set to true, the listener will respond with 403 Forbidden when the client
             * IP address cannot be determined.
             */
            failClosed?: pulumi.Input<boolean>;
            /**
             * Name of the header containing the original downstream remote address, if present.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * CustomHeader provides configuration for determining the client IP address for a request based on
         * a trusted custom HTTP header. This uses the custom_header original IP detection extension.
         * Refer to https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/http/original_ip_detection/custom_header/v3/custom_header.proto
         * for more details.
         */
        interface ClientTrafficPolicySpecClientIPDetectionCustomHeaderPatch {
            /**
             * FailClosed is a switch used to control the flow of traffic when client IP detection
             * fails. If set to true, the listener will respond with 403 Forbidden when the client
             * IP address cannot be determined.
             */
            failClosed?: pulumi.Input<boolean>;
            /**
             * Name of the header containing the original downstream remote address, if present.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ClientIPDetectionSettings provides configuration for determining the original client IP address for requests.
         */
        interface ClientTrafficPolicySpecClientIPDetectionPatch {
            customHeader?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetectionCustomHeaderPatch>;
            xForwardedFor?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetectionXForwardedForPatch>;
        }
        /**
         * XForwardedForSettings provides configuration for using X-Forwarded-For headers for determining the client IP address.
         */
        interface ClientTrafficPolicySpecClientIPDetectionXForwardedFor {
            /**
             * NumTrustedHops controls the number of additional ingress proxy hops from the right side of XFF HTTP
             * headers to trust when determining the origin client's IP address.
             * Only one of NumTrustedHops and TrustedCIDRs must be set.
             */
            numTrustedHops?: pulumi.Input<number>;
            /**
             * TrustedCIDRs is a list of CIDR ranges to trust when evaluating
             * the remote IP address to determine the original client’s IP address.
             * When the remote IP address matches a trusted CIDR and the x-forwarded-for header was sent,
             * each entry in the x-forwarded-for header is evaluated from right to left
             * and the first public non-trusted address is used as the original client address.
             * If all addresses in x-forwarded-for are within the trusted list, the first (leftmost) entry is used.
             * Only one of NumTrustedHops and TrustedCIDRs must be set.
             */
            trustedCIDRs?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * XForwardedForSettings provides configuration for using X-Forwarded-For headers for determining the client IP address.
         */
        interface ClientTrafficPolicySpecClientIPDetectionXForwardedForPatch {
            /**
             * NumTrustedHops controls the number of additional ingress proxy hops from the right side of XFF HTTP
             * headers to trust when determining the origin client's IP address.
             * Only one of NumTrustedHops and TrustedCIDRs must be set.
             */
            numTrustedHops?: pulumi.Input<number>;
            /**
             * TrustedCIDRs is a list of CIDR ranges to trust when evaluating
             * the remote IP address to determine the original client’s IP address.
             * When the remote IP address matches a trusted CIDR and the x-forwarded-for header was sent,
             * each entry in the x-forwarded-for header is evaluated from right to left
             * and the first public non-trusted address is used as the original client address.
             * If all addresses in x-forwarded-for are within the trusted list, the first (leftmost) entry is used.
             * Only one of NumTrustedHops and TrustedCIDRs must be set.
             */
            trustedCIDRs?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Connection includes client connection settings.
         */
        interface ClientTrafficPolicySpecConnection {
            /**
             * BufferLimit provides configuration for the maximum buffer size in bytes for each incoming connection.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             * Default: 32768 bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            connectionLimit?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecConnectionConnectionLimit>;
            /**
             * MaxAcceptPerSocketEvent provides configuration for the maximum number of connections to accept from the kernel
             * per socket event. If there are more than MaxAcceptPerSocketEvent connections pending accept, connections over
             * this threshold will be accepted in later event loop iterations.
             * Defaults to 1 and can be disabled by setting to 0 for allowing unlimited accepted connections.
             */
            maxAcceptPerSocketEvent?: pulumi.Input<number>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each incoming socket.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * ConnectionLimit defines limits related to connections
         */
        interface ClientTrafficPolicySpecConnectionConnectionLimit {
            /**
             * CloseDelay defines the delay to use before closing connections that are rejected
             * once the limit value is reached.
             * Default: none.
             */
            closeDelay?: pulumi.Input<string>;
            /**
             * Value of the maximum concurrent connections limit.
             * When the limit is reached, incoming connections will be closed after the CloseDelay duration.
             */
            value?: pulumi.Input<number>;
        }
        /**
         * ConnectionLimit defines limits related to connections
         */
        interface ClientTrafficPolicySpecConnectionConnectionLimitPatch {
            /**
             * CloseDelay defines the delay to use before closing connections that are rejected
             * once the limit value is reached.
             * Default: none.
             */
            closeDelay?: pulumi.Input<string>;
            /**
             * Value of the maximum concurrent connections limit.
             * When the limit is reached, incoming connections will be closed after the CloseDelay duration.
             */
            value?: pulumi.Input<number>;
        }
        /**
         * Connection includes client connection settings.
         */
        interface ClientTrafficPolicySpecConnectionPatch {
            /**
             * BufferLimit provides configuration for the maximum buffer size in bytes for each incoming connection.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             * Default: 32768 bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            connectionLimit?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecConnectionConnectionLimitPatch>;
            /**
             * MaxAcceptPerSocketEvent provides configuration for the maximum number of connections to accept from the kernel
             * per socket event. If there are more than MaxAcceptPerSocketEvent connections pending accept, connections over
             * this threshold will be accepted in later event loop iterations.
             * Defaults to 1 and can be disabled by setting to 0 for allowing unlimited accepted connections.
             */
            maxAcceptPerSocketEvent?: pulumi.Input<number>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each incoming socket.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * HeaderSettings provides configuration for header management.
         */
        interface ClientTrafficPolicySpecHeaders {
            /**
             * DisableRateLimitHeaders configures Envoy Proxy to omit the "X-RateLimit-" response headers
             * when rate limiting is enabled.
             */
            disableRateLimitHeaders?: pulumi.Input<boolean>;
            earlyRequestHeaders?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeaders>;
            /**
             * EnableEnvoyHeaders configures Envoy Proxy to add the "X-Envoy-" headers to requests
             * and responses.
             */
            enableEnvoyHeaders?: pulumi.Input<boolean>;
            /**
             * PreserveXRequestID configures Envoy to keep the X-Request-ID header if passed for a request that is edge
             * (Edge request is the request from external clients to front Envoy) and not reset it, which is the current Envoy behaviour.
             * Defaults to false and cannot be combined with RequestID.
             * Deprecated: use RequestID=Preserve instead
             */
            preserveXRequestID?: pulumi.Input<boolean>;
            /**
             * RequestID configures Envoy's behavior for handling the `X-Request-ID` header.
             * Defaults to `Generate` and builds the `X-Request-ID` for every request and ignores pre-existing values from the edge.
             * (An "edge request" refers to a request from an external client to the Envoy entrypoint.)
             */
            requestID?: pulumi.Input<string>;
            /**
             * WithUnderscoresAction configures the action to take when an HTTP header with underscores
             * is encountered. The default action is to reject the request.
             */
            withUnderscoresAction?: pulumi.Input<string>;
            xForwardedClientCert?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersXForwardedClientCert>;
        }
        /**
         * EarlyRequestHeaders defines settings for early request header modification, before envoy performs
         * routing, tracing and built-in header manipulation.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeaders {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet>[]>;
        }
        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersAdd {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersAddPatch {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * EarlyRequestHeaders defines settings for early request header modification, before envoy performs
         * routing, tracing and built-in header manipulation.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersPatch {
            /**
             * Add adds the given header(s) (name, value) to the request
             * before the action. It appends to any existing values associated
             * with the header name.
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             * Config:
             *   add:
             *   - name: "my-header"
             *     value: "bar,baz"
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: foo,bar,baz
             */
            add?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersAddPatch>[]>;
            /**
             * Remove the given header(s) from the HTTP request before the action. The
             * value of Remove is a list of HTTP header names. Note that the header
             * names are case-insensitive (see
             * https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header1: foo
             *   my-header2: bar
             *   my-header3: baz
             *
             * Config:
             *   remove: ["my-header1", "my-header3"]
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header2: bar
             */
            remove?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Set overwrites the request with the given header (name, value)
             * before the action.
             *
             * Input:
             *   GET /foo HTTP/1.1
             *   my-header: foo
             *
             * Config:
             *   set:
             *   - name: "my-header"
             *     value: "bar"
             *
             * Output:
             *   GET /foo HTTP/1.1
             *   my-header: bar
             */
            set?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersSetPatch>[]>;
        }
        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersSet {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader represents an HTTP Header name and value as defined by RFC 7230.
         */
        interface ClientTrafficPolicySpecHeadersEarlyRequestHeadersSetPatch {
            /**
             * Name is the name of the HTTP Header to be matched. Name matching MUST be
             * case-insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
             *
             * If multiple entries specify equivalent header names, the first entry with
             * an equivalent name MUST be considered for a match. Subsequent entries
             * with an equivalent header name MUST be ignored. Due to the
             * case-insensitivity of header names, "foo" and "Foo" are considered
             * equivalent.
             */
            name?: pulumi.Input<string>;
            /**
             * Value is the value of HTTP Header to be matched.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * HeaderSettings provides configuration for header management.
         */
        interface ClientTrafficPolicySpecHeadersPatch {
            /**
             * DisableRateLimitHeaders configures Envoy Proxy to omit the "X-RateLimit-" response headers
             * when rate limiting is enabled.
             */
            disableRateLimitHeaders?: pulumi.Input<boolean>;
            earlyRequestHeaders?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersEarlyRequestHeadersPatch>;
            /**
             * EnableEnvoyHeaders configures Envoy Proxy to add the "X-Envoy-" headers to requests
             * and responses.
             */
            enableEnvoyHeaders?: pulumi.Input<boolean>;
            /**
             * PreserveXRequestID configures Envoy to keep the X-Request-ID header if passed for a request that is edge
             * (Edge request is the request from external clients to front Envoy) and not reset it, which is the current Envoy behaviour.
             * Defaults to false and cannot be combined with RequestID.
             * Deprecated: use RequestID=Preserve instead
             */
            preserveXRequestID?: pulumi.Input<boolean>;
            /**
             * RequestID configures Envoy's behavior for handling the `X-Request-ID` header.
             * Defaults to `Generate` and builds the `X-Request-ID` for every request and ignores pre-existing values from the edge.
             * (An "edge request" refers to a request from an external client to the Envoy entrypoint.)
             */
            requestID?: pulumi.Input<string>;
            /**
             * WithUnderscoresAction configures the action to take when an HTTP header with underscores
             * is encountered. The default action is to reject the request.
             */
            withUnderscoresAction?: pulumi.Input<string>;
            xForwardedClientCert?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersXForwardedClientCertPatch>;
        }
        /**
         * XForwardedClientCert configures how Envoy Proxy handle the x-forwarded-client-cert (XFCC) HTTP header.
         *
         * x-forwarded-client-cert (XFCC) is an HTTP header used to forward the certificate
         * information of part or all of the clients or proxies that a request has flowed through,
         * on its way from the client to the server.
         *
         * Envoy proxy may choose to sanitize/append/forward the XFCC header before proxying the request.
         *
         * If not set, the default behavior is sanitizing the XFCC header.
         */
        interface ClientTrafficPolicySpecHeadersXForwardedClientCert {
            /**
             * CertDetailsToAdd specifies the fields in the client certificate to be forwarded in the XFCC header.
             *
             * Hash(the SHA 256 digest of the current client certificate) and By(the Subject Alternative Name)
             * are always included if the client certificate is forwarded.
             *
             * This field is only applicable when the mode is set to `AppendForward` or
             * `SanitizeSet` and the client connection is mTLS.
             */
            certDetailsToAdd?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Mode defines how XFCC header is handled by Envoy Proxy.
             * If not set, the default mode is `Sanitize`.
             */
            mode?: pulumi.Input<string>;
        }
        /**
         * XForwardedClientCert configures how Envoy Proxy handle the x-forwarded-client-cert (XFCC) HTTP header.
         *
         * x-forwarded-client-cert (XFCC) is an HTTP header used to forward the certificate
         * information of part or all of the clients or proxies that a request has flowed through,
         * on its way from the client to the server.
         *
         * Envoy proxy may choose to sanitize/append/forward the XFCC header before proxying the request.
         *
         * If not set, the default behavior is sanitizing the XFCC header.
         */
        interface ClientTrafficPolicySpecHeadersXForwardedClientCertPatch {
            /**
             * CertDetailsToAdd specifies the fields in the client certificate to be forwarded in the XFCC header.
             *
             * Hash(the SHA 256 digest of the current client certificate) and By(the Subject Alternative Name)
             * are always included if the client certificate is forwarded.
             *
             * This field is only applicable when the mode is set to `AppendForward` or
             * `SanitizeSet` and the client connection is mTLS.
             */
            certDetailsToAdd?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Mode defines how XFCC header is handled by Envoy Proxy.
             * If not set, the default mode is `Sanitize`.
             */
            mode?: pulumi.Input<string>;
        }
        /**
         * HealthCheck provides configuration for determining whether the HTTP/HTTPS listener is healthy.
         */
        interface ClientTrafficPolicySpecHealthCheck {
            /**
             * Path specifies the HTTP path to match on for health check requests.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * HealthCheck provides configuration for determining whether the HTTP/HTTPS listener is healthy.
         */
        interface ClientTrafficPolicySpecHealthCheckPatch {
            /**
             * Path specifies the HTTP path to match on for health check requests.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * HTTP1 provides HTTP/1 configuration on the listener.
         */
        interface ClientTrafficPolicySpecHttp1 {
            /**
             * EnableTrailers defines if HTTP/1 trailers should be proxied by Envoy.
             */
            enableTrailers?: pulumi.Input<boolean>;
            http10?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp1Http10>;
            /**
             * PreserveHeaderCase defines if Envoy should preserve the letter case of headers.
             * By default, Envoy will lowercase all the headers.
             */
            preserveHeaderCase?: pulumi.Input<boolean>;
        }
        /**
         * HTTP10 turns on support for HTTP/1.0 and HTTP/0.9 requests.
         */
        interface ClientTrafficPolicySpecHttp1Http10 {
            /**
             * UseDefaultHost defines if the HTTP/1.0 request is missing the Host header,
             * then the hostname associated with the listener should be injected into the
             * request.
             * If this is not set and an HTTP/1.0 request arrives without a host, then
             * it will be rejected.
             */
            useDefaultHost?: pulumi.Input<boolean>;
        }
        /**
         * HTTP10 turns on support for HTTP/1.0 and HTTP/0.9 requests.
         */
        interface ClientTrafficPolicySpecHttp1Http10Patch {
            /**
             * UseDefaultHost defines if the HTTP/1.0 request is missing the Host header,
             * then the hostname associated with the listener should be injected into the
             * request.
             * If this is not set and an HTTP/1.0 request arrives without a host, then
             * it will be rejected.
             */
            useDefaultHost?: pulumi.Input<boolean>;
        }
        /**
         * HTTP1 provides HTTP/1 configuration on the listener.
         */
        interface ClientTrafficPolicySpecHttp1Patch {
            /**
             * EnableTrailers defines if HTTP/1 trailers should be proxied by Envoy.
             */
            enableTrailers?: pulumi.Input<boolean>;
            http10?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp1Http10Patch>;
            /**
             * PreserveHeaderCase defines if Envoy should preserve the letter case of headers.
             * By default, Envoy will lowercase all the headers.
             */
            preserveHeaderCase?: pulumi.Input<boolean>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration on the listener.
         */
        interface ClientTrafficPolicySpecHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration on the listener.
         */
        interface ClientTrafficPolicySpecHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * Spec defines the desired state of ClientTrafficPolicy.
         */
        interface ClientTrafficPolicySpecPatch {
            clientIPDetection?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecClientIPDetectionPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecConnectionPatch>;
            /**
             * EnableProxyProtocol interprets the ProxyProtocol header and adds the
             * Client Address into the X-Forwarded-For header.
             * Note Proxy Protocol must be present when this field is set, else the connection
             * is closed.
             *
             * Deprecated: Use ProxyProtocol instead.
             */
            enableProxyProtocol?: pulumi.Input<boolean>;
            headers?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHeadersPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHealthCheckPatch>;
            http1?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp1Patch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecHttp2Patch>;
            /**
             * HTTP3 provides HTTP/3 configuration on the listener.
             */
            http3?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecPathPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecProxyProtocolPatch>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetRefPatch>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetRefsPatch>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetSelectorsPatch>[]>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeoutPatch>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsPatch>;
        }
        /**
         * Path enables managing how the incoming path set by clients can be normalized.
         */
        interface ClientTrafficPolicySpecPath {
            /**
             * DisableMergeSlashes allows disabling the default configuration of merging adjacent
             * slashes in the path.
             * Note that slash merging is not part of the HTTP spec and is provided for convenience.
             */
            disableMergeSlashes?: pulumi.Input<boolean>;
            /**
             * EscapedSlashesAction determines how %2f, %2F, %5c, or %5C sequences in the path URI
             * should be handled.
             * The default is UnescapeAndRedirect.
             */
            escapedSlashesAction?: pulumi.Input<string>;
        }
        /**
         * Path enables managing how the incoming path set by clients can be normalized.
         */
        interface ClientTrafficPolicySpecPathPatch {
            /**
             * DisableMergeSlashes allows disabling the default configuration of merging adjacent
             * slashes in the path.
             * Note that slash merging is not part of the HTTP spec and is provided for convenience.
             */
            disableMergeSlashes?: pulumi.Input<boolean>;
            /**
             * EscapedSlashesAction determines how %2f, %2F, %5c, or %5C sequences in the path URI
             * should be handled.
             * The default is UnescapeAndRedirect.
             */
            escapedSlashesAction?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol configures the Proxy Protocol settings. When configured,
         * the Proxy Protocol header will be interpreted and the Client Address
         * will be added into the X-Forwarded-For header.
         * If both EnableProxyProtocol and ProxyProtocol are set, ProxyProtocol takes precedence.
         */
        interface ClientTrafficPolicySpecProxyProtocol {
            /**
             * Optional allows requests without a Proxy Protocol header to be proxied.
             * If set to true, the listener will accept requests without a Proxy Protocol header.
             * If set to false, the listener will reject requests without a Proxy Protocol header.
             * If not set, the default behavior is to reject requests without a Proxy Protocol header.
             * Warning: Optional breaks conformance with the specification. Only enable if ALL traffic to the listener comes from a trusted source.
             * For more information on security implications, see haproxy.org/download/2.1/doc/proxy-protocol.txt
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * ProxyProtocol configures the Proxy Protocol settings. When configured,
         * the Proxy Protocol header will be interpreted and the Client Address
         * will be added into the X-Forwarded-For header.
         * If both EnableProxyProtocol and ProxyProtocol are set, ProxyProtocol takes precedence.
         */
        interface ClientTrafficPolicySpecProxyProtocolPatch {
            /**
             * Optional allows requests without a Proxy Protocol header to be proxied.
             * If set to true, the listener will accept requests without a Proxy Protocol header.
             * If set to false, the listener will reject requests without a Proxy Protocol header.
             * If not set, the default behavior is to reject requests without a Proxy Protocol header.
             * Warning: Optional breaks conformance with the specification. Only enable if ALL traffic to the listener comes from a trusted source.
             * For more information on security implications, see haproxy.org/download/2.1/doc/proxy-protocol.txt
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface ClientTrafficPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface ClientTrafficPolicySpecTargetRefPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface ClientTrafficPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface ClientTrafficPolicySpecTargetRefsPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        interface ClientTrafficPolicySpecTargetSelectors {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetSelectorsMatchExpressions>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface ClientTrafficPolicySpecTargetSelectorsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface ClientTrafficPolicySpecTargetSelectorsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        interface ClientTrafficPolicySpecTargetSelectorsPatch {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTargetSelectorsMatchExpressionsPatch>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * TcpKeepalive settings associated with the downstream client connection.
         * If defined, sets SO_KEEPALIVE on the listener socket to enable TCP Keepalives.
         * Disabled by default.
         */
        interface ClientTrafficPolicySpecTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the downstream client connection.
         * If defined, sets SO_KEEPALIVE on the listener socket to enable TCP Keepalives.
         * Disabled by default.
         */
        interface ClientTrafficPolicySpecTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the client connections.
         */
        interface ClientTrafficPolicySpecTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface ClientTrafficPolicySpecTimeoutHttp {
            /**
             * IdleTimeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * RequestReceivedTimeout is the duration envoy waits for the complete request reception. This timer starts upon request
             * initiation and stops when either the last byte of the request is sent upstream or when the response begins.
             */
            requestReceivedTimeout?: pulumi.Input<string>;
            /**
             *  The stream idle timeout defines the amount of time a stream can exist without any upstream or downstream activity.
             *  Default: 5 minutes.
             */
            streamIdleTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface ClientTrafficPolicySpecTimeoutHttpPatch {
            /**
             * IdleTimeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            idleTimeout?: pulumi.Input<string>;
            /**
             * RequestReceivedTimeout is the duration envoy waits for the complete request reception. This timer starts upon request
             * initiation and stops when either the last byte of the request is sent upstream or when the response begins.
             */
            requestReceivedTimeout?: pulumi.Input<string>;
            /**
             *  The stream idle timeout defines the amount of time a stream can exist without any upstream or downstream activity.
             *  Default: 5 minutes.
             */
            streamIdleTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the client connections.
         */
        interface ClientTrafficPolicySpecTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface ClientTrafficPolicySpecTimeoutTcp {
            /**
             * IdleTimeout for a TCP connection. Idle time is defined as a period in which there are no
             * bytes sent or received on either the upstream or downstream connection.
             * Default: 1 hour.
             */
            idleTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface ClientTrafficPolicySpecTimeoutTcpPatch {
            /**
             * IdleTimeout for a TCP connection. Idle time is defined as a period in which there are no
             * bytes sent or received on either the upstream or downstream connection.
             * Default: 1 hour.
             */
            idleTimeout?: pulumi.Input<string>;
        }
        /**
         * TLS settings configure TLS termination settings with the downstream client.
         */
        interface ClientTrafficPolicySpecTls {
            /**
             * ALPNProtocols supplies the list of ALPN protocols that should be
             * exposed by the listener or used by the proxy to connect to the backend.
             * Defaults:
             * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
             * 2. Other Routes: ALPN is disabled.
             * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
             * When an empty list is provided, the ALPN TLS extension is disabled.
             * Supported values are:
             * - http/1.0
             * - http/1.1
             * - h2
             */
            alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Ciphers specifies the set of cipher suites supported when
             * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
             * In non-FIPS Envoy Proxy builds the default cipher list is:
             * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
             * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             * In builds using BoringSSL FIPS the default cipher list is:
             * - ECDHE-ECDSA-AES128-GCM-SHA256
             * - ECDHE-RSA-AES128-GCM-SHA256
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             */
            ciphers?: pulumi.Input<pulumi.Input<string>[]>;
            clientValidation?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidation>;
            /**
             * ECDHCurves specifies the set of supported ECDH curves.
             * In non-FIPS Envoy Proxy builds the default curves are:
             * - X25519
             * - P-256
             * In builds using BoringSSL FIPS the default curve is:
             * - P-256
             */
            ecdhCurves?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Max specifies the maximal TLS protocol version to allow
             * The default is TLS 1.3 if this is not specified.
             */
            maxVersion?: pulumi.Input<string>;
            /**
             * Min specifies the minimal TLS protocol version to allow.
             * The default is TLS 1.2 if this is not specified.
             */
            minVersion?: pulumi.Input<string>;
            session?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsSession>;
            /**
             * SignatureAlgorithms specifies which signature algorithms the listener should
             * support.
             */
            signatureAlgorithms?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * ClientValidation specifies the configuration to validate the client
         * initiating the TLS connection to the Gateway listener.
         */
        interface ClientTrafficPolicySpecTlsClientValidation {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
             * with the CA certificate in a key named `ca.crt` is currently supported.
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will
             * verify that the SHA-256 of the DER-encoded presented certificate matches
             * one of the specified values.
             */
            certificateHashes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Optional set to true accepts connections even when a client doesn't present a certificate.
             * Defaults to false, which rejects connections without a valid client certificate.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will
             * verify that the SHA-256 of the DER-encoded Subject Public Key Information
             * (SPKI) of the presented certificate matches one of the specified values.
             */
            spkiHashes?: pulumi.Input<pulumi.Input<string>[]>;
            subjectAltNames?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNames>;
        }
        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface ClientTrafficPolicySpecTlsClientValidationCaCertificateRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface ClientTrafficPolicySpecTlsClientValidationCaCertificateRefsPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * ClientValidation specifies the configuration to validate the client
         * initiating the TLS connection to the Gateway listener.
         */
        interface ClientTrafficPolicySpecTlsClientValidationPatch {
            /**
             * CACertificateRefs contains one or more references to
             * Kubernetes objects that contain TLS certificates of
             * the Certificate Authorities that can be used
             * as a trust anchor to validate the certificates presented by the client.
             *
             * A single reference to a Kubernetes ConfigMap or a Kubernetes Secret,
             * with the CA certificate in a key named `ca.crt` is currently supported.
             *
             * References to a resource in different namespace are invalid UNLESS there
             * is a ReferenceGrant in the target namespace that allows the certificate
             * to be attached.
             */
            caCertificateRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationCaCertificateRefsPatch>[]>;
            /**
             * An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will
             * verify that the SHA-256 of the DER-encoded presented certificate matches
             * one of the specified values.
             */
            certificateHashes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Optional set to true accepts connections even when a client doesn't present a certificate.
             * Defaults to false, which rejects connections without a valid client certificate.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will
             * verify that the SHA-256 of the DER-encoded Subject Public Key Information
             * (SPKI) of the presented certificate matches one of the specified values.
             */
            spkiHashes?: pulumi.Input<pulumi.Input<string>[]>;
            subjectAltNames?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesPatch>;
        }
        /**
         * An optional list of Subject Alternative name matchers. If specified, Envoy
         * will verify that the Subject Alternative Name of the presented certificate
         * matches one of the specified matchers
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNames {
            /**
             * DNS names matchers
             */
            dnsNames?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames>[]>;
            /**
             * Email addresses matchers
             */
            emailAddresses?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses>[]>;
            /**
             * IP addresses matchers
             */
            ipAddresses?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses>[]>;
            /**
             * Other names matchers
             */
            otherNames?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames>[]>;
            /**
             * URIs matchers
             */
            uris?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris>[]>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNames {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNamesPatch {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddresses {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddressesPatch {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddresses {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddressesPatch {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNames {
            /**
             * OID Value
             */
            oid?: pulumi.Input<string>;
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNamesPatch {
            /**
             * OID Value
             */
            oid?: pulumi.Input<string>;
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * An optional list of Subject Alternative name matchers. If specified, Envoy
         * will verify that the Subject Alternative Name of the presented certificate
         * matches one of the specified matchers
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesPatch {
            /**
             * DNS names matchers
             */
            dnsNames?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesDnsNamesPatch>[]>;
            /**
             * Email addresses matchers
             */
            emailAddresses?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesEmailAddressesPatch>[]>;
            /**
             * IP addresses matchers
             */
            ipAddresses?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesIpAddressesPatch>[]>;
            /**
             * Other names matchers
             */
            otherNames?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesOtherNamesPatch>[]>;
            /**
             * URIs matchers
             */
            uris?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUrisPatch>[]>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUris {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface ClientTrafficPolicySpecTlsClientValidationSubjectAltNamesUrisPatch {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TLS settings configure TLS termination settings with the downstream client.
         */
        interface ClientTrafficPolicySpecTlsPatch {
            /**
             * ALPNProtocols supplies the list of ALPN protocols that should be
             * exposed by the listener or used by the proxy to connect to the backend.
             * Defaults:
             * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
             * 2. Other Routes: ALPN is disabled.
             * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
             * When an empty list is provided, the ALPN TLS extension is disabled.
             * Supported values are:
             * - http/1.0
             * - http/1.1
             * - h2
             */
            alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Ciphers specifies the set of cipher suites supported when
             * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
             * In non-FIPS Envoy Proxy builds the default cipher list is:
             * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
             * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             * In builds using BoringSSL FIPS the default cipher list is:
             * - ECDHE-ECDSA-AES128-GCM-SHA256
             * - ECDHE-RSA-AES128-GCM-SHA256
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             */
            ciphers?: pulumi.Input<pulumi.Input<string>[]>;
            clientValidation?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsClientValidationPatch>;
            /**
             * ECDHCurves specifies the set of supported ECDH curves.
             * In non-FIPS Envoy Proxy builds the default curves are:
             * - X25519
             * - P-256
             * In builds using BoringSSL FIPS the default curve is:
             * - P-256
             */
            ecdhCurves?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Max specifies the maximal TLS protocol version to allow
             * The default is TLS 1.3 if this is not specified.
             */
            maxVersion?: pulumi.Input<string>;
            /**
             * Min specifies the minimal TLS protocol version to allow.
             * The default is TLS 1.2 if this is not specified.
             */
            minVersion?: pulumi.Input<string>;
            session?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsSessionPatch>;
            /**
             * SignatureAlgorithms specifies which signature algorithms the listener should
             * support.
             */
            signatureAlgorithms?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Session defines settings related to TLS session management.
         */
        interface ClientTrafficPolicySpecTlsSession {
            resumption?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsSessionResumption>;
        }
        /**
         * Session defines settings related to TLS session management.
         */
        interface ClientTrafficPolicySpecTlsSessionPatch {
            resumption?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicySpecTlsSessionResumptionPatch>;
        }
        /**
         * Resumption determines the proxy's supported TLS session resumption option.
         * By default, Envoy Gateway does not enable session resumption. Use sessionResumption to
         * enable stateful and stateless session resumption. Users should consider security impacts
         * of different resumption methods. Performance gains from resumption are diminished when
         * Envoy proxy is deployed with more than one replica.
         */
        interface ClientTrafficPolicySpecTlsSessionResumption {
            /**
             * Stateful defines setting for stateful (session-id based) session resumption
             */
            stateful?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Stateless defines setting for stateless (session-ticket based) session resumption
             */
            stateless?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * Resumption determines the proxy's supported TLS session resumption option.
         * By default, Envoy Gateway does not enable session resumption. Use sessionResumption to
         * enable stateful and stateless session resumption. Users should consider security impacts
         * of different resumption methods. Performance gains from resumption are diminished when
         * Envoy proxy is deployed with more than one replica.
         */
        interface ClientTrafficPolicySpecTlsSessionResumptionPatch {
            /**
             * Stateful defines setting for stateful (session-id based) session resumption
             */
            stateful?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Stateless defines setting for stateless (session-ticket based) session resumption
             */
            stateless?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * Status defines the current status of ClientTrafficPolicy.
         */
        interface ClientTrafficPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicyStatusAncestors>[]>;
        }
        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        interface ClientTrafficPolicyStatusAncestors {
            ancestorRef?: pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicyStatusAncestorsAncestorRef>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.ClientTrafficPolicyStatusAncestorsConditions>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             * Example: "example.net/gateway-controller".
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName?: pulumi.Input<string>;
        }
        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        interface ClientTrafficPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             * There are two kinds of parent resources with "Core" support:
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             * Support: Core
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             * <gateway:experimental:description>
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             * </gateway:experimental:description>
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             * <gateway:experimental:description>
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             * </gateway:experimental:description>
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface ClientTrafficPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EnvoyExtensionPolicy allows the user to configure various envoy extensibility options for the Gateway.
         */
        interface EnvoyExtensionPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"EnvoyExtensionPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicyStatus>;
        }
        /**
         * Spec defines the desired state of EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpec {
            /**
             * ExtProc is an ordered list of external processing filters
             * that should be added to the envoy filter chain
             */
            extProc?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProc>[]>;
            /**
             * Lua is an ordered list of Lua filters
             * that should be added to the envoy filter chain
             */
            lua?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecLua>[]>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetRef>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetRefs>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetSelectors>[]>;
            /**
             * Wasm is a list of Wasm extensions to be loaded by the Gateway.
             * Order matters, as the extensions will be loaded in the order they are
             * defined in this list.
             */
            wasm?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasm>[]>;
        }
        /**
         * ExtProc defines the configuration for External Processing filter.
         */
        interface EnvoyExtensionPolicySpecExtProc {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettings>;
            /**
             * FailOpen is a switch used to control the behavior when failing to call the external processor.
             *
             * If FailOpen is set to true, the system bypasses the ExtProc extension and
             * allows the traffic to pass through. If it is set to false or
             * not set (defaulting to false), the system blocks the traffic and returns
             * an HTTP 5xx error.
             *
             * If set to true, the ExtProc extension will also be bypassed if the configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            /**
             * MessageTimeout is the timeout for a response to be returned from the external processor
             * Default: 200ms
             */
            messageTimeout?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcMetadata>;
            processingMode?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingMode>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyExtensionPolicySpecExtProcBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Metadata defines options related to the sending and receiving of dynamic metadata.
         * These options define which metadata namespaces would be sent to the processor and which dynamic metadata
         * namespaces the processor would be permitted to emit metadata to.
         * Users can specify custom namespaces or well-known envoy metadata namespace (such as envoy.filters.http.ext_authz)
         * documented here: https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata
         * Default: no metadata context is sent or received from the external processor
         */
        interface EnvoyExtensionPolicySpecExtProcMetadata {
            /**
             * AccessibleNamespaces are metadata namespaces that are sent to the external processor as context
             */
            accessibleNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * WritableNamespaces are metadata namespaces that the external processor can write to
             */
            writableNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Metadata defines options related to the sending and receiving of dynamic metadata.
         * These options define which metadata namespaces would be sent to the processor and which dynamic metadata
         * namespaces the processor would be permitted to emit metadata to.
         * Users can specify custom namespaces or well-known envoy metadata namespace (such as envoy.filters.http.ext_authz)
         * documented here: https://www.envoyproxy.io/docs/envoy/latest/configuration/advanced/well_known_dynamic_metadata#well-known-dynamic-metadata
         * Default: no metadata context is sent or received from the external processor
         */
        interface EnvoyExtensionPolicySpecExtProcMetadataPatch {
            /**
             * AccessibleNamespaces are metadata namespaces that are sent to the external processor as context
             */
            accessibleNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * WritableNamespaces are metadata namespaces that the external processor can write to
             */
            writableNamespaces?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * ExtProc defines the configuration for External Processing filter.
         */
        interface EnvoyExtensionPolicySpecExtProcPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcBackendSettingsPatch>;
            /**
             * FailOpen is a switch used to control the behavior when failing to call the external processor.
             *
             * If FailOpen is set to true, the system bypasses the ExtProc extension and
             * allows the traffic to pass through. If it is set to false or
             * not set (defaulting to false), the system blocks the traffic and returns
             * an HTTP 5xx error.
             *
             * If set to true, the ExtProc extension will also be bypassed if the configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            /**
             * MessageTimeout is the timeout for a response to be returned from the external processor
             * Default: 200ms
             */
            messageTimeout?: pulumi.Input<string>;
            metadata?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcMetadataPatch>;
            processingMode?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModePatch>;
        }
        /**
         * ProcessingMode defines how request and response body is processed
         * Default: header and body are not sent to the external processor
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingMode {
            /**
             * AllowModeOverride allows the external processor to override the processing mode set via the
             * `mode_override` field in the gRPC response message. This defaults to false.
             */
            allowModeOverride?: pulumi.Input<boolean>;
            request?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeRequest>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeResponse>;
        }
        /**
         * ProcessingMode defines how request and response body is processed
         * Default: header and body are not sent to the external processor
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingModePatch {
            /**
             * AllowModeOverride allows the external processor to override the processing mode set via the
             * `mode_override` field in the gRPC response message. This defaults to false.
             */
            allowModeOverride?: pulumi.Input<boolean>;
            request?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeRequestPatch>;
            response?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcProcessingModeResponsePatch>;
        }
        /**
         * Defines processing mode for requests. If present, request headers are sent. Request body is processed according
         * to the specified mode.
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingModeRequest {
            /**
             * Defines which attributes are sent to the external processor. Envoy Gateway currently
             * supports only the following attribute prefixes: connection, source, destination,
             * request, response, upstream and xds.route.
             * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
             */
            attributes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Defines body processing mode
             */
            body?: pulumi.Input<string>;
        }
        /**
         * Defines processing mode for requests. If present, request headers are sent. Request body is processed according
         * to the specified mode.
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingModeRequestPatch {
            /**
             * Defines which attributes are sent to the external processor. Envoy Gateway currently
             * supports only the following attribute prefixes: connection, source, destination,
             * request, response, upstream and xds.route.
             * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
             */
            attributes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Defines body processing mode
             */
            body?: pulumi.Input<string>;
        }
        /**
         * Defines processing mode for responses. If present, response headers are sent. Response body is processed according
         * to the specified mode.
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingModeResponse {
            /**
             * Defines which attributes are sent to the external processor. Envoy Gateway currently
             * supports only the following attribute prefixes: connection, source, destination,
             * request, response, upstream and xds.route.
             * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
             */
            attributes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Defines body processing mode
             */
            body?: pulumi.Input<string>;
        }
        /**
         * Defines processing mode for responses. If present, response headers are sent. Response body is processed according
         * to the specified mode.
         */
        interface EnvoyExtensionPolicySpecExtProcProcessingModeResponsePatch {
            /**
             * Defines which attributes are sent to the external processor. Envoy Gateway currently
             * supports only the following attribute prefixes: connection, source, destination,
             * request, response, upstream and xds.route.
             * https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/advanced/attributes
             */
            attributes?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Defines body processing mode
             */
            body?: pulumi.Input<string>;
        }
        /**
         * Lua defines a Lua extension
         * Only one of Inline or ValueRef must be set
         */
        interface EnvoyExtensionPolicySpecLua {
            /**
             * Inline contains the source code as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the Lua value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecLuaValueRef>;
        }
        /**
         * Lua defines a Lua extension
         * Only one of Inline or ValueRef must be set
         */
        interface EnvoyExtensionPolicySpecLuaPatch {
            /**
             * Inline contains the source code as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the Lua value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecLuaValueRefPatch>;
        }
        /**
         * ValueRef has the source code specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         * The value of key `lua` in the ConfigMap will be used.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface EnvoyExtensionPolicySpecLuaValueRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ValueRef has the source code specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         * The value of key `lua` in the ConfigMap will be used.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface EnvoyExtensionPolicySpecLuaValueRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Spec defines the desired state of EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpecPatch {
            /**
             * ExtProc is an ordered list of external processing filters
             * that should be added to the envoy filter chain
             */
            extProc?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecExtProcPatch>[]>;
            /**
             * Lua is an ordered list of Lua filters
             * that should be added to the envoy filter chain
             */
            lua?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecLuaPatch>[]>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetRefPatch>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetRefsPatch>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetSelectorsPatch>[]>;
            /**
             * Wasm is a list of Wasm extensions to be loaded by the Gateway.
             * Order matters, as the extensions will be loaded in the order they are
             * defined in this list.
             */
            wasm?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmPatch>[]>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface EnvoyExtensionPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface EnvoyExtensionPolicySpecTargetRefPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface EnvoyExtensionPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface EnvoyExtensionPolicySpecTargetRefsPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        interface EnvoyExtensionPolicySpecTargetSelectors {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyExtensionPolicySpecTargetSelectorsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyExtensionPolicySpecTargetSelectorsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        interface EnvoyExtensionPolicySpecTargetSelectorsPatch {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecTargetSelectorsMatchExpressionsPatch>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * Wasm defines a Wasm extension.
         *
         * Note: at the moment, Envoy Gateway does not support configuring Wasm runtime.
         * v8 is used as the VM runtime for the Wasm extensions.
         */
        interface EnvoyExtensionPolicySpecWasm {
            code?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCode>;
            /**
             * Config is the configuration for the Wasm extension.
             * This configuration will be passed as a JSON string to the Wasm extension.
             */
            config?: pulumi.Input<{
                [key: string]: any;
            }>;
            env?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmEnv>;
            /**
             * FailOpen is a switch used to control the behavior when a fatal error occurs
             * during the initialization or the execution of the Wasm extension.
             *
             * If FailOpen is set to true, the system bypasses the Wasm extension and
             * allows the traffic to pass through. If it is set to false or
             * not set (defaulting to false), the system blocks the traffic and returns
             * an HTTP 5xx error.
             *
             * If set to true, the Wasm extension will also be bypassed if the configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            /**
             * Name is a unique name for this Wasm extension. It is used to identify the
             * Wasm extension if multiple extensions are handled by the same vm_id and root_id.
             * It's also used for logging/debugging.
             * If not specified, EG will generate a unique name for the Wasm extension.
             */
            name?: pulumi.Input<string>;
            /**
             * RootID is a unique ID for a set of extensions in a VM which will share a
             * RootContext and Contexts if applicable (e.g., an Wasm HttpFilter and an Wasm AccessLog).
             * If left blank, all extensions with a blank root_id with the same vm_id will share Context(s).
             *
             * Note: RootID must match the root_id parameter used to register the Context in the Wasm code.
             */
            rootID?: pulumi.Input<string>;
        }
        /**
         * Code is the Wasm code for the extension.
         */
        interface EnvoyExtensionPolicySpecWasmCode {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttp>;
            image?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImage>;
            /**
             * PullPolicy is the policy to use when pulling the Wasm module by either the HTTP or Image source.
             * This field is only applicable when the SHA256 field is not set.
             *
             * If not specified, the default policy is IfNotPresent except for OCI images whose tag is latest.
             *
             * Note: EG does not update the Wasm module every time an Envoy proxy requests
             * the Wasm module even if the pull policy is set to Always.
             * It only updates the Wasm module when the EnvoyExtension resource version changes.
             */
            pullPolicy?: pulumi.Input<string>;
            /**
             * Type is the type of the source of the Wasm code.
             * Valid WasmCodeSourceType values are "HTTP" or "Image".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP is the HTTP URL containing the Wasm code.
         *
         * Note that the HTTP server must be accessible from the Envoy proxy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttp {
            /**
             * SHA256 checksum that will be used to verify the Wasm code.
             *
             * If not specified, Envoy Gateway will not verify the downloaded Wasm code.
             * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
             */
            sha256?: pulumi.Input<string>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTls>;
            /**
             * URL is the URL containing the Wasm code.
             */
            url?: pulumi.Input<string>;
        }
        /**
         * HTTP is the HTTP URL containing the Wasm code.
         *
         * Note that the HTTP server must be accessible from the Envoy proxy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttpPatch {
            /**
             * SHA256 checksum that will be used to verify the Wasm code.
             *
             * If not specified, Envoy Gateway will not verify the downloaded Wasm code.
             * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
             */
            sha256?: pulumi.Input<string>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTlsPatch>;
            /**
             * URL is the URL containing the Wasm code.
             */
            url?: pulumi.Input<string>;
        }
        /**
         * TLS configuration when connecting to the Wasm code source.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttpTls {
            caCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef>;
        }
        /**
         * CACertificateRef contains a references to
         * Kubernetes objects that contain TLS certificates of
         * the Certificate Authorities that can be used
         * as a trust anchor to validate the certificates presented by the Wasm code source.
         *
         * Kubernetes ConfigMap and Kubernetes Secret are supported.
         * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * CACertificateRef contains a references to
         * Kubernetes objects that contain TLS certificates of
         * the Certificate Authorities that can be used
         * as a trust anchor to validate the certificates presented by the Wasm code source.
         *
         * Kubernetes ConfigMap and Kubernetes Secret are supported.
         * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * TLS configuration when connecting to the Wasm code source.
         */
        interface EnvoyExtensionPolicySpecWasmCodeHttpTlsPatch {
            caCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpTlsCaCertificateRefPatch>;
        }
        /**
         * Image is the OCI image containing the Wasm code.
         *
         * Note that the image must be accessible from the Envoy Gateway.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImage {
            pullSecretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef>;
            /**
             * SHA256 checksum that will be used to verify the OCI image.
             *
             * It must match the digest of the OCI image.
             *
             * If not specified, Envoy Gateway will not verify the downloaded OCI image.
             * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
             */
            sha256?: pulumi.Input<string>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTls>;
            /**
             * URL is the URL of the OCI image.
             * URL can be in the format of `registry/image:tag` or `registry/image@sha256:digest`.
             */
            url?: pulumi.Input<string>;
        }
        /**
         * Image is the OCI image containing the Wasm code.
         *
         * Note that the image must be accessible from the Envoy Gateway.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImagePatch {
            pullSecretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImagePullSecretRefPatch>;
            /**
             * SHA256 checksum that will be used to verify the OCI image.
             *
             * It must match the digest of the OCI image.
             *
             * If not specified, Envoy Gateway will not verify the downloaded OCI image.
             * kubebuilder:validation:Pattern=`^[a-f0-9]{64}$`
             */
            sha256?: pulumi.Input<string>;
            tls?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTlsPatch>;
            /**
             * URL is the URL of the OCI image.
             * URL can be in the format of `registry/image:tag` or `registry/image@sha256:digest`.
             */
            url?: pulumi.Input<string>;
        }
        /**
         * PullSecretRef is a reference to the secret containing the credentials to pull the image.
         * Only support Kubernetes Secret resource from the same namespace.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImagePullSecretRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * PullSecretRef is a reference to the secret containing the credentials to pull the image.
         * Only support Kubernetes Secret resource from the same namespace.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImagePullSecretRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * TLS configuration when connecting to the Wasm code source.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImageTls {
            caCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef>;
        }
        /**
         * CACertificateRef contains a references to
         * Kubernetes objects that contain TLS certificates of
         * the Certificate Authorities that can be used
         * as a trust anchor to validate the certificates presented by the Wasm code source.
         *
         * Kubernetes ConfigMap and Kubernetes Secret are supported.
         * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * CACertificateRef contains a references to
         * Kubernetes objects that contain TLS certificates of
         * the Certificate Authorities that can be used
         * as a trust anchor to validate the certificates presented by the Wasm code source.
         *
         * Kubernetes ConfigMap and Kubernetes Secret are supported.
         * Note: The ConfigMap or Secret must be in the same namespace as the EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * TLS configuration when connecting to the Wasm code source.
         */
        interface EnvoyExtensionPolicySpecWasmCodeImageTlsPatch {
            caCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImageTlsCaCertificateRefPatch>;
        }
        /**
         * Code is the Wasm code for the extension.
         */
        interface EnvoyExtensionPolicySpecWasmCodePatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeHttpPatch>;
            image?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodeImagePatch>;
            /**
             * PullPolicy is the policy to use when pulling the Wasm module by either the HTTP or Image source.
             * This field is only applicable when the SHA256 field is not set.
             *
             * If not specified, the default policy is IfNotPresent except for OCI images whose tag is latest.
             *
             * Note: EG does not update the Wasm module every time an Envoy proxy requests
             * the Wasm module even if the pull policy is set to Always.
             * It only updates the Wasm module when the EnvoyExtension resource version changes.
             */
            pullPolicy?: pulumi.Input<string>;
            /**
             * Type is the type of the source of the Wasm code.
             * Valid WasmCodeSourceType values are "HTTP" or "Image".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Env configures the environment for the Wasm extension
         */
        interface EnvoyExtensionPolicySpecWasmEnv {
            /**
             * HostKeys is a list of keys for environment variables from the host envoy process
             * that should be passed into the Wasm VM. This is useful for passing secrets to to Wasm extensions.
             */
            hostKeys?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Env configures the environment for the Wasm extension
         */
        interface EnvoyExtensionPolicySpecWasmEnvPatch {
            /**
             * HostKeys is a list of keys for environment variables from the host envoy process
             * that should be passed into the Wasm VM. This is useful for passing secrets to to Wasm extensions.
             */
            hostKeys?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Wasm defines a Wasm extension.
         *
         * Note: at the moment, Envoy Gateway does not support configuring Wasm runtime.
         * v8 is used as the VM runtime for the Wasm extensions.
         */
        interface EnvoyExtensionPolicySpecWasmPatch {
            code?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmCodePatch>;
            /**
             * Config is the configuration for the Wasm extension.
             * This configuration will be passed as a JSON string to the Wasm extension.
             */
            config?: pulumi.Input<{
                [key: string]: any;
            }>;
            env?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicySpecWasmEnvPatch>;
            /**
             * FailOpen is a switch used to control the behavior when a fatal error occurs
             * during the initialization or the execution of the Wasm extension.
             *
             * If FailOpen is set to true, the system bypasses the Wasm extension and
             * allows the traffic to pass through. If it is set to false or
             * not set (defaulting to false), the system blocks the traffic and returns
             * an HTTP 5xx error.
             *
             * If set to true, the Wasm extension will also be bypassed if the configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            /**
             * Name is a unique name for this Wasm extension. It is used to identify the
             * Wasm extension if multiple extensions are handled by the same vm_id and root_id.
             * It's also used for logging/debugging.
             * If not specified, EG will generate a unique name for the Wasm extension.
             */
            name?: pulumi.Input<string>;
            /**
             * RootID is a unique ID for a set of extensions in a VM which will share a
             * RootContext and Contexts if applicable (e.g., an Wasm HttpFilter and an Wasm AccessLog).
             * If left blank, all extensions with a blank root_id with the same vm_id will share Context(s).
             *
             * Note: RootID must match the root_id parameter used to register the Context in the Wasm code.
             */
            rootID?: pulumi.Input<string>;
        }
        /**
         * Status defines the current status of EnvoyExtensionPolicy.
         */
        interface EnvoyExtensionPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicyStatusAncestors>[]>;
        }
        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        interface EnvoyExtensionPolicyStatusAncestors {
            ancestorRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicyStatusAncestorsAncestorRef>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyExtensionPolicyStatusAncestorsConditions>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             * Example: "example.net/gateway-controller".
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName?: pulumi.Input<string>;
        }
        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        interface EnvoyExtensionPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             * There are two kinds of parent resources with "Core" support:
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             * Support: Core
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             * <gateway:experimental:description>
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             * </gateway:experimental:description>
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             * <gateway:experimental:description>
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             * </gateway:experimental:description>
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface EnvoyExtensionPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EnvoyPatchPolicy allows the user to modify the generated Envoy xDS
         * resources by Envoy Gateway using this patch API
         */
        interface EnvoyPatchPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"EnvoyPatchPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicyStatus>;
        }
        /**
         * Spec defines the desired state of EnvoyPatchPolicy.
         */
        interface EnvoyPatchPolicySpec {
            /**
             * JSONPatch defines the JSONPatch configuration.
             */
            jsonPatches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecJsonPatches>[]>;
            /**
             * Priority of the EnvoyPatchPolicy.
             * If multiple EnvoyPatchPolicies are applied to the same
             * TargetRef, they will be applied in the ascending order of
             * the priority i.e. int32.min has the highest priority and
             * int32.max has the lowest priority.
             * Defaults to 0.
             */
            priority?: pulumi.Input<number>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecTargetRef>;
            /**
             * Type decides the type of patch.
             * Valid EnvoyPatchType values are "JSONPatch".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EnvoyJSONPatchConfig defines the configuration for patching a Envoy xDS Resource
         * using JSONPatch semantic
         */
        interface EnvoyPatchPolicySpecJsonPatches {
            /**
             * Name is the name of the resource
             */
            name?: pulumi.Input<string>;
            operation?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecJsonPatchesOperation>;
            /**
             * Type is the typed URL of the Envoy xDS Resource
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Patch defines the JSON Patch Operation
         */
        interface EnvoyPatchPolicySpecJsonPatchesOperation {
            /**
             * From is the source location of the value to be copied or moved. Only valid
             * for move or copy operations
             * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             */
            from?: pulumi.Input<string>;
            /**
             * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
             * It produces one or more JSONPointer expressions based on the given JSON document.
             * If no JSONPointer is found, it will result in an error.
             * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
             * This is useful when creating a property that does not yet exist in the JSON document.
             * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
             */
            jsonPath?: pulumi.Input<string>;
            /**
             * Op is the type of operation to perform
             */
            op?: pulumi.Input<string>;
            /**
             * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             * It specifies the location of the target document/field where the operation will be performed
             */
            path?: pulumi.Input<string>;
            /**
             * Value is the new value of the path location. The value is only used by
             * the `add` and `replace` operations.
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * Patch defines the JSON Patch Operation
         */
        interface EnvoyPatchPolicySpecJsonPatchesOperationPatch {
            /**
             * From is the source location of the value to be copied or moved. Only valid
             * for move or copy operations
             * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             */
            from?: pulumi.Input<string>;
            /**
             * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
             * It produces one or more JSONPointer expressions based on the given JSON document.
             * If no JSONPointer is found, it will result in an error.
             * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
             * This is useful when creating a property that does not yet exist in the JSON document.
             * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
             */
            jsonPath?: pulumi.Input<string>;
            /**
             * Op is the type of operation to perform
             */
            op?: pulumi.Input<string>;
            /**
             * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             * It specifies the location of the target document/field where the operation will be performed
             */
            path?: pulumi.Input<string>;
            /**
             * Value is the new value of the path location. The value is only used by
             * the `add` and `replace` operations.
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * EnvoyJSONPatchConfig defines the configuration for patching a Envoy xDS Resource
         * using JSONPatch semantic
         */
        interface EnvoyPatchPolicySpecJsonPatchesPatch {
            /**
             * Name is the name of the resource
             */
            name?: pulumi.Input<string>;
            operation?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecJsonPatchesOperationPatch>;
            /**
             * Type is the typed URL of the Envoy xDS Resource
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Spec defines the desired state of EnvoyPatchPolicy.
         */
        interface EnvoyPatchPolicySpecPatch {
            /**
             * JSONPatch defines the JSONPatch configuration.
             */
            jsonPatches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecJsonPatchesPatch>[]>;
            /**
             * Priority of the EnvoyPatchPolicy.
             * If multiple EnvoyPatchPolicies are applied to the same
             * TargetRef, they will be applied in the ascending order of
             * the priority i.e. int32.min has the highest priority and
             * int32.max has the lowest priority.
             * Defaults to 0.
             */
            priority?: pulumi.Input<number>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicySpecTargetRefPatch>;
            /**
             * Type decides the type of patch.
             * Valid EnvoyPatchType values are "JSONPatch".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the Gateway API resource this policy
         * is being attached to.
         * By default, attaching to Gateway is supported and
         * when mergeGateways is enabled it should attach to GatewayClass.
         * This Policy and the TargetRef MUST be in the same namespace
         * for this Policy to have effect and be applied to the Gateway
         * TargetRef
         */
        interface EnvoyPatchPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the Gateway API resource this policy
         * is being attached to.
         * By default, attaching to Gateway is supported and
         * when mergeGateways is enabled it should attach to GatewayClass.
         * This Policy and the TargetRef MUST be in the same namespace
         * for this Policy to have effect and be applied to the Gateway
         * TargetRef
         */
        interface EnvoyPatchPolicySpecTargetRefPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Status defines the current status of EnvoyPatchPolicy.
         */
        interface EnvoyPatchPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicyStatusAncestors>[]>;
        }
        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        interface EnvoyPatchPolicyStatusAncestors {
            ancestorRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicyStatusAncestorsAncestorRef>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyPatchPolicyStatusAncestorsConditions>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             * Example: "example.net/gateway-controller".
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName?: pulumi.Input<string>;
        }
        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        interface EnvoyPatchPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             * There are two kinds of parent resources with "Core" support:
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             * Support: Core
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             * <gateway:experimental:description>
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             * </gateway:experimental:description>
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             * <gateway:experimental:description>
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             * </gateway:experimental:description>
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface EnvoyPatchPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EnvoyProxy is the schema for the envoyproxies API.
         */
        interface EnvoyProxy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"EnvoyProxy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpec>;
            /**
             * EnvoyProxyStatus defines the actual state of EnvoyProxy.
             */
            status?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * EnvoyProxySpec defines the desired state of EnvoyProxy.
         */
        interface EnvoyProxySpec {
            backendTLS?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBackendTLS>;
            bootstrap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBootstrap>;
            /**
             * Concurrency defines the number of worker threads to run. If unset, it defaults to
             * the number of cpuset threads on the platform.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * ExtraArgs defines additional command line options that are provided to Envoy.
             * More info: https://www.envoyproxy.io/docs/envoy/latest/operations/cli#command-line-options
             * Note: some command line options are used internally(e.g. --log-level) so they cannot be provided here.
             */
            extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FilterOrder defines the order of filters in the Envoy proxy's HTTP filter chain.
             * The FilterPosition in the list will be applied in the order they are defined.
             * If unspecified, the default filter order is applied.
             * Default filter order is:
             *
             * - envoy.filters.http.health_check
             *
             * - envoy.filters.http.fault
             *
             * - envoy.filters.http.cors
             *
             * - envoy.filters.http.ext_authz
             *
             * - envoy.filters.http.basic_auth
             *
             * - envoy.filters.http.oauth2
             *
             * - envoy.filters.http.jwt_authn
             *
             * - envoy.filters.http.stateful_session
             *
             * - envoy.filters.http.lua
             *
             * - envoy.filters.http.ext_proc
             *
             * - envoy.filters.http.wasm
             *
             * - envoy.filters.http.rbac
             *
             * - envoy.filters.http.local_ratelimit
             *
             * - envoy.filters.http.ratelimit
             *
             * - envoy.filters.http.custom_response
             *
             * - envoy.filters.http.router
             *
             * Note: "envoy.filters.http.router" cannot be reordered, it's always the last filter in the chain.
             */
            filterOrder?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecFilterOrder>[]>;
            /**
             * IPFamily specifies the IP family for the EnvoyProxy fleet.
             * This setting only affects the Gateway listener port and does not impact
             * other aspects of the Envoy proxy configuration.
             * If not specified, the system will operate as follows:
             * - It defaults to IPv4 only.
             * - IPv6 and dual-stack environments are not supported in this default configuration.
             * Note: To enable IPv6 or dual-stack functionality, explicit configuration is required.
             */
            ipFamily?: pulumi.Input<string>;
            logging?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecLogging>;
            /**
             * LuaValidation determines strictness of the Lua script validation for Lua EnvoyExtensionPolicies
             * Default: Strict
             */
            luaValidation?: pulumi.Input<string>;
            /**
             * MergeGateways defines if Gateway resources should be merged onto the same Envoy Proxy Infrastructure.
             * Setting this field to true would merge all Gateway Listeners under the parent Gateway Class.
             * This means that the port, protocol and hostname tuple must be unique for every listener.
             * If a duplicate listener is detected, the newer listener (based on timestamp) will be rejected and its status will be updated with a "Accepted=False" condition.
             */
            mergeGateways?: pulumi.Input<boolean>;
            /**
             * PreserveRouteOrder determines if the order of matching for HTTPRoutes is determined by Gateway-API
             * specification (https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteRule)
             * or preserves the order defined by users in the HTTPRoute's HTTPRouteRule list.
             * Default: False
             */
            preserveRouteOrder?: pulumi.Input<boolean>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProvider>;
            /**
             * RoutingType can be set to "Service" to use the Service Cluster IP for routing to the backend,
             * or it can be set to "Endpoint" to use Endpoint routing. The default is "Endpoint".
             */
            routingType?: pulumi.Input<string>;
            shutdown?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecShutdown>;
            telemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetry>;
        }
        /**
         * BackendTLS is the TLS configuration for the Envoy proxy to use when connecting to backends.
         * These settings are applied on backends for which TLS policies are specified.
         */
        interface EnvoyProxySpecBackendTLS {
            /**
             * ALPNProtocols supplies the list of ALPN protocols that should be
             * exposed by the listener or used by the proxy to connect to the backend.
             * Defaults:
             * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
             * 2. Other Routes: ALPN is disabled.
             * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
             * When an empty list is provided, the ALPN TLS extension is disabled.
             * Supported values are:
             * - http/1.0
             * - http/1.1
             * - h2
             */
            alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Ciphers specifies the set of cipher suites supported when
             * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
             * In non-FIPS Envoy Proxy builds the default cipher list is:
             * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
             * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             * In builds using BoringSSL FIPS the default cipher list is:
             * - ECDHE-ECDSA-AES128-GCM-SHA256
             * - ECDHE-RSA-AES128-GCM-SHA256
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             */
            ciphers?: pulumi.Input<pulumi.Input<string>[]>;
            clientCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBackendTLSClientCertificateRef>;
            /**
             * ECDHCurves specifies the set of supported ECDH curves.
             * In non-FIPS Envoy Proxy builds the default curves are:
             * - X25519
             * - P-256
             * In builds using BoringSSL FIPS the default curve is:
             * - P-256
             */
            ecdhCurves?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Max specifies the maximal TLS protocol version to allow
             * The default is TLS 1.3 if this is not specified.
             */
            maxVersion?: pulumi.Input<string>;
            /**
             * Min specifies the minimal TLS protocol version to allow.
             * The default is TLS 1.2 if this is not specified.
             */
            minVersion?: pulumi.Input<string>;
            /**
             * SignatureAlgorithms specifies which signature algorithms the listener should
             * support.
             */
            signatureAlgorithms?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
         * the client certificate and private key for Envoy to use when connecting to
         * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
         * This secret should be located within the same namespace as the Envoy proxy resource that references it.
         */
        interface EnvoyProxySpecBackendTLSClientCertificateRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * ClientCertificateRef defines the reference to a Kubernetes Secret that contains
         * the client certificate and private key for Envoy to use when connecting to
         * backend services and external services, such as ExtAuth, ALS, OpenTelemetry, etc.
         * This secret should be located within the same namespace as the Envoy proxy resource that references it.
         */
        interface EnvoyProxySpecBackendTLSClientCertificateRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * BackendTLS is the TLS configuration for the Envoy proxy to use when connecting to backends.
         * These settings are applied on backends for which TLS policies are specified.
         */
        interface EnvoyProxySpecBackendTLSPatch {
            /**
             * ALPNProtocols supplies the list of ALPN protocols that should be
             * exposed by the listener or used by the proxy to connect to the backend.
             * Defaults:
             * 1. HTTPS Routes: h2 and http/1.1 are enabled in listener context.
             * 2. Other Routes: ALPN is disabled.
             * 3. Backends: proxy uses the appropriate ALPN options for the backend protocol.
             * When an empty list is provided, the ALPN TLS extension is disabled.
             * Supported values are:
             * - http/1.0
             * - http/1.1
             * - h2
             */
            alpnProtocols?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Ciphers specifies the set of cipher suites supported when
             * negotiating TLS 1.0 - 1.2. This setting has no effect for TLS 1.3.
             * In non-FIPS Envoy Proxy builds the default cipher list is:
             * - [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
             * - [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             * In builds using BoringSSL FIPS the default cipher list is:
             * - ECDHE-ECDSA-AES128-GCM-SHA256
             * - ECDHE-RSA-AES128-GCM-SHA256
             * - ECDHE-ECDSA-AES256-GCM-SHA384
             * - ECDHE-RSA-AES256-GCM-SHA384
             */
            ciphers?: pulumi.Input<pulumi.Input<string>[]>;
            clientCertificateRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBackendTLSClientCertificateRefPatch>;
            /**
             * ECDHCurves specifies the set of supported ECDH curves.
             * In non-FIPS Envoy Proxy builds the default curves are:
             * - X25519
             * - P-256
             * In builds using BoringSSL FIPS the default curve is:
             * - P-256
             */
            ecdhCurves?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Max specifies the maximal TLS protocol version to allow
             * The default is TLS 1.3 if this is not specified.
             */
            maxVersion?: pulumi.Input<string>;
            /**
             * Min specifies the minimal TLS protocol version to allow.
             * The default is TLS 1.2 if this is not specified.
             */
            minVersion?: pulumi.Input<string>;
            /**
             * SignatureAlgorithms specifies which signature algorithms the listener should
             * support.
             */
            signatureAlgorithms?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Bootstrap defines the Envoy Bootstrap as a YAML string.
         * Visit https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto#envoy-v3-api-msg-config-bootstrap-v3-bootstrap
         * to learn more about the syntax.
         * If set, this is the Bootstrap configuration used for the managed Envoy Proxy fleet instead of the default Bootstrap configuration
         * set by Envoy Gateway.
         * Some fields within the Bootstrap that are required to communicate with the xDS Server (Envoy Gateway) and receive xDS resources
         * from it are not configurable and will result in the `EnvoyProxy` resource being rejected.
         * Backward compatibility across minor versions is not guaranteed.
         * We strongly recommend using `egctl x translate` to generate a `EnvoyProxy` resource with the `Bootstrap` field set to the default
         * Bootstrap configuration used. You can edit this configuration, and rerun `egctl x translate` to ensure there are no validation errors.
         */
        interface EnvoyProxySpecBootstrap {
            /**
             * JSONPatches is an array of JSONPatches to be applied to the default bootstrap. Patches are
             * applied in the order in which they are defined.
             */
            jsonPatches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBootstrapJsonPatches>[]>;
            /**
             * Type is the type of the bootstrap configuration, it should be either **Replace**,  **Merge**, or **JSONPatch**.
             * If unspecified, it defaults to Replace.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is a YAML string of the bootstrap.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * JSONPatchOperation defines the JSON Patch Operation as defined in
         * https://datatracker.ietf.org/doc/html/rfc6902
         */
        interface EnvoyProxySpecBootstrapJsonPatches {
            /**
             * From is the source location of the value to be copied or moved. Only valid
             * for move or copy operations
             * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             */
            from?: pulumi.Input<string>;
            /**
             * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
             * It produces one or more JSONPointer expressions based on the given JSON document.
             * If no JSONPointer is found, it will result in an error.
             * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
             * This is useful when creating a property that does not yet exist in the JSON document.
             * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
             */
            jsonPath?: pulumi.Input<string>;
            /**
             * Op is the type of operation to perform
             */
            op?: pulumi.Input<string>;
            /**
             * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             * It specifies the location of the target document/field where the operation will be performed
             */
            path?: pulumi.Input<string>;
            /**
             * Value is the new value of the path location. The value is only used by
             * the `add` and `replace` operations.
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * JSONPatchOperation defines the JSON Patch Operation as defined in
         * https://datatracker.ietf.org/doc/html/rfc6902
         */
        interface EnvoyProxySpecBootstrapJsonPatchesPatch {
            /**
             * From is the source location of the value to be copied or moved. Only valid
             * for move or copy operations
             * Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             */
            from?: pulumi.Input<string>;
            /**
             * JSONPath is a JSONPath expression. Refer to https://datatracker.ietf.org/doc/rfc9535/ for more details.
             * It produces one or more JSONPointer expressions based on the given JSON document.
             * If no JSONPointer is found, it will result in an error.
             * If the 'Path' property is also set, it will be appended to the resulting JSONPointer expressions from the JSONPath evaluation.
             * This is useful when creating a property that does not yet exist in the JSON document.
             * The final JSONPointer expressions specifies the locations in the target document/field where the operation will be applied.
             */
            jsonPath?: pulumi.Input<string>;
            /**
             * Op is the type of operation to perform
             */
            op?: pulumi.Input<string>;
            /**
             * Path is a JSONPointer expression. Refer to https://datatracker.ietf.org/doc/html/rfc6901 for more details.
             * It specifies the location of the target document/field where the operation will be performed
             */
            path?: pulumi.Input<string>;
            /**
             * Value is the new value of the path location. The value is only used by
             * the `add` and `replace` operations.
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * Bootstrap defines the Envoy Bootstrap as a YAML string.
         * Visit https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/bootstrap/v3/bootstrap.proto#envoy-v3-api-msg-config-bootstrap-v3-bootstrap
         * to learn more about the syntax.
         * If set, this is the Bootstrap configuration used for the managed Envoy Proxy fleet instead of the default Bootstrap configuration
         * set by Envoy Gateway.
         * Some fields within the Bootstrap that are required to communicate with the xDS Server (Envoy Gateway) and receive xDS resources
         * from it are not configurable and will result in the `EnvoyProxy` resource being rejected.
         * Backward compatibility across minor versions is not guaranteed.
         * We strongly recommend using `egctl x translate` to generate a `EnvoyProxy` resource with the `Bootstrap` field set to the default
         * Bootstrap configuration used. You can edit this configuration, and rerun `egctl x translate` to ensure there are no validation errors.
         */
        interface EnvoyProxySpecBootstrapPatch {
            /**
             * JSONPatches is an array of JSONPatches to be applied to the default bootstrap. Patches are
             * applied in the order in which they are defined.
             */
            jsonPatches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBootstrapJsonPatchesPatch>[]>;
            /**
             * Type is the type of the bootstrap configuration, it should be either **Replace**,  **Merge**, or **JSONPatch**.
             * If unspecified, it defaults to Replace.
             */
            type?: pulumi.Input<string>;
            /**
             * Value is a YAML string of the bootstrap.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * FilterPosition defines the position of an Envoy HTTP filter in the filter chain.
         */
        interface EnvoyProxySpecFilterOrder {
            /**
             * After defines the filter that should come after the filter.
             * Only one of Before or After must be set.
             */
            after?: pulumi.Input<string>;
            /**
             * Before defines the filter that should come before the filter.
             * Only one of Before or After must be set.
             */
            before?: pulumi.Input<string>;
            /**
             * Name of the filter.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * FilterPosition defines the position of an Envoy HTTP filter in the filter chain.
         */
        interface EnvoyProxySpecFilterOrderPatch {
            /**
             * After defines the filter that should come after the filter.
             * Only one of Before or After must be set.
             */
            after?: pulumi.Input<string>;
            /**
             * Before defines the filter that should come before the filter.
             * Only one of Before or After must be set.
             */
            before?: pulumi.Input<string>;
            /**
             * Name of the filter.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Logging defines logging parameters for managed proxies.
         */
        interface EnvoyProxySpecLogging {
            /**
             * Level is a map of logging level per component, where the component is the key
             * and the log level is the value. If unspecified, defaults to "default: warn".
             */
            level?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * Logging defines logging parameters for managed proxies.
         */
        interface EnvoyProxySpecLoggingPatch {
            /**
             * Level is a map of logging level per component, where the component is the key
             * and the log level is the value. If unspecified, defaults to "default: warn".
             */
            level?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * EnvoyProxySpec defines the desired state of EnvoyProxy.
         */
        interface EnvoyProxySpecPatch {
            backendTLS?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBackendTLSPatch>;
            bootstrap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecBootstrapPatch>;
            /**
             * Concurrency defines the number of worker threads to run. If unset, it defaults to
             * the number of cpuset threads on the platform.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * ExtraArgs defines additional command line options that are provided to Envoy.
             * More info: https://www.envoyproxy.io/docs/envoy/latest/operations/cli#command-line-options
             * Note: some command line options are used internally(e.g. --log-level) so they cannot be provided here.
             */
            extraArgs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * FilterOrder defines the order of filters in the Envoy proxy's HTTP filter chain.
             * The FilterPosition in the list will be applied in the order they are defined.
             * If unspecified, the default filter order is applied.
             * Default filter order is:
             *
             * - envoy.filters.http.health_check
             *
             * - envoy.filters.http.fault
             *
             * - envoy.filters.http.cors
             *
             * - envoy.filters.http.ext_authz
             *
             * - envoy.filters.http.basic_auth
             *
             * - envoy.filters.http.oauth2
             *
             * - envoy.filters.http.jwt_authn
             *
             * - envoy.filters.http.stateful_session
             *
             * - envoy.filters.http.lua
             *
             * - envoy.filters.http.ext_proc
             *
             * - envoy.filters.http.wasm
             *
             * - envoy.filters.http.rbac
             *
             * - envoy.filters.http.local_ratelimit
             *
             * - envoy.filters.http.ratelimit
             *
             * - envoy.filters.http.custom_response
             *
             * - envoy.filters.http.router
             *
             * Note: "envoy.filters.http.router" cannot be reordered, it's always the last filter in the chain.
             */
            filterOrder?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecFilterOrderPatch>[]>;
            /**
             * IPFamily specifies the IP family for the EnvoyProxy fleet.
             * This setting only affects the Gateway listener port and does not impact
             * other aspects of the Envoy proxy configuration.
             * If not specified, the system will operate as follows:
             * - It defaults to IPv4 only.
             * - IPv6 and dual-stack environments are not supported in this default configuration.
             * Note: To enable IPv6 or dual-stack functionality, explicit configuration is required.
             */
            ipFamily?: pulumi.Input<string>;
            logging?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecLoggingPatch>;
            /**
             * LuaValidation determines strictness of the Lua script validation for Lua EnvoyExtensionPolicies
             * Default: Strict
             */
            luaValidation?: pulumi.Input<string>;
            /**
             * MergeGateways defines if Gateway resources should be merged onto the same Envoy Proxy Infrastructure.
             * Setting this field to true would merge all Gateway Listeners under the parent Gateway Class.
             * This means that the port, protocol and hostname tuple must be unique for every listener.
             * If a duplicate listener is detected, the newer listener (based on timestamp) will be rejected and its status will be updated with a "Accepted=False" condition.
             */
            mergeGateways?: pulumi.Input<boolean>;
            /**
             * PreserveRouteOrder determines if the order of matching for HTTPRoutes is determined by Gateway-API
             * specification (https://gateway-api.sigs.k8s.io/reference/spec/#gateway.networking.k8s.io/v1.HTTPRouteRule)
             * or preserves the order defined by users in the HTTPRoute's HTTPRouteRule list.
             * Default: False
             */
            preserveRouteOrder?: pulumi.Input<boolean>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderPatch>;
            /**
             * RoutingType can be set to "Service" to use the Service Cluster IP for routing to the backend,
             * or it can be set to "Endpoint" to use Endpoint routing. The default is "Endpoint".
             */
            routingType?: pulumi.Input<string>;
            shutdown?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecShutdownPatch>;
            telemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryPatch>;
        }
        /**
         * Provider defines the desired resource provider and provider-specific configuration.
         * If unspecified, the "Kubernetes" resource provider is used with default configuration
         * parameters.
         */
        interface EnvoyProxySpecProvider {
            kubernetes?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetes>;
            /**
             * Type is the type of resource provider to use. A resource provider provides
             * infrastructure resources for running the data plane, e.g. Envoy proxy, and
             * optional auxiliary control planes. Supported types are "Kubernetes".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Kubernetes defines the desired state of the Kubernetes resource provider.
         * Kubernetes provides infrastructure resources for running the data plane,
         * e.g. Envoy proxy. If unspecified and type is "Kubernetes", default settings
         * for managed Kubernetes resources are applied.
         */
        interface EnvoyProxySpecProviderKubernetes {
            envoyDaemonSet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSet>;
            envoyDeployment?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeployment>;
            envoyHpa?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpa>;
            envoyPDB?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDB>;
            envoyService?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyService>;
            envoyServiceAccount?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServiceAccount>;
            /**
             * UseListenerPortAsContainerPort disables the port shifting feature in the Envoy Proxy.
             * When set to false (default value), if the service port is a privileged port (1-1023), add a constant to the value converting it into an ephemeral port.
             * This allows the container to bind to the port without needing a CAP_NET_BIND_SERVICE capability.
             */
            useListenerPortAsContainerPort?: pulumi.Input<boolean>;
        }
        /**
         * EnvoyDaemonSet defines the desired state of the Envoy daemonset resource.
         * Disabled by default, a deployment resource is used instead to provision the Envoy Proxy fleet
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSet {
            container?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer>;
            /**
             * Name of the daemonSet.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
            patch?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch>;
            pod?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod>;
            strategy?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy>;
        }
        /**
         * Container defines the desired specification of main container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainer {
            /**
             * List of environment variables to set in the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv>[]>;
            /**
             * Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.
             * This field is mutually exclusive with ImageRepository.
             */
            image?: pulumi.Input<string>;
            /**
             * ImageRepository specifies the container image repository to be used without specifying a tag.
             * The default tag will be used.
             * This field is mutually exclusive with Image.
             */
            imageRepository?: pulumi.Input<string>;
            resources?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources>;
            securityContext?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext>;
            /**
             * VolumeMounts are volumes to mount into the container's filesystem.
             * Cannot be updated.
             */
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts>[]>;
        }
        /**
         * EnvVar represents an environment variable present in a Container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name?: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded
             * using the previously defined environment variables in the container and
             * any service environment variables. If a variable cannot be resolved,
             * the reference in the input string will be unchanged. Double $$ are reduced
             * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
             * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
             * Escaped references will never be expanded, regardless of whether the variable
             * exists or not.
             * Defaults to "".
             */
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom>;
        }
        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef>;
        }
        /**
         * Selects a key of a ConfigMap.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
         * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * Selects a key of a secret in the pod's namespace
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerEnvValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Resources required by this container.
         * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
        }
        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name?: pulumi.Input<string>;
            /**
             * Request is the name chosen for a request in the referenced claim.
             * If empty, everything from the claim is made available, otherwise
             * only the result of this request.
             */
            request?: pulumi.Input<string>;
        }
        /**
         * SecurityContext defines the security options the container should be run with.
         * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
         * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            appArmorProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile>;
            capabilities?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default value is Default which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions>;
            seccompProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile>;
            windowsOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions>;
        }
        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }
        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }
        /**
         * VolumeMount describes a mounting of a Volume within a container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetContainerVolumeMounts {
            /**
             * Path within the container at which the volume should be mounted.  Must
             * not contain ':'.
             */
            mountPath?: pulumi.Input<string>;
            /**
             * mountPropagation determines how mounts are propagated from the host
             * to container and the other way around.
             * When not set, MountPropagationNone is used.
             * This field is beta in 1.10.
             * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
             * (which defaults to None).
             */
            mountPropagation?: pulumi.Input<string>;
            /**
             * This must match the Name of a Volume.
             */
            name?: pulumi.Input<string>;
            /**
             * Mounted read-only if true, read-write otherwise (false or unspecified).
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * RecursiveReadOnly specifies whether read-only mounts should be handled
             * recursively.
             *
             * If ReadOnly is false, this field has no meaning and must be unspecified.
             *
             * If ReadOnly is true, and this field is set to Disabled, the mount is not made
             * recursively read-only.  If this field is set to IfPossible, the mount is made
             * recursively read-only, if it is supported by the container runtime.  If this
             * field is set to Enabled, the mount is made recursively read-only if it is
             * supported by the container runtime, otherwise the pod will not be started and
             * an error will be generated to indicate the reason.
             *
             * If this field is set to IfPossible or Enabled, MountPropagation must be set to
             * None (or be unspecified, which defaults to None).
             *
             * If this field is not specified, it is treated as an equivalent of Disabled.
             */
            recursiveReadOnly?: pulumi.Input<string>;
            /**
             * Path within the volume from which the container's volume should be mounted.
             * Defaults to "" (volume's root).
             */
            subPath?: pulumi.Input<string>;
            /**
             * Expanded path within the volume from which the container's volume should be mounted.
             * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
             * Defaults to "" (volume's root).
             * SubPathExpr and SubPath are mutually exclusive.
             */
            subPathExpr?: pulumi.Input<string>;
        }
        /**
         * Patch defines how to perform the patch operation to daemonset
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch {
            /**
             * Type is the type of merge operation to perform
             *
             * By default, StrategicMerge is used as the patch type.
             */
            type?: pulumi.Input<string>;
            /**
             * Object contains the raw configuration for merged object
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * Pod defines the desired specification of pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPod {
            affinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity>;
            /**
             * Annotations are the annotations that should be appended to the pods.
             * By default, no pod annotations are appended.
             */
            annotations?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * ImagePullSecrets is an optional list of references to secrets
             * in the same namespace to use for pulling any of the images used by this PodSpec.
             * If specified, these secrets will be passed to individual puller implementations for them to use.
             * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets>[]>;
            /**
             * Labels are the additional labels that should be tagged to the pods.
             * By default, no additional pod labels are tagged.
             */
            labels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * NodeSelector is a selector which must be true for the pod to fit on a node.
             * Selector which must match a node's labels for the pod to be scheduled on that node.
             * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
             */
            nodeSelector?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            securityContext?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext>;
            /**
             * If specified, the pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations>[]>;
            /**
             * TopologySpreadConstraints describes how a group of pods ought to spread across topology
             * domains. Scheduler will schedule pods in a way which abides by the constraints.
             * All topologySpreadConstraints are ANDed.
             */
            topologySpreadConstraints?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints>[]>;
            /**
             * Volumes that can be mounted by containers belonging to the pod.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes>[]>;
        }
        /**
         * If specified, the pod's scheduling constraints.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinity {
            nodeAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity>;
        }
        /**
         * Describes node affinity scheduling rules for the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }
        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * A node selector term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }
        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }
        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }
        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodImagePullSecrets {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * SecurityContext holds pod-level security attributes and common container settings.
         * Optional: Defaults to empty.  See type description for default values of each field.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContext {
            appArmorProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile>;
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: pulumi.Input<number>;
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: pulumi.Input<string>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
             * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
             * Valid values are "MountOption" and "Recursive".
             *
             * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
             * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
             *
             * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
             * This requires all Pods that share the same volume to use the same SELinux label.
             * It is not possible to share the same volume among privileged and unprivileged Pods.
             * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
             * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
             * CSIDriver instance. Other volumes are always re-labelled recursively.
             * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
             *
             * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
             * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
             * and "Recursive" for all other volumes.
             *
             * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
             *
             * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxChangePolicy?: pulumi.Input<string>;
            seLinuxOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions>;
            seccompProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile>;
            /**
             * A list of groups applied to the first process run in each container, in
             * addition to the container's primary GID and fsGroup (if specified).  If
             * the SupplementalGroupsPolicy feature is enabled, the
             * supplementalGroupsPolicy field determines whether these are in addition
             * to or instead of any group memberships defined in the container image.
             * If unspecified, no additional groups are added, though group memberships
             * defined in the container image may still be used, depending on the
             * supplementalGroupsPolicy field.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Defines how supplemental groups of the first container processes are calculated.
             * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
             * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
             * and the container runtime must implement support for this feature.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroupsPolicy?: pulumi.Input<string>;
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions>;
        }
        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }
        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Sysctl defines a kernel parameter to be set
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextSysctls {
            /**
             * Name of a property to set
             */
            name?: pulumi.Input<string>;
            /**
             * Value of a property to set
             */
            value?: pulumi.Input<string>;
        }
        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }
        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTolerations {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: pulumi.Input<string>;
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: pulumi.Input<string>;
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: pulumi.Input<string>;
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: pulumi.Input<number>;
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraints {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select the pods over which
             * spreading will be calculated. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are ANDed with labelSelector
             * to select the group of existing pods over which spreading will be calculated
             * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
             * MatchLabelKeys cannot be set when LabelSelector isn't set.
             * Keys that don't exist in the incoming pod labels will
             * be ignored. A null or empty list means only match against labelSelector.
             *
             * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MaxSkew describes the degree to which pods may be unevenly distributed.
             * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
             * between the number of matching pods in the target topology and the global minimum.
             * The global minimum is the minimum number of matching pods in an eligible domain
             * or zero if the number of eligible domains is less than MinDomains.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 2/2/1:
             * In this case, the global minimum is 1.
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |   P   |
             * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
             * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
             * violate MaxSkew(1).
             * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
             * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
             * to topologies that satisfy it.
             * It's a required field. Default value is 1 and 0 is not allowed.
             */
            maxSkew?: pulumi.Input<number>;
            /**
             * MinDomains indicates a minimum number of eligible domains.
             * When the number of eligible domains with matching topology keys is less than minDomains,
             * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
             * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
             * this value has no effect on scheduling.
             * As a result, when the number of eligible domains is less than minDomains,
             * scheduler won't schedule more than maxSkew Pods to those domains.
             * If value is nil, the constraint behaves as if MinDomains is equal to 1.
             * Valid values are integers greater than 0.
             * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
             *
             * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
             * labelSelector spread as 2/2/2:
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |  P P  |
             * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
             * In this situation, new pod with the same labelSelector cannot be scheduled,
             * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
             * it will violate MaxSkew.
             */
            minDomains?: pulumi.Input<number>;
            /**
             * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
             * when calculating pod topology spread skew. Options are:
             * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
             * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
             *
             * If this value is nil, the behavior is equivalent to the Honor policy.
             */
            nodeAffinityPolicy?: pulumi.Input<string>;
            /**
             * NodeTaintsPolicy indicates how we will treat node taints when calculating
             * pod topology spread skew. Options are:
             * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
             * has a toleration, are included.
             * - Ignore: node taints are ignored. All nodes are included.
             *
             * If this value is nil, the behavior is equivalent to the Ignore policy.
             */
            nodeTaintsPolicy?: pulumi.Input<string>;
            /**
             * TopologyKey is the key of node labels. Nodes that have a label with this key
             * and identical values are considered to be in the same topology.
             * We consider each <key, value> as a "bucket", and try to put balanced number
             * of pods into each bucket.
             * We define a domain as a particular instance of a topology.
             * Also, we define an eligible domain as a domain whose nodes meet the requirements of
             * nodeAffinityPolicy and nodeTaintsPolicy.
             * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
             * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
             * It's a required field.
             */
            topologyKey?: pulumi.Input<string>;
            /**
             * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
             * the spread constraint.
             * - DoNotSchedule (default) tells the scheduler not to schedule it.
             * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
             *   but giving higher precedence to topologies that would help reduce the
             *   skew.
             * A constraint is considered "Unsatisfiable" for an incoming pod
             * if and only if every possible node assignment for that pod would violate
             * "MaxSkew" on some topology.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 3/1/1:
             * | zone1 | zone2 | zone3 |
             * | P P P |   P   |   P   |
             * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
             * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
             * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
             * won't make it *more* imbalanced.
             * It's a required field.
             */
            whenUnsatisfiable?: pulumi.Input<string>;
        }
        /**
         * LabelSelector is used to find matching pods.
         * Pods that match this label selector are counted to determine the number of pods
         * in their corresponding topology domain.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Volume represents a named volume in a pod that may be accessed by any container in the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs>;
            cinder?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder>;
            configMap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap>;
            csi?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir>;
            ephemeral?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral>;
            fc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc>;
            flexVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath>;
            image?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage>;
            iscsi?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi>;
            /**
             * name of the volume.
             * Must be a DNS_LABEL and unique within the pod.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected>;
            quobyte?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIO>;
            secret?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret>;
            storageos?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume>;
        }
        /**
         * awsElasticBlockStore represents an AWS Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
         * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAwsElasticBlockStore {
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            fsType?: pulumi.Input<string>;
            /**
             * partition is the partition in the volume that you want to mount.
             * If omitted, the default is to mount by volume name.
             * Examples: For volume /dev/sda1, you specify the partition as "1".
             * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
             */
            partition?: pulumi.Input<number>;
            /**
             * readOnly value true will force the readOnly setting in VolumeMounts.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
         * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
         * are redirected to the disk.csi.azure.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureDisk {
            /**
             * cachingMode is the Host Caching mode: None, Read Only, Read Write.
             */
            cachingMode?: pulumi.Input<string>;
            /**
             * diskName is the Name of the data disk in the blob storage
             */
            diskName?: pulumi.Input<string>;
            /**
             * diskURI is the URI of data disk in the blob storage
             */
            diskURI?: pulumi.Input<string>;
            /**
             * fsType is Filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
             */
            kind?: pulumi.Input<string>;
            /**
             * readOnly Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
         * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
         * are redirected to the file.csi.azure.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesAzureFile {
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * secretName is the  name of secret that contains Azure Storage Account Name and Key
             */
            secretName?: pulumi.Input<string>;
            /**
             * shareName is the azure share Name
             */
            shareName?: pulumi.Input<string>;
        }
        /**
         * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
         * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfs {
            /**
             * monitors is Required: Monitors is a collection of Ceph monitors
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            monitors?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef>;
            /**
             * user is optional: User is the rados user name, default is admin
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            user?: pulumi.Input<string>;
        }
        /**
         * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCephfsSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * cinder represents a cinder volume attached and mounted on kubelets host machine.
         * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
         * are redirected to the cinder.csi.openstack.org CSI driver.
         * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinder {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef>;
            /**
             * volumeID used to identify the volume in cinder.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * secretRef is optional: points to a secret object containing parameters used to connect
         * to OpenStack.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCinderSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * configMap represents a configMap that should populate this volume
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMap {
            /**
             * defaultMode is optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * ConfigMap will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the ConfigMap,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional specify whether the ConfigMap or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesConfigMapItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsi {
            /**
             * driver is the name of the CSI driver that handles this volume.
             * Consult with your admin for the correct name as registered in the cluster.
             */
            driver?: pulumi.Input<string>;
            /**
             * fsType to mount. Ex. "ext4", "xfs", "ntfs".
             * If not provided, the empty value is passed to the associated CSI driver
             * which will determine the default filesystem to apply.
             */
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef>;
            /**
             * readOnly specifies a read-only configuration for the volume.
             * Defaults to false (read/write).
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeAttributes stores driver-specific properties that are passed to the CSI
             * driver. Consult your driver's documentation for supported values.
             */
            volumeAttributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * nodePublishSecretRef is a reference to the secret object containing
         * sensitive information to pass to the CSI driver to complete the CSI
         * NodePublishVolume and NodeUnpublishVolume calls.
         * This field is optional, and  may be empty if no secret is required. If the
         * secret object contains more than one secret, all secret references are passed.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesCsiNodePublishSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * downwardAPI represents downward API about the pod that should populate this volume
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPI {
            /**
             * Optional: mode bits to use on created files by default. Must be a
             * Optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * Items is a list of downward API volume file
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItems>[]>;
        }
        /**
         * DownwardAPIVolumeFile represents information to create the file containing the pod field
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsFieldRef>;
            /**
             * Optional: mode bits used to set permissions on this file, must be an octal value
             * between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
             */
            path?: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsResourceFieldRef>;
        }
        /**
         * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesDownwardAPIItemsResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * emptyDir represents a temporary directory that shares a pod's lifetime.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEmptyDir {
            /**
             * medium represents what type of storage medium should back this directory.
             * The default is "" which means to use the node's default medium.
             * Must be an empty string (default) or Memory.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
             */
            medium?: pulumi.Input<string>;
            /**
             * sizeLimit is the total amount of local storage required for this EmptyDir volume.
             * The size limit is also applicable for memory medium.
             * The maximum usage on memory medium EmptyDir would be the minimum value between
             * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
             * The default is nil which means that the limit is undefined.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
             */
            sizeLimit?: pulumi.Input<number | string>;
        }
        /**
         * ephemeral represents a volume that is handled by a cluster storage driver.
         * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
         * and deleted when the pod is removed.
         *
         * Use this if:
         * a) the volume is only needed while the pod runs,
         * b) features of normal volumes like restoring from snapshot or capacity
         *    tracking are needed,
         * c) the storage driver is specified through a storage class, and
         * d) the storage driver supports dynamic volume provisioning through
         *    a PersistentVolumeClaim (see EphemeralVolumeSource for more
         *    information on the connection between this volume type
         *    and PersistentVolumeClaim).
         *
         * Use PersistentVolumeClaim or one of the vendor-specific
         * APIs for volumes that persist for longer than the lifecycle
         * of an individual pod.
         *
         * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
         * be used that way - see the documentation of the driver for
         * more information.
         *
         * A pod can use both types of ephemeral volumes and
         * persistent volumes at the same time.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeral {
            volumeClaimTemplate?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate>;
        }
        /**
         * Will be used to create a stand-alone PVC to provision the volume.
         * The pod in which this EphemeralVolumeSource is embedded will be the
         * owner of the PVC, i.e. the PVC will be deleted together with the
         * pod.  The name of the PVC will be `<pod name>-<volume name>` where
         * `<volume name>` is the name from the `PodSpec.Volumes` array
         * entry. Pod validation will reject the pod if the concatenated name
         * is not valid for a PVC (for example, too long).
         *
         * An existing PVC with that name that is not owned by the pod
         * will *not* be used for the pod to avoid using an unrelated
         * volume by mistake. Starting the pod is then blocked until
         * the unrelated PVC is removed. If such a pre-created PVC is
         * meant to be used by the pod, the PVC has to updated with an
         * owner reference to the pod once the pod exists. Normally
         * this should not be necessary, but it may be useful when
         * manually reconstructing a broken cluster.
         *
         * This field is read-only and no changes will be made by Kubernetes
         * to the PVC after it has been created.
         *
         * Required, must not be nil.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplate {
            /**
             * May contain labels and annotations that will be copied into the PVC
             * when creating it. No other fields are allowed and will be rejected during
             * validation.
             */
            metadata?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec>;
        }
        /**
         * The specification for the PersistentVolumeClaim. The entire content is
         * copied unchanged into the PVC that gets created from this
         * template. The same fields as in a PersistentVolumeClaim
         * are also valid here.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpec {
            /**
             * accessModes contains the desired access modes the volume should have.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
             */
            accessModes?: pulumi.Input<pulumi.Input<string>[]>;
            dataSource?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource>;
            dataSourceRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>;
            resources?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources>;
            selector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector>;
            /**
             * storageClassName is the name of the StorageClass required by the claim.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
             */
            storageClassName?: pulumi.Input<string>;
            /**
             * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
             * If specified, the CSI driver will create or update the volume with the attributes defined
             * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
             * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
             * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
             * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
             * will be set by the persistentvolume controller if it exists.
             * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
             * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
             * exists.
             * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
             * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
             */
            volumeAttributesClassName?: pulumi.Input<string>;
            /**
             * volumeMode defines what type of volume is required by the claim.
             * Value of Filesystem is implied when not included in claim spec.
             */
            volumeMode?: pulumi.Input<string>;
            /**
             * volumeName is the binding reference to the PersistentVolume backing this claim.
             */
            volumeName?: pulumi.Input<string>;
        }
        /**
         * dataSource field can be used to specify either:
         * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
         * * An existing PVC (PersistentVolumeClaim)
         * If the provisioner or an external controller can support the specified data source,
         * it will create a new volume based on the contents of the specified data source.
         * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
         * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
         * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSource {
            /**
             * APIGroup is the group for the resource being referenced.
             * If APIGroup is not specified, the specified Kind must be in the core API group.
             * For any other third-party types, APIGroup is required.
             */
            apiGroup?: pulumi.Input<string>;
            /**
             * Kind is the type of resource being referenced
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of resource being referenced
             */
            name?: pulumi.Input<string>;
        }
        /**
         * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
         * volume is desired. This may be any object from a non-empty API group (non
         * core object) or a PersistentVolumeClaim object.
         * When this field is specified, volume binding will only succeed if the type of
         * the specified object matches some installed volume populator or dynamic
         * provisioner.
         * This field will replace the functionality of the dataSource field and as such
         * if both fields are non-empty, they must have the same value. For backwards
         * compatibility, when namespace isn't specified in dataSourceRef,
         * both fields (dataSource and dataSourceRef) will be set to the same
         * value automatically if one of them is empty and the other is non-empty.
         * When namespace is specified in dataSourceRef,
         * dataSource isn't set to the same value and must be empty.
         * There are three important differences between dataSource and dataSourceRef:
         * * While dataSource only allows two specific types of objects, dataSourceRef
         *   allows any non-core object, as well as PersistentVolumeClaim objects.
         * * While dataSource ignores disallowed values (dropping them), dataSourceRef
         *   preserves all values, and generates an error if a disallowed value is
         *   specified.
         * * While dataSource only allows local objects, dataSourceRef allows objects
         *   in any namespaces.
         * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
         * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
            /**
             * APIGroup is the group for the resource being referenced.
             * If APIGroup is not specified, the specified Kind must be in the core API group.
             * For any other third-party types, APIGroup is required.
             */
            apiGroup?: pulumi.Input<string>;
            /**
             * Kind is the type of resource being referenced
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of resource being referenced
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of resource being referenced
             * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
             * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * resources represents the minimum resources the volume should have.
         * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
         * that are lower than previous value but must still be higher than capacity recorded in the
         * status field of the claim.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
        }
        /**
         * selector is a label query over volumes to consider for binding.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFc {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * lun is Optional: FC target lun number
             */
            lun?: pulumi.Input<number>;
            /**
             * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * targetWWNs is Optional: FC target worldwide names (WWNs)
             */
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * wwids Optional: FC volume world wide identifiers (wwids)
             * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
             */
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * flexVolume represents a generic volume resource that is
         * provisioned/attached using an exec based plugin.
         * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolume {
            /**
             * driver is the name of the driver to use for this volume.
             */
            driver?: pulumi.Input<string>;
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
             */
            fsType?: pulumi.Input<string>;
            /**
             * options is Optional: this field holds extra command options if any.
             */
            options?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef>;
        }
        /**
         * secretRef is Optional: secretRef is reference to the secret object containing
         * sensitive information to pass to the plugin scripts. This may be
         * empty if no secret object is specified. If the secret object
         * contains more than one secret, all secrets are passed to the plugin
         * scripts.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlexVolumeSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
         * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesFlocker {
            /**
             * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
             * should be considered as deprecated
             */
            datasetName?: pulumi.Input<string>;
            /**
             * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
             */
            datasetUUID?: pulumi.Input<string>;
        }
        /**
         * gcePersistentDisk represents a GCE Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
         * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGcePersistentDisk {
            /**
             * fsType is filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            fsType?: pulumi.Input<string>;
            /**
             * partition is the partition in the volume that you want to mount.
             * If omitted, the default is to mount by volume name.
             * Examples: For volume /dev/sda1, you specify the partition as "1".
             * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            partition?: pulumi.Input<number>;
            /**
             * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            pdName?: pulumi.Input<string>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * gitRepo represents a git repository at a particular revision.
         * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
         * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
         * into the Pod's container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGitRepo {
            /**
             * directory is the target directory name.
             * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
             * git repository.  Otherwise, if specified, the volume will contain the git repository in
             * the subdirectory with the given name.
             */
            directory?: pulumi.Input<string>;
            /**
             * repository is the URL
             */
            repository?: pulumi.Input<string>;
            /**
             * revision is the commit hash for the specified revision.
             */
            revision?: pulumi.Input<string>;
        }
        /**
         * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
         * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
         * More info: https://examples.k8s.io/volumes/glusterfs/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesGlusterfs {
            /**
             * endpoints is the endpoint name that details Glusterfs topology.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            endpoints?: pulumi.Input<string>;
            /**
             * path is the Glusterfs volume path.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
             * Defaults to false.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * hostPath represents a pre-existing file or directory on the host
         * machine that is directly exposed to the container. This is generally
         * used for system agents or other privileged things that are allowed
         * to see the host machine. Most containers will NOT need this.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesHostPath {
            /**
             * path of the directory on the host.
             * If the path is a symlink, it will follow the link to the real path.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
             */
            path?: pulumi.Input<string>;
            /**
             * type for HostPath Volume
             * Defaults to ""
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
             */
            type?: pulumi.Input<string>;
        }
        /**
         * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
         * The volume is resolved at pod startup depending on which PullPolicy value is provided:
         *
         * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
         * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
         * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
         *
         * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
         * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
         * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
         * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
         * The volume will be mounted read-only (ro) and non-executable files (noexec).
         * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
         * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesImage {
            /**
             * Policy for pulling OCI objects. Possible values are:
             * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
             * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
             * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
             * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
             */
            pullPolicy?: pulumi.Input<string>;
            /**
             * Required: Image or artifact reference to be used.
             * Behaves in the same way as pod.spec.containers[*].image.
             * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
             * More info: https://kubernetes.io/docs/concepts/containers/images
             * This field is optional to allow higher level config management to default or override
             * container images in workload controllers like Deployments and StatefulSets.
             */
            reference?: pulumi.Input<string>;
        }
        /**
         * iscsi represents an ISCSI Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * More info: https://examples.k8s.io/volumes/iscsi/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsi {
            /**
             * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
             */
            chapAuthDiscovery?: pulumi.Input<boolean>;
            /**
             * chapAuthSession defines whether support iSCSI Session CHAP authentication
             */
            chapAuthSession?: pulumi.Input<boolean>;
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
             */
            fsType?: pulumi.Input<string>;
            /**
             * initiatorName is the custom iSCSI Initiator Name.
             * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
             * <target portal>:<volume name> will be created for the connection.
             */
            initiatorName?: pulumi.Input<string>;
            /**
             * iqn is the target iSCSI Qualified Name.
             */
            iqn?: pulumi.Input<string>;
            /**
             * iscsiInterface is the interface Name that uses an iSCSI transport.
             * Defaults to 'default' (tcp).
             */
            iscsiInterface?: pulumi.Input<string>;
            /**
             * lun represents iSCSI Target Lun number.
             */
            lun?: pulumi.Input<number>;
            /**
             * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
             * is other than default (typically TCP ports 860 and 3260).
             */
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef>;
            /**
             * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
             * is other than default (typically TCP ports 860 and 3260).
             */
            targetPortal?: pulumi.Input<string>;
        }
        /**
         * secretRef is the CHAP Secret for iSCSI target and initiator authentication
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesIscsiSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * nfs represents an NFS mount on the host that shares a pod's lifetime
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesNfs {
            /**
             * path that is exported by the NFS server.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly here will force the NFS export to be mounted with read-only permissions.
             * Defaults to false.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * server is the hostname or IP address of the NFS server.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            server?: pulumi.Input<string>;
        }
        /**
         * persistentVolumeClaimVolumeSource represents a reference to a
         * PersistentVolumeClaim in the same namespace.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPersistentVolumeClaim {
            /**
             * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
             */
            claimName?: pulumi.Input<string>;
            /**
             * readOnly Will force the ReadOnly setting in VolumeMounts.
             * Default false.
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
         * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPhotonPersistentDisk {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * pdID is the ID that identifies Photon Controller persistent disk
             */
            pdID?: pulumi.Input<string>;
        }
        /**
         * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
         * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
         * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
         * is on.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesPortworxVolume {
            /**
             * fSType represents the filesystem type to mount
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeID uniquely identifies a Portworx volume
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * projected items for all in one resources secrets, configmaps, and downward API
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjected {
            /**
             * defaultMode are the mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * sources is the list of volume projections. Each entry in this list
             * handles one source.
             */
            sources?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources>[]>;
        }
        /**
         * Projection that may be projected along with other supported volume types.
         * Exactly one of these fields must be set.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSources {
            clusterTrustBundle?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle>;
            configMap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken>;
        }
        /**
         * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
         * of ClusterTrustBundle objects in an auto-updating file.
         *
         * Alpha, gated by the ClusterTrustBundleProjection feature gate.
         *
         * ClusterTrustBundle objects can either be selected by name, or by the
         * combination of signer name and a label selector.
         *
         * Kubelet performs aggressive normalization of the PEM contents written
         * into the pod filesystem.  Esoteric PEM features such as inter-block
         * comments and block headers are stripped.  Certificates are deduplicated.
         * The ordering of certificates within the file is arbitrary, and Kubelet
         * may change the order over time.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundle {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector>;
            /**
             * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
             * with signerName and labelSelector.
             */
            name?: pulumi.Input<string>;
            /**
             * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
             * aren't available.  If using name, then the named ClusterTrustBundle is
             * allowed not to exist.  If using signerName, then the combination of
             * signerName and labelSelector is allowed to match zero
             * ClusterTrustBundles.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * Relative path from the volume root to write the bundle.
             */
            path?: pulumi.Input<string>;
            /**
             * Select all ClusterTrustBundles that match this signer name.
             * Mutually-exclusive with name.  The contents of all selected
             * ClusterTrustBundles will be unified and deduplicated.
             */
            signerName?: pulumi.Input<string>;
        }
        /**
         * Select all ClusterTrustBundles that match this label selector.  Only has
         * effect if signerName is set.  Mutually-exclusive with name.  If unset,
         * interpreted as "match nothing".  If set but empty, interpreted as "match
         * everything".
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * configMap information about the configMap data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMap {
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * ConfigMap will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the ConfigMap,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional specify whether the ConfigMap or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesConfigMapItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * downwardAPI information about the downwardAPI data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPI {
            /**
             * Items is a list of DownwardAPIVolume file
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItems>[]>;
        }
        /**
         * DownwardAPIVolumeFile represents information to create the file containing the pod field
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            /**
             * Optional: mode bits used to set permissions on this file, must be an octal value
             * between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
             */
            path?: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }
        /**
         * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * secret information about the secret data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecret {
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * Secret will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the Secret,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional field specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesSecretItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * serviceAccountToken is information about the serviceAccountToken data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesProjectedSourcesServiceAccountToken {
            /**
             * audience is the intended audience of the token. A recipient of a token
             * must identify itself with an identifier specified in the audience of the
             * token, and otherwise should reject the token. The audience defaults to the
             * identifier of the apiserver.
             */
            audience?: pulumi.Input<string>;
            /**
             * expirationSeconds is the requested duration of validity of the service
             * account token. As the token approaches expiration, the kubelet volume
             * plugin will proactively rotate the service account token. The kubelet will
             * start trying to rotate the token if the token is older than 80 percent of
             * its time to live or if the token is older than 24 hours.Defaults to 1 hour
             * and must be at least 10 minutes.
             */
            expirationSeconds?: pulumi.Input<number>;
            /**
             * path is the path relative to the mount point of the file to project the
             * token into.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
         * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesQuobyte {
            /**
             * group to map volume access to
             * Default is no group
             */
            group?: pulumi.Input<string>;
            /**
             * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * registry represents a single or multiple Quobyte Registry services
             * specified as a string as host:port pair (multiple entries are separated with commas)
             * which acts as the central registry for volumes
             */
            registry?: pulumi.Input<string>;
            /**
             * tenant owning the given Quobyte volume in the Backend
             * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
             */
            tenant?: pulumi.Input<string>;
            /**
             * user to map volume access to
             * Defaults to serivceaccount user
             */
            user?: pulumi.Input<string>;
            /**
             * volume is a string that references an already created Quobyte volume by name.
             */
            volume?: pulumi.Input<string>;
        }
        /**
         * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
         * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
         * More info: https://examples.k8s.io/volumes/rbd/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbd {
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
             */
            fsType?: pulumi.Input<string>;
            /**
             * image is the rados image name.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            image?: pulumi.Input<string>;
            /**
             * keyring is the path to key ring for RBDUser.
             * Default is /etc/ceph/keyring.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            keyring?: pulumi.Input<string>;
            /**
             * monitors is a collection of Ceph monitors.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            monitors?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * pool is the rados pool name.
             * Default is rbd.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            pool?: pulumi.Input<string>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef>;
            /**
             * user is the rados user name.
             * Default is admin.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            user?: pulumi.Input<string>;
        }
        /**
         * secretRef is name of the authentication secret for RBDUser. If provided
         * overrides keyring.
         * Default is nil.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesRbdSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
         * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIO {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs".
             * Default is "xfs".
             */
            fsType?: pulumi.Input<string>;
            /**
             * gateway is the host address of the ScaleIO API Gateway.
             */
            gateway?: pulumi.Input<string>;
            /**
             * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
             */
            protectionDomain?: pulumi.Input<string>;
            /**
             * readOnly Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIOSecretRef>;
            /**
             * sslEnabled Flag enable/disable SSL communication with Gateway, default false
             */
            sslEnabled?: pulumi.Input<boolean>;
            /**
             * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
             * Default is ThinProvisioned.
             */
            storageMode?: pulumi.Input<string>;
            /**
             * storagePool is the ScaleIO Storage Pool associated with the protection domain.
             */
            storagePool?: pulumi.Input<string>;
            /**
             * system is the name of the storage system as configured in ScaleIO.
             */
            system?: pulumi.Input<string>;
            /**
             * volumeName is the name of a volume already created in the ScaleIO system
             * that is associated with this volume source.
             */
            volumeName?: pulumi.Input<string>;
        }
        /**
         * secretRef references to the secret for ScaleIO user and other
         * sensitive information. If this is not provided, Login operation will fail.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesScaleIOSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * secret represents a secret that should populate this volume.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecret {
            /**
             * defaultMode is Optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values
             * for mode bits. Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * items If unspecified, each key-value pair in the Data field of the referenced
             * Secret will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the Secret,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems>[]>;
            /**
             * optional field specify whether the Secret or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
            /**
             * secretName is the name of the secret in the pod's namespace to use.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
             */
            secretName?: pulumi.Input<string>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesSecretItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
         * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageos {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef>;
            /**
             * volumeName is the human-readable name of the StorageOS volume.  Volume
             * names are only unique within a namespace.
             */
            volumeName?: pulumi.Input<string>;
            /**
             * volumeNamespace specifies the scope of the volume within StorageOS.  If no
             * namespace is specified then the Pod's namespace will be used.  This allows the
             * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
             * Set VolumeName to any name to override the default behaviour.
             * Set to "default" if you are not using namespaces within StorageOS.
             * Namespaces that do not pre-exist within StorageOS will be created.
             */
            volumeNamespace?: pulumi.Input<string>;
        }
        /**
         * secretRef specifies the secret to use for obtaining the StorageOS API
         * credentials.  If not specified, default values will be attempted.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesStorageosSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
         * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
         * are redirected to the csi.vsphere.vmware.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPodVolumesVsphereVolume {
            /**
             * fsType is filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
             */
            storagePolicyID?: pulumi.Input<string>;
            /**
             * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
             */
            storagePolicyName?: pulumi.Input<string>;
            /**
             * volumePath is the path that identifies vSphere volume vmdk
             */
            volumePath?: pulumi.Input<string>;
        }
        /**
         * The daemonset strategy to use to replace existing pods with new ones.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategy {
            rollingUpdate?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate>;
            /**
             * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Rolling update config params. Present only if type = "RollingUpdate".
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDaemonSetStrategyRollingUpdate {
            /**
             * The maximum number of nodes with an existing available DaemonSet pod that
             * can have an updated DaemonSet pod during during an update.
             * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
             * This can not be 0 if MaxUnavailable is 0.
             * Absolute number is calculated from percentage by rounding up to a minimum of 1.
             * Default value is 0.
             * Example: when this is set to 30%, at most 30% of the total number of nodes
             * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
             * can have their a new pod created before the old pod is marked as deleted.
             * The update starts by launching new pods on 30% of nodes. Once an updated
             * pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
             * on that node is marked deleted. If the old pod becomes unavailable for any
             * reason (Ready transitions to false, is evicted, or is drained) an updated
             * pod is immediatedly created on that node without considering surge limits.
             * Allowing surge implies the possibility that the resources consumed by the
             * daemonset on any given node can double if the readiness check fails, and
             * so resource intensive daemonsets should take into account that they may
             * cause evictions during disruption.
             */
            maxSurge?: pulumi.Input<number | string>;
            /**
             * The maximum number of DaemonSet pods that can be unavailable during the
             * update. Value can be an absolute number (ex: 5) or a percentage of total
             * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
             * number is calculated from percentage by rounding up.
             * This cannot be 0 if MaxSurge is 0
             * Default value is 1.
             * Example: when this is set to 30%, at most 30% of the total number of nodes
             * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
             * can have their pods stopped for an update at any given time. The update
             * starts by stopping at most 30% of those DaemonSet pods and then brings
             * up new DaemonSet pods in their place. Once the new pods are available,
             * it then proceeds onto other DaemonSet pods, thus ensuring that at least
             * 70% of original number of DaemonSet pods are available at all times during
             * the update.
             */
            maxUnavailable?: pulumi.Input<number | string>;
        }
        /**
         * EnvoyDeployment defines the desired state of the Envoy deployment resource.
         * If unspecified, default settings for the managed Envoy deployment resource
         * are applied.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeployment {
            container?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer>;
            /**
             * List of initialization containers belonging to the pod.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
             */
            initContainers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers>[]>;
            /**
             * Name of the deployment.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
            patch?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch>;
            pod?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod>;
            /**
             * Replicas is the number of desired pods. Defaults to 1.
             */
            replicas?: pulumi.Input<number>;
            strategy?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy>;
        }
        /**
         * Container defines the desired specification of main container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainer {
            /**
             * List of environment variables to set in the container.
             */
            env?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv>[]>;
            /**
             * Image specifies the EnvoyProxy container image to be used including a tag, instead of the default image.
             * This field is mutually exclusive with ImageRepository.
             */
            image?: pulumi.Input<string>;
            /**
             * ImageRepository specifies the container image repository to be used without specifying a tag.
             * The default tag will be used.
             * This field is mutually exclusive with Image.
             */
            imageRepository?: pulumi.Input<string>;
            resources?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources>;
            securityContext?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext>;
            /**
             * VolumeMounts are volumes to mount into the container's filesystem.
             * Cannot be updated.
             */
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts>[]>;
        }
        /**
         * EnvVar represents an environment variable present in a Container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name?: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded
             * using the previously defined environment variables in the container and
             * any service environment variables. If a variable cannot be resolved,
             * the reference in the input string will be unchanged. Double $$ are reduced
             * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
             * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
             * Escaped references will never be expanded, regardless of whether the variable
             * exists or not.
             * Defaults to "".
             */
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom>;
        }
        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef>;
        }
        /**
         * Selects a key of a ConfigMap.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
         * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * Selects a key of a secret in the pod's namespace
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerEnvValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Resources required by this container.
         * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
        }
        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name?: pulumi.Input<string>;
            /**
             * Request is the name chosen for a request in the referenced claim.
             * If empty, everything from the claim is made available, otherwise
             * only the result of this request.
             */
            request?: pulumi.Input<string>;
        }
        /**
         * SecurityContext defines the security options the container should be run with.
         * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
         * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            appArmorProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile>;
            capabilities?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default value is Default which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions>;
            seccompProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile>;
            windowsOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions>;
        }
        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }
        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }
        /**
         * VolumeMount describes a mounting of a Volume within a container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentContainerVolumeMounts {
            /**
             * Path within the container at which the volume should be mounted.  Must
             * not contain ':'.
             */
            mountPath?: pulumi.Input<string>;
            /**
             * mountPropagation determines how mounts are propagated from the host
             * to container and the other way around.
             * When not set, MountPropagationNone is used.
             * This field is beta in 1.10.
             * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
             * (which defaults to None).
             */
            mountPropagation?: pulumi.Input<string>;
            /**
             * This must match the Name of a Volume.
             */
            name?: pulumi.Input<string>;
            /**
             * Mounted read-only if true, read-write otherwise (false or unspecified).
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * RecursiveReadOnly specifies whether read-only mounts should be handled
             * recursively.
             *
             * If ReadOnly is false, this field has no meaning and must be unspecified.
             *
             * If ReadOnly is true, and this field is set to Disabled, the mount is not made
             * recursively read-only.  If this field is set to IfPossible, the mount is made
             * recursively read-only, if it is supported by the container runtime.  If this
             * field is set to Enabled, the mount is made recursively read-only if it is
             * supported by the container runtime, otherwise the pod will not be started and
             * an error will be generated to indicate the reason.
             *
             * If this field is set to IfPossible or Enabled, MountPropagation must be set to
             * None (or be unspecified, which defaults to None).
             *
             * If this field is not specified, it is treated as an equivalent of Disabled.
             */
            recursiveReadOnly?: pulumi.Input<string>;
            /**
             * Path within the volume from which the container's volume should be mounted.
             * Defaults to "" (volume's root).
             */
            subPath?: pulumi.Input<string>;
            /**
             * Expanded path within the volume from which the container's volume should be mounted.
             * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
             * Defaults to "" (volume's root).
             * SubPathExpr and SubPath are mutually exclusive.
             */
            subPathExpr?: pulumi.Input<string>;
        }
        /**
         * A single application container that you want to run within a pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainers {
            /**
             * Arguments to the entrypoint.
             * The container image's CMD is used if this is not provided.
             * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
             * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
             * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
             * of whether the variable exists or not. Cannot be updated.
             * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
             */
            args?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Entrypoint array. Not executed within a shell.
             * The container image's ENTRYPOINT is used if this is not provided.
             * Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
             * cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
             * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
             * of whether the variable exists or not. Cannot be updated.
             * More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * List of environment variables to set in the container.
             * Cannot be updated.
             */
            env?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv>[]>;
            /**
             * List of sources to populate environment variables in the container.
             * The keys defined within a source must be a C_IDENTIFIER. All invalid keys
             * will be reported as an event when the container is starting. When a key exists in multiple
             * sources, the value associated with the last source will take precedence.
             * Values defined by an Env with a duplicate key will take precedence.
             * Cannot be updated.
             */
            envFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom>[]>;
            /**
             * Container image name.
             * More info: https://kubernetes.io/docs/concepts/containers/images
             * This field is optional to allow higher level config management to default or override
             * container images in workload controllers like Deployments and StatefulSets.
             */
            image?: pulumi.Input<string>;
            /**
             * Image pull policy.
             * One of Always, Never, IfNotPresent.
             * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
             * Cannot be updated.
             * More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
             */
            imagePullPolicy?: pulumi.Input<string>;
            lifecycle?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle>;
            livenessProbe?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe>;
            /**
             * Name of the container specified as a DNS_LABEL.
             * Each container in a pod must have a unique name (DNS_LABEL).
             * Cannot be updated.
             */
            name?: pulumi.Input<string>;
            /**
             * List of ports to expose from the container. Not specifying a port here
             * DOES NOT prevent that port from being exposed. Any port which is
             * listening on the default "0.0.0.0" address inside a container will be
             * accessible from the network.
             * Modifying this array with strategic merge patch may corrupt the data.
             * For more information See https://github.com/kubernetes/kubernetes/issues/108255.
             * Cannot be updated.
             */
            ports?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts>[]>;
            readinessProbe?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe>;
            /**
             * Resources resize policy for the container.
             */
            resizePolicy?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy>[]>;
            resources?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources>;
            /**
             * RestartPolicy defines the restart behavior of individual containers in a pod.
             * This field may only be set for init containers, and the only allowed value is "Always".
             * For non-init containers or when this field is not specified,
             * the restart behavior is defined by the Pod's restart policy and the container type.
             * Setting the RestartPolicy as "Always" for the init container will have the following effect:
             * this init container will be continually restarted on
             * exit until all regular containers have terminated. Once all regular
             * containers have completed, all init containers with restartPolicy "Always"
             * will be shut down. This lifecycle differs from normal init containers and
             * is often referred to as a "sidecar" container. Although this init
             * container still starts in the init container sequence, it does not wait
             * for the container to complete before proceeding to the next init
             * container. Instead, the next init container starts immediately after this
             * init container is started, or after any startupProbe has successfully
             * completed.
             */
            restartPolicy?: pulumi.Input<string>;
            securityContext?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext>;
            startupProbe?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe>;
            /**
             * Whether this container should allocate a buffer for stdin in the container runtime. If this
             * is not set, reads from stdin in the container will always result in EOF.
             * Default is false.
             */
            stdin?: pulumi.Input<boolean>;
            /**
             * Whether the container runtime should close the stdin channel after it has been opened by
             * a single attach. When stdin is true the stdin stream will remain open across multiple attach
             * sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
             * first client attaches to stdin, and then remains open and accepts data until the client disconnects,
             * at which time stdin is closed and remains closed until the container is restarted. If this
             * flag is false, a container processes that reads from stdin will never receive an EOF.
             * Default is false
             */
            stdinOnce?: pulumi.Input<boolean>;
            /**
             * Optional: Path at which the file to which the container's termination message
             * will be written is mounted into the container's filesystem.
             * Message written is intended to be brief final status, such as an assertion failure message.
             * Will be truncated by the node if greater than 4096 bytes. The total message length across
             * all containers will be limited to 12kb.
             * Defaults to /dev/termination-log.
             * Cannot be updated.
             */
            terminationMessagePath?: pulumi.Input<string>;
            /**
             * Indicate how the termination message should be populated. File will use the contents of
             * terminationMessagePath to populate the container status message on both success and failure.
             * FallbackToLogsOnError will use the last chunk of container log output if the termination
             * message file is empty and the container exited with an error.
             * The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
             * Defaults to File.
             * Cannot be updated.
             */
            terminationMessagePolicy?: pulumi.Input<string>;
            /**
             * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
             * Default is false.
             */
            tty?: pulumi.Input<boolean>;
            /**
             * volumeDevices is the list of block devices to be used by the container.
             */
            volumeDevices?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices>[]>;
            /**
             * Pod volumes to mount into the container's filesystem.
             * Cannot be updated.
             */
            volumeMounts?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts>[]>;
            /**
             * Container's working directory.
             * If not specified, the container runtime's default will be used, which
             * might be configured in the container image.
             * Cannot be updated.
             */
            workingDir?: pulumi.Input<string>;
        }
        /**
         * EnvVar represents an environment variable present in a Container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name?: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded
             * using the previously defined environment variables in the container and
             * any service environment variables. If a variable cannot be resolved,
             * the reference in the input string will be unchanged. Double $$ are reduced
             * to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
             * "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
             * Escaped references will never be expanded, regardless of whether the variable
             * exists or not.
             * Defaults to "".
             */
            value?: pulumi.Input<string>;
            valueFrom?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom>;
        }
        /**
         * EnvFromSource represents the source of a set of ConfigMaps or Secrets
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFrom {
            configMapRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef>;
            /**
             * Optional text to prepend to the name of each environment variable. Must be a C_IDENTIFIER.
             */
            prefix?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef>;
        }
        /**
         * The ConfigMap to select from
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromConfigMapRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * The Secret to select from
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvFromSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Source for the environment variable's value. Cannot be used if value is not empty.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFrom {
            configMapKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef>;
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef>;
            secretKeyRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef>;
        }
        /**
         * Selects a key of a ConfigMap.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromConfigMapKeyRef {
            /**
             * The key to select.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the ConfigMap or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
         * spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * Selects a key of a secret in the pod's namespace
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersEnvValueFromSecretKeyRef {
            /**
             * The key of the secret to select from.  Must be a valid secret key.
             */
            key?: pulumi.Input<string>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * Specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Actions that the management system should take in response to container lifecycle events.
         * Cannot be updated.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecycle {
            postStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart>;
            preStop?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop>;
            /**
             * StopSignal defines which signal will be sent to a container when it is being stopped.
             * If not specified, the default is defined by the container runtime in use.
             * StopSignal can only be set for Pods with a non-empty .spec.os.name
             */
            stopSignal?: pulumi.Input<string>;
        }
        /**
         * PostStart is called immediately after a container is created. If the handler fails,
         * the container is terminated and restarted according to its restart policy.
         * Other management of the container blocks until the hook completes.
         * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStart {
            exec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec>;
            httpGet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet>;
            sleep?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep>;
            tcpSocket?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket>;
        }
        /**
         * Exec specifies a command to execute in the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the
             * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             * a shell, you need to explicitly call out to that shell.
             * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * HTTPGet specifies an HTTP GET request to perform.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set
             * "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
            /**
             * Scheme to use for connecting to the host.
             * Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartHttpGetHttpHeaders {
            /**
             * The header field name.
             * This will be canonicalized upon output, so case-variant names will be understood as the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * The header field value
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Sleep represents a duration that the container should sleep.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartSleep {
            /**
             * Seconds is the number of seconds to sleep.
             */
            seconds?: pulumi.Input<number>;
        }
        /**
         * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
         * for backward compatibility. There is no validation of this field and
         * lifecycle hooks will fail at runtime when it is specified.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePostStartTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
        }
        /**
         * PreStop is called immediately before a container is terminated due to an
         * API request or management event such as liveness/startup probe failure,
         * preemption, resource contention, etc. The handler is not called if the
         * container crashes or exits. The Pod's termination grace period countdown begins before the
         * PreStop hook is executed. Regardless of the outcome of the handler, the
         * container will eventually terminate within the Pod's termination grace
         * period (unless delayed by finalizers). Other management of the container blocks until the hook completes
         * or until the termination grace period is reached.
         * More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStop {
            exec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec>;
            httpGet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet>;
            sleep?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep>;
            tcpSocket?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket>;
        }
        /**
         * Exec specifies a command to execute in the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the
             * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             * a shell, you need to explicitly call out to that shell.
             * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * HTTPGet specifies an HTTP GET request to perform.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set
             * "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
            /**
             * Scheme to use for connecting to the host.
             * Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopHttpGetHttpHeaders {
            /**
             * The header field name.
             * This will be canonicalized upon output, so case-variant names will be understood as the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * The header field value
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Sleep represents a duration that the container should sleep.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopSleep {
            /**
             * Seconds is the number of seconds to sleep.
             */
            seconds?: pulumi.Input<number>;
        }
        /**
         * Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
         * for backward compatibility. There is no validation of this field and
         * lifecycle hooks will fail at runtime when it is specified.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLifecyclePreStopTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
        }
        /**
         * Periodic probe of container liveness.
         * Container will be restarted if the probe fails.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbe {
            exec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec>;
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             * Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc>;
            httpGet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe.
             * Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket>;
            /**
             * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
             * The grace period is the duration in seconds after the processes running in the pod are sent
             * a termination signal and the time when the processes are forcibly halted with a kill signal.
             * Set this value longer than the expected cleanup time for your process.
             * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
             * value overrides the value provided by the pod spec.
             * Value must be non-negative integer. The value zero indicates stop immediately via
             * the kill signal (no opportunity to shut down).
             * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
             * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * Number of seconds after which the probe times out.
             * Defaults to 1 second. Minimum value is 1.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            timeoutSeconds?: pulumi.Input<number>;
        }
        /**
         * Exec specifies a command to execute in the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the
             * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             * a shell, you need to explicitly call out to that shell.
             * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * GRPC specifies a GRPC HealthCheckRequest.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeGrpc {
            /**
             * Port number of the gRPC service. Number must be in the range 1 to 65535.
             */
            port?: pulumi.Input<number>;
            /**
             * Service is the name of the service to place in the gRPC HealthCheckRequest
             * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
             *
             * If this is not specified, the default behavior is defined by gRPC.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTPGet specifies an HTTP GET request to perform.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set
             * "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
            /**
             * Scheme to use for connecting to the host.
             * Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeHttpGetHttpHeaders {
            /**
             * The header field name.
             * This will be canonicalized upon output, so case-variant names will be understood as the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * The header field value
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TCPSocket specifies a connection to a TCP port.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersLivenessProbeTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
        }
        /**
         * ContainerPort represents a network port in a single container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersPorts {
            /**
             * Number of port to expose on the pod's IP address.
             * This must be a valid port number, 0 < x < 65536.
             */
            containerPort?: pulumi.Input<number>;
            /**
             * What host IP to bind the external port to.
             */
            hostIP?: pulumi.Input<string>;
            /**
             * Number of port to expose on the host.
             * If specified, this must be a valid port number, 0 < x < 65536.
             * If HostNetwork is specified, this must match ContainerPort.
             * Most containers do not need this.
             */
            hostPort?: pulumi.Input<number>;
            /**
             * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
             * named port in a pod must have a unique name. Name for the port that can be
             * referred to by services.
             */
            name?: pulumi.Input<string>;
            /**
             * Protocol for port. Must be UDP, TCP, or SCTP.
             * Defaults to "TCP".
             */
            protocol?: pulumi.Input<string>;
        }
        /**
         * Periodic probe of container service readiness.
         * Container will be removed from service endpoints if the probe fails.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbe {
            exec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec>;
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             * Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc>;
            httpGet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe.
             * Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket>;
            /**
             * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
             * The grace period is the duration in seconds after the processes running in the pod are sent
             * a termination signal and the time when the processes are forcibly halted with a kill signal.
             * Set this value longer than the expected cleanup time for your process.
             * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
             * value overrides the value provided by the pod spec.
             * Value must be non-negative integer. The value zero indicates stop immediately via
             * the kill signal (no opportunity to shut down).
             * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
             * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * Number of seconds after which the probe times out.
             * Defaults to 1 second. Minimum value is 1.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            timeoutSeconds?: pulumi.Input<number>;
        }
        /**
         * Exec specifies a command to execute in the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the
             * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             * a shell, you need to explicitly call out to that shell.
             * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * GRPC specifies a GRPC HealthCheckRequest.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeGrpc {
            /**
             * Port number of the gRPC service. Number must be in the range 1 to 65535.
             */
            port?: pulumi.Input<number>;
            /**
             * Service is the name of the service to place in the gRPC HealthCheckRequest
             * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
             *
             * If this is not specified, the default behavior is defined by gRPC.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTPGet specifies an HTTP GET request to perform.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set
             * "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
            /**
             * Scheme to use for connecting to the host.
             * Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeHttpGetHttpHeaders {
            /**
             * The header field name.
             * This will be canonicalized upon output, so case-variant names will be understood as the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * The header field value
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TCPSocket specifies a connection to a TCP port.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersReadinessProbeTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
        }
        /**
         * ContainerResizePolicy represents resource resize policy for the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResizePolicy {
            /**
             * Name of the resource to which this resource resize policy applies.
             * Supported values: cpu, memory.
             */
            resourceName?: pulumi.Input<string>;
            /**
             * Restart policy to apply when specified resource is resized.
             * If not specified, it defaults to NotRequired.
             */
            restartPolicy?: pulumi.Input<string>;
        }
        /**
         * Compute Resources required by this container.
         * Cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
        }
        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name?: pulumi.Input<string>;
            /**
             * Request is the name chosen for a request in the referenced claim.
             * If empty, everything from the claim is made available, otherwise
             * only the result of this request.
             */
            request?: pulumi.Input<string>;
        }
        /**
         * SecurityContext defines the security options the container should be run with.
         * If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
         * More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            appArmorProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile>;
            capabilities?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default value is Default which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            seLinuxOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions>;
            seccompProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile>;
            windowsOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions>;
        }
        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }
        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }
        /**
         * StartupProbe indicates that the Pod has successfully initialized.
         * If specified, no other probes are executed until this completes successfully.
         * If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
         * This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
         * when it might take a long time to load data or warm a cache, than during steady-state operation.
         * This cannot be updated.
         * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbe {
            exec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec>;
            /**
             * Minimum consecutive failures for the probe to be considered failed after having succeeded.
             * Defaults to 3. Minimum value is 1.
             */
            failureThreshold?: pulumi.Input<number>;
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc>;
            httpGet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet>;
            /**
             * Number of seconds after the container has started before liveness probes are initiated.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            initialDelaySeconds?: pulumi.Input<number>;
            /**
             * How often (in seconds) to perform the probe.
             * Default to 10 seconds. Minimum value is 1.
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * Minimum consecutive successes for the probe to be considered successful after having failed.
             * Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
             */
            successThreshold?: pulumi.Input<number>;
            tcpSocket?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket>;
            /**
             * Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
             * The grace period is the duration in seconds after the processes running in the pod are sent
             * a termination signal and the time when the processes are forcibly halted with a kill signal.
             * Set this value longer than the expected cleanup time for your process.
             * If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
             * value overrides the value provided by the pod spec.
             * Value must be non-negative integer. The value zero indicates stop immediately via
             * the kill signal (no opportunity to shut down).
             * This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
             * Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
             */
            terminationGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * Number of seconds after which the probe times out.
             * Defaults to 1 second. Minimum value is 1.
             * More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
             */
            timeoutSeconds?: pulumi.Input<number>;
        }
        /**
         * Exec specifies a command to execute in the container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeExec {
            /**
             * Command is the command line to execute inside the container, the working directory for the
             * command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
             * not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
             * a shell, you need to explicitly call out to that shell.
             * Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
             */
            command?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * GRPC specifies a GRPC HealthCheckRequest.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeGrpc {
            /**
             * Port number of the gRPC service. Number must be in the range 1 to 65535.
             */
            port?: pulumi.Input<number>;
            /**
             * Service is the name of the service to place in the gRPC HealthCheckRequest
             * (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
             *
             * If this is not specified, the default behavior is defined by gRPC.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTPGet specifies an HTTP GET request to perform.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGet {
            /**
             * Host name to connect to, defaults to the pod IP. You probably want to set
             * "Host" in httpHeaders instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Custom headers to set in the request. HTTP allows repeated headers.
             */
            httpHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders>[]>;
            /**
             * Path to access on the HTTP server.
             */
            path?: pulumi.Input<string>;
            /**
             * Name or number of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
            /**
             * Scheme to use for connecting to the host.
             * Defaults to HTTP.
             */
            scheme?: pulumi.Input<string>;
        }
        /**
         * HTTPHeader describes a custom header to be used in HTTP probes
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeHttpGetHttpHeaders {
            /**
             * The header field name.
             * This will be canonicalized upon output, so case-variant names will be understood as the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * The header field value
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TCPSocket specifies a connection to a TCP port.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersStartupProbeTcpSocket {
            /**
             * Optional: Host name to connect to, defaults to the pod IP.
             */
            host?: pulumi.Input<string>;
            /**
             * Number or name of the port to access on the container.
             * Number must be in the range 1 to 65535.
             * Name must be an IANA_SVC_NAME.
             */
            port?: pulumi.Input<number | string>;
        }
        /**
         * volumeDevice describes a mapping of a raw block device within a container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeDevices {
            /**
             * devicePath is the path inside of the container that the device will be mapped to.
             */
            devicePath?: pulumi.Input<string>;
            /**
             * name must match the name of a persistentVolumeClaim in the pod
             */
            name?: pulumi.Input<string>;
        }
        /**
         * VolumeMount describes a mounting of a Volume within a container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentInitContainersVolumeMounts {
            /**
             * Path within the container at which the volume should be mounted.  Must
             * not contain ':'.
             */
            mountPath?: pulumi.Input<string>;
            /**
             * mountPropagation determines how mounts are propagated from the host
             * to container and the other way around.
             * When not set, MountPropagationNone is used.
             * This field is beta in 1.10.
             * When RecursiveReadOnly is set to IfPossible or to Enabled, MountPropagation must be None or unspecified
             * (which defaults to None).
             */
            mountPropagation?: pulumi.Input<string>;
            /**
             * This must match the Name of a Volume.
             */
            name?: pulumi.Input<string>;
            /**
             * Mounted read-only if true, read-write otherwise (false or unspecified).
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * RecursiveReadOnly specifies whether read-only mounts should be handled
             * recursively.
             *
             * If ReadOnly is false, this field has no meaning and must be unspecified.
             *
             * If ReadOnly is true, and this field is set to Disabled, the mount is not made
             * recursively read-only.  If this field is set to IfPossible, the mount is made
             * recursively read-only, if it is supported by the container runtime.  If this
             * field is set to Enabled, the mount is made recursively read-only if it is
             * supported by the container runtime, otherwise the pod will not be started and
             * an error will be generated to indicate the reason.
             *
             * If this field is set to IfPossible or Enabled, MountPropagation must be set to
             * None (or be unspecified, which defaults to None).
             *
             * If this field is not specified, it is treated as an equivalent of Disabled.
             */
            recursiveReadOnly?: pulumi.Input<string>;
            /**
             * Path within the volume from which the container's volume should be mounted.
             * Defaults to "" (volume's root).
             */
            subPath?: pulumi.Input<string>;
            /**
             * Expanded path within the volume from which the container's volume should be mounted.
             * Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
             * Defaults to "" (volume's root).
             * SubPathExpr and SubPath are mutually exclusive.
             */
            subPathExpr?: pulumi.Input<string>;
        }
        /**
         * Patch defines how to perform the patch operation to deployment
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch {
            /**
             * Type is the type of merge operation to perform
             *
             * By default, StrategicMerge is used as the patch type.
             */
            type?: pulumi.Input<string>;
            /**
             * Object contains the raw configuration for merged object
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * Pod defines the desired specification of pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPod {
            affinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity>;
            /**
             * Annotations are the annotations that should be appended to the pods.
             * By default, no pod annotations are appended.
             */
            annotations?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * ImagePullSecrets is an optional list of references to secrets
             * in the same namespace to use for pulling any of the images used by this PodSpec.
             * If specified, these secrets will be passed to individual puller implementations for them to use.
             * More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets>[]>;
            /**
             * Labels are the additional labels that should be tagged to the pods.
             * By default, no additional pod labels are tagged.
             */
            labels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * NodeSelector is a selector which must be true for the pod to fit on a node.
             * Selector which must match a node's labels for the pod to be scheduled on that node.
             * More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
             */
            nodeSelector?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            securityContext?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext>;
            /**
             * If specified, the pod's tolerations.
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations>[]>;
            /**
             * TopologySpreadConstraints describes how a group of pods ought to spread across topology
             * domains. Scheduler will schedule pods in a way which abides by the constraints.
             * All topologySpreadConstraints are ANDed.
             */
            topologySpreadConstraints?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints>[]>;
            /**
             * Volumes that can be mounted by containers belonging to the pod.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes
             */
            volumes?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes>[]>;
        }
        /**
         * If specified, the pod's scheduling constraints.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinity {
            nodeAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity>;
            podAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity>;
            podAntiAffinity?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity>;
        }
        /**
         * Describes node affinity scheduling rules for the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution>;
        }
        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            preference?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference>;
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * A node selector term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms>[]>;
        }
        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator?: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }
        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution>[]>;
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution>[]>;
        }
        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            podAffinityTerm?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight?: pulumi.Input<number>;
        }
        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            namespaceSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey?: pulumi.Input<string>;
        }
        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodImagePullSecrets {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * SecurityContext holds pod-level security attributes and common container settings.
         * Optional: Defaults to empty.  See type description for default values of each field.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContext {
            appArmorProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile>;
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: pulumi.Input<number>;
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: pulumi.Input<string>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * seLinuxChangePolicy defines how the container's SELinux label is applied to all volumes used by the Pod.
             * It has no effect on nodes that do not support SELinux or to volumes does not support SELinux.
             * Valid values are "MountOption" and "Recursive".
             *
             * "Recursive" means relabeling of all files on all Pod volumes by the container runtime.
             * This may be slow for large volumes, but allows mixing privileged and unprivileged Pods sharing the same volume on the same node.
             *
             * "MountOption" mounts all eligible Pod volumes with `-o context` mount option.
             * This requires all Pods that share the same volume to use the same SELinux label.
             * It is not possible to share the same volume among privileged and unprivileged Pods.
             * Eligible volumes are in-tree FibreChannel and iSCSI volumes, and all CSI volumes
             * whose CSI driver announces SELinux support by setting spec.seLinuxMount: true in their
             * CSIDriver instance. Other volumes are always re-labelled recursively.
             * "MountOption" value is allowed only when SELinuxMount feature gate is enabled.
             *
             * If not specified and SELinuxMount feature gate is enabled, "MountOption" is used.
             * If not specified and SELinuxMount feature gate is disabled, "MountOption" is used for ReadWriteOncePod volumes
             * and "Recursive" for all other volumes.
             *
             * This field affects only Pods that have SELinux label set, either in PodSecurityContext or in SecurityContext of all containers.
             *
             * All Pods that use the same volume should use the same seLinuxChangePolicy, otherwise some pods can get stuck in ContainerCreating state.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxChangePolicy?: pulumi.Input<string>;
            seLinuxOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions>;
            seccompProfile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile>;
            /**
             * A list of groups applied to the first process run in each container, in
             * addition to the container's primary GID and fsGroup (if specified).  If
             * the SupplementalGroupsPolicy feature is enabled, the
             * supplementalGroupsPolicy field determines whether these are in addition
             * to or instead of any group memberships defined in the container image.
             * If unspecified, no additional groups are added, though group memberships
             * defined in the container image may still be used, depending on the
             * supplementalGroupsPolicy field.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Defines how supplemental groups of the first container processes are calculated.
             * Valid values are "Merge" and "Strict". If not specified, "Merge" is used.
             * (Alpha) Using the field requires the SupplementalGroupsPolicy feature gate to be enabled
             * and the container runtime must implement support for this feature.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroupsPolicy?: pulumi.Input<string>;
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls>[]>;
            windowsOptions?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions>;
        }
        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }
        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Sysctl defines a kernel parameter to be set
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextSysctls {
            /**
             * Name of a property to set
             */
            name?: pulumi.Input<string>;
            /**
             * Value of a property to set
             */
            value?: pulumi.Input<string>;
        }
        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }
        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTolerations {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: pulumi.Input<string>;
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: pulumi.Input<string>;
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: pulumi.Input<string>;
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: pulumi.Input<number>;
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraints {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector>;
            /**
             * MatchLabelKeys is a set of pod label keys to select the pods over which
             * spreading will be calculated. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are ANDed with labelSelector
             * to select the group of existing pods over which spreading will be calculated
             * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
             * MatchLabelKeys cannot be set when LabelSelector isn't set.
             * Keys that don't exist in the incoming pod labels will
             * be ignored. A null or empty list means only match against labelSelector.
             *
             * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MaxSkew describes the degree to which pods may be unevenly distributed.
             * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
             * between the number of matching pods in the target topology and the global minimum.
             * The global minimum is the minimum number of matching pods in an eligible domain
             * or zero if the number of eligible domains is less than MinDomains.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 2/2/1:
             * In this case, the global minimum is 1.
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |   P   |
             * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
             * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
             * violate MaxSkew(1).
             * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
             * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
             * to topologies that satisfy it.
             * It's a required field. Default value is 1 and 0 is not allowed.
             */
            maxSkew?: pulumi.Input<number>;
            /**
             * MinDomains indicates a minimum number of eligible domains.
             * When the number of eligible domains with matching topology keys is less than minDomains,
             * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
             * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
             * this value has no effect on scheduling.
             * As a result, when the number of eligible domains is less than minDomains,
             * scheduler won't schedule more than maxSkew Pods to those domains.
             * If value is nil, the constraint behaves as if MinDomains is equal to 1.
             * Valid values are integers greater than 0.
             * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
             *
             * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
             * labelSelector spread as 2/2/2:
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |  P P  |
             * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
             * In this situation, new pod with the same labelSelector cannot be scheduled,
             * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
             * it will violate MaxSkew.
             */
            minDomains?: pulumi.Input<number>;
            /**
             * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
             * when calculating pod topology spread skew. Options are:
             * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
             * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
             *
             * If this value is nil, the behavior is equivalent to the Honor policy.
             */
            nodeAffinityPolicy?: pulumi.Input<string>;
            /**
             * NodeTaintsPolicy indicates how we will treat node taints when calculating
             * pod topology spread skew. Options are:
             * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
             * has a toleration, are included.
             * - Ignore: node taints are ignored. All nodes are included.
             *
             * If this value is nil, the behavior is equivalent to the Ignore policy.
             */
            nodeTaintsPolicy?: pulumi.Input<string>;
            /**
             * TopologyKey is the key of node labels. Nodes that have a label with this key
             * and identical values are considered to be in the same topology.
             * We consider each <key, value> as a "bucket", and try to put balanced number
             * of pods into each bucket.
             * We define a domain as a particular instance of a topology.
             * Also, we define an eligible domain as a domain whose nodes meet the requirements of
             * nodeAffinityPolicy and nodeTaintsPolicy.
             * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
             * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
             * It's a required field.
             */
            topologyKey?: pulumi.Input<string>;
            /**
             * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
             * the spread constraint.
             * - DoNotSchedule (default) tells the scheduler not to schedule it.
             * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
             *   but giving higher precedence to topologies that would help reduce the
             *   skew.
             * A constraint is considered "Unsatisfiable" for an incoming pod
             * if and only if every possible node assignment for that pod would violate
             * "MaxSkew" on some topology.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 3/1/1:
             * | zone1 | zone2 | zone3 |
             * | P P P |   P   |   P   |
             * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
             * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
             * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
             * won't make it *more* imbalanced.
             * It's a required field.
             */
            whenUnsatisfiable?: pulumi.Input<string>;
        }
        /**
         * LabelSelector is used to find matching pods.
         * Pods that match this label selector are counted to determine the number of pods
         * in their corresponding topology domain.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Volume represents a named volume in a pod that may be accessed by any container in the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumes {
            awsElasticBlockStore?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore>;
            azureDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk>;
            azureFile?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile>;
            cephfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs>;
            cinder?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder>;
            configMap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap>;
            csi?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi>;
            downwardAPI?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPI>;
            emptyDir?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir>;
            ephemeral?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral>;
            fc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc>;
            flexVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume>;
            flocker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker>;
            gcePersistentDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk>;
            gitRepo?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo>;
            glusterfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs>;
            hostPath?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath>;
            image?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage>;
            iscsi?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi>;
            /**
             * name of the volume.
             * Must be a DNS_LABEL and unique within the pod.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            nfs?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs>;
            persistentVolumeClaim?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim>;
            photonPersistentDisk?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk>;
            portworxVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume>;
            projected?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected>;
            quobyte?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte>;
            rbd?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd>;
            scaleIO?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIO>;
            secret?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret>;
            storageos?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos>;
            vsphereVolume?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume>;
        }
        /**
         * awsElasticBlockStore represents an AWS Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * Deprecated: AWSElasticBlockStore is deprecated. All operations for the in-tree
         * awsElasticBlockStore type are redirected to the ebs.csi.aws.com CSI driver.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAwsElasticBlockStore {
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            fsType?: pulumi.Input<string>;
            /**
             * partition is the partition in the volume that you want to mount.
             * If omitted, the default is to mount by volume name.
             * Examples: For volume /dev/sda1, you specify the partition as "1".
             * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
             */
            partition?: pulumi.Input<number>;
            /**
             * readOnly value true will force the readOnly setting in VolumeMounts.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
         * Deprecated: AzureDisk is deprecated. All operations for the in-tree azureDisk type
         * are redirected to the disk.csi.azure.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureDisk {
            /**
             * cachingMode is the Host Caching mode: None, Read Only, Read Write.
             */
            cachingMode?: pulumi.Input<string>;
            /**
             * diskName is the Name of the data disk in the blob storage
             */
            diskName?: pulumi.Input<string>;
            /**
             * diskURI is the URI of data disk in the blob storage
             */
            diskURI?: pulumi.Input<string>;
            /**
             * fsType is Filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
             */
            kind?: pulumi.Input<string>;
            /**
             * readOnly Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * azureFile represents an Azure File Service mount on the host and bind mount to the pod.
         * Deprecated: AzureFile is deprecated. All operations for the in-tree azureFile type
         * are redirected to the file.csi.azure.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesAzureFile {
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * secretName is the  name of secret that contains Azure Storage Account Name and Key
             */
            secretName?: pulumi.Input<string>;
            /**
             * shareName is the azure share Name
             */
            shareName?: pulumi.Input<string>;
        }
        /**
         * cephFS represents a Ceph FS mount on the host that shares a pod's lifetime.
         * Deprecated: CephFS is deprecated and the in-tree cephfs type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfs {
            /**
             * monitors is Required: Monitors is a collection of Ceph monitors
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            monitors?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            secretFile?: pulumi.Input<string>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef>;
            /**
             * user is optional: User is the rados user name, default is admin
             * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
             */
            user?: pulumi.Input<string>;
        }
        /**
         * secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
         * More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCephfsSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * cinder represents a cinder volume attached and mounted on kubelets host machine.
         * Deprecated: Cinder is deprecated. All operations for the in-tree cinder type
         * are redirected to the cinder.csi.openstack.org CSI driver.
         * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinder {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef>;
            /**
             * volumeID used to identify the volume in cinder.
             * More info: https://examples.k8s.io/mysql-cinder-pd/README.md
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * secretRef is optional: points to a secret object containing parameters used to connect
         * to OpenStack.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCinderSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * configMap represents a configMap that should populate this volume
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMap {
            /**
             * defaultMode is optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * ConfigMap will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the ConfigMap,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional specify whether the ConfigMap or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesConfigMapItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsi {
            /**
             * driver is the name of the CSI driver that handles this volume.
             * Consult with your admin for the correct name as registered in the cluster.
             */
            driver?: pulumi.Input<string>;
            /**
             * fsType to mount. Ex. "ext4", "xfs", "ntfs".
             * If not provided, the empty value is passed to the associated CSI driver
             * which will determine the default filesystem to apply.
             */
            fsType?: pulumi.Input<string>;
            nodePublishSecretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef>;
            /**
             * readOnly specifies a read-only configuration for the volume.
             * Defaults to false (read/write).
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeAttributes stores driver-specific properties that are passed to the CSI
             * driver. Consult your driver's documentation for supported values.
             */
            volumeAttributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * nodePublishSecretRef is a reference to the secret object containing
         * sensitive information to pass to the CSI driver to complete the CSI
         * NodePublishVolume and NodeUnpublishVolume calls.
         * This field is optional, and  may be empty if no secret is required. If the
         * secret object contains more than one secret, all secret references are passed.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesCsiNodePublishSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * downwardAPI represents downward API about the pod that should populate this volume
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPI {
            /**
             * Optional: mode bits to use on created files by default. Must be a
             * Optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * Items is a list of downward API volume file
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItems>[]>;
        }
        /**
         * DownwardAPIVolumeFile represents information to create the file containing the pod field
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsFieldRef>;
            /**
             * Optional: mode bits used to set permissions on this file, must be an octal value
             * between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
             */
            path?: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsResourceFieldRef>;
        }
        /**
         * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesDownwardAPIItemsResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * emptyDir represents a temporary directory that shares a pod's lifetime.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEmptyDir {
            /**
             * medium represents what type of storage medium should back this directory.
             * The default is "" which means to use the node's default medium.
             * Must be an empty string (default) or Memory.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
             */
            medium?: pulumi.Input<string>;
            /**
             * sizeLimit is the total amount of local storage required for this EmptyDir volume.
             * The size limit is also applicable for memory medium.
             * The maximum usage on memory medium EmptyDir would be the minimum value between
             * the SizeLimit specified here and the sum of memory limits of all containers in a pod.
             * The default is nil which means that the limit is undefined.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
             */
            sizeLimit?: pulumi.Input<number | string>;
        }
        /**
         * ephemeral represents a volume that is handled by a cluster storage driver.
         * The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
         * and deleted when the pod is removed.
         *
         * Use this if:
         * a) the volume is only needed while the pod runs,
         * b) features of normal volumes like restoring from snapshot or capacity
         *    tracking are needed,
         * c) the storage driver is specified through a storage class, and
         * d) the storage driver supports dynamic volume provisioning through
         *    a PersistentVolumeClaim (see EphemeralVolumeSource for more
         *    information on the connection between this volume type
         *    and PersistentVolumeClaim).
         *
         * Use PersistentVolumeClaim or one of the vendor-specific
         * APIs for volumes that persist for longer than the lifecycle
         * of an individual pod.
         *
         * Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
         * be used that way - see the documentation of the driver for
         * more information.
         *
         * A pod can use both types of ephemeral volumes and
         * persistent volumes at the same time.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeral {
            volumeClaimTemplate?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate>;
        }
        /**
         * Will be used to create a stand-alone PVC to provision the volume.
         * The pod in which this EphemeralVolumeSource is embedded will be the
         * owner of the PVC, i.e. the PVC will be deleted together with the
         * pod.  The name of the PVC will be `<pod name>-<volume name>` where
         * `<volume name>` is the name from the `PodSpec.Volumes` array
         * entry. Pod validation will reject the pod if the concatenated name
         * is not valid for a PVC (for example, too long).
         *
         * An existing PVC with that name that is not owned by the pod
         * will *not* be used for the pod to avoid using an unrelated
         * volume by mistake. Starting the pod is then blocked until
         * the unrelated PVC is removed. If such a pre-created PVC is
         * meant to be used by the pod, the PVC has to updated with an
         * owner reference to the pod once the pod exists. Normally
         * this should not be necessary, but it may be useful when
         * manually reconstructing a broken cluster.
         *
         * This field is read-only and no changes will be made by Kubernetes
         * to the PVC after it has been created.
         *
         * Required, must not be nil.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplate {
            /**
             * May contain labels and annotations that will be copied into the PVC
             * when creating it. No other fields are allowed and will be rejected during
             * validation.
             */
            metadata?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec>;
        }
        /**
         * The specification for the PersistentVolumeClaim. The entire content is
         * copied unchanged into the PVC that gets created from this
         * template. The same fields as in a PersistentVolumeClaim
         * are also valid here.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpec {
            /**
             * accessModes contains the desired access modes the volume should have.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
             */
            accessModes?: pulumi.Input<pulumi.Input<string>[]>;
            dataSource?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource>;
            dataSourceRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef>;
            resources?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources>;
            selector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector>;
            /**
             * storageClassName is the name of the StorageClass required by the claim.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
             */
            storageClassName?: pulumi.Input<string>;
            /**
             * volumeAttributesClassName may be used to set the VolumeAttributesClass used by this claim.
             * If specified, the CSI driver will create or update the volume with the attributes defined
             * in the corresponding VolumeAttributesClass. This has a different purpose than storageClassName,
             * it can be changed after the claim is created. An empty string value means that no VolumeAttributesClass
             * will be applied to the claim but it's not allowed to reset this field to empty string once it is set.
             * If unspecified and the PersistentVolumeClaim is unbound, the default VolumeAttributesClass
             * will be set by the persistentvolume controller if it exists.
             * If the resource referred to by volumeAttributesClass does not exist, this PersistentVolumeClaim will be
             * set to a Pending state, as reflected by the modifyVolumeStatus field, until such as a resource
             * exists.
             * More info: https://kubernetes.io/docs/concepts/storage/volume-attributes-classes/
             * (Beta) Using this field requires the VolumeAttributesClass feature gate to be enabled (off by default).
             */
            volumeAttributesClassName?: pulumi.Input<string>;
            /**
             * volumeMode defines what type of volume is required by the claim.
             * Value of Filesystem is implied when not included in claim spec.
             */
            volumeMode?: pulumi.Input<string>;
            /**
             * volumeName is the binding reference to the PersistentVolume backing this claim.
             */
            volumeName?: pulumi.Input<string>;
        }
        /**
         * dataSource field can be used to specify either:
         * * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
         * * An existing PVC (PersistentVolumeClaim)
         * If the provisioner or an external controller can support the specified data source,
         * it will create a new volume based on the contents of the specified data source.
         * When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
         * and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
         * If the namespace is specified, then dataSourceRef will not be copied to dataSource.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSource {
            /**
             * APIGroup is the group for the resource being referenced.
             * If APIGroup is not specified, the specified Kind must be in the core API group.
             * For any other third-party types, APIGroup is required.
             */
            apiGroup?: pulumi.Input<string>;
            /**
             * Kind is the type of resource being referenced
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of resource being referenced
             */
            name?: pulumi.Input<string>;
        }
        /**
         * dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
         * volume is desired. This may be any object from a non-empty API group (non
         * core object) or a PersistentVolumeClaim object.
         * When this field is specified, volume binding will only succeed if the type of
         * the specified object matches some installed volume populator or dynamic
         * provisioner.
         * This field will replace the functionality of the dataSource field and as such
         * if both fields are non-empty, they must have the same value. For backwards
         * compatibility, when namespace isn't specified in dataSourceRef,
         * both fields (dataSource and dataSourceRef) will be set to the same
         * value automatically if one of them is empty and the other is non-empty.
         * When namespace is specified in dataSourceRef,
         * dataSource isn't set to the same value and must be empty.
         * There are three important differences between dataSource and dataSourceRef:
         * * While dataSource only allows two specific types of objects, dataSourceRef
         *   allows any non-core object, as well as PersistentVolumeClaim objects.
         * * While dataSource ignores disallowed values (dropping them), dataSourceRef
         *   preserves all values, and generates an error if a disallowed value is
         *   specified.
         * * While dataSource only allows local objects, dataSourceRef allows objects
         *   in any namespaces.
         * (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
         * (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecDataSourceRef {
            /**
             * APIGroup is the group for the resource being referenced.
             * If APIGroup is not specified, the specified Kind must be in the core API group.
             * For any other third-party types, APIGroup is required.
             */
            apiGroup?: pulumi.Input<string>;
            /**
             * Kind is the type of resource being referenced
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of resource being referenced
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of resource being referenced
             * Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
             * (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * resources represents the minimum resources the volume should have.
         * If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
         * that are lower than previous value but must still be higher than capacity recorded in the
         * status field of the claim.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecResources {
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{
                [key: string]: pulumi.Input<number | string>;
            }>;
        }
        /**
         * selector is a label query over volumes to consider for binding.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesEphemeralVolumeClaimTemplateSpecSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFc {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * lun is Optional: FC target lun number
             */
            lun?: pulumi.Input<number>;
            /**
             * readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * targetWWNs is Optional: FC target worldwide names (WWNs)
             */
            targetWWNs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * wwids Optional: FC volume world wide identifiers (wwids)
             * Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
             */
            wwids?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * flexVolume represents a generic volume resource that is
         * provisioned/attached using an exec based plugin.
         * Deprecated: FlexVolume is deprecated. Consider using a CSIDriver instead.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolume {
            /**
             * driver is the name of the driver to use for this volume.
             */
            driver?: pulumi.Input<string>;
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
             */
            fsType?: pulumi.Input<string>;
            /**
             * options is Optional: this field holds extra command options if any.
             */
            options?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * readOnly is Optional: defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef>;
        }
        /**
         * secretRef is Optional: secretRef is reference to the secret object containing
         * sensitive information to pass to the plugin scripts. This may be
         * empty if no secret object is specified. If the secret object
         * contains more than one secret, all secrets are passed to the plugin
         * scripts.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlexVolumeSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running.
         * Deprecated: Flocker is deprecated and the in-tree flocker type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesFlocker {
            /**
             * datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
             * should be considered as deprecated
             */
            datasetName?: pulumi.Input<string>;
            /**
             * datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
             */
            datasetUUID?: pulumi.Input<string>;
        }
        /**
         * gcePersistentDisk represents a GCE Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * Deprecated: GCEPersistentDisk is deprecated. All operations for the in-tree
         * gcePersistentDisk type are redirected to the pd.csi.storage.gke.io CSI driver.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGcePersistentDisk {
            /**
             * fsType is filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            fsType?: pulumi.Input<string>;
            /**
             * partition is the partition in the volume that you want to mount.
             * If omitted, the default is to mount by volume name.
             * Examples: For volume /dev/sda1, you specify the partition as "1".
             * Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            partition?: pulumi.Input<number>;
            /**
             * pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            pdName?: pulumi.Input<string>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * gitRepo represents a git repository at a particular revision.
         * Deprecated: GitRepo is deprecated. To provision a container with a git repo, mount an
         * EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
         * into the Pod's container.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGitRepo {
            /**
             * directory is the target directory name.
             * Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
             * git repository.  Otherwise, if specified, the volume will contain the git repository in
             * the subdirectory with the given name.
             */
            directory?: pulumi.Input<string>;
            /**
             * repository is the URL
             */
            repository?: pulumi.Input<string>;
            /**
             * revision is the commit hash for the specified revision.
             */
            revision?: pulumi.Input<string>;
        }
        /**
         * glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
         * Deprecated: Glusterfs is deprecated and the in-tree glusterfs type is no longer supported.
         * More info: https://examples.k8s.io/volumes/glusterfs/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesGlusterfs {
            /**
             * endpoints is the endpoint name that details Glusterfs topology.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            endpoints?: pulumi.Input<string>;
            /**
             * path is the Glusterfs volume path.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
             * Defaults to false.
             * More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * hostPath represents a pre-existing file or directory on the host
         * machine that is directly exposed to the container. This is generally
         * used for system agents or other privileged things that are allowed
         * to see the host machine. Most containers will NOT need this.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesHostPath {
            /**
             * path of the directory on the host.
             * If the path is a symlink, it will follow the link to the real path.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
             */
            path?: pulumi.Input<string>;
            /**
             * type for HostPath Volume
             * Defaults to ""
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
             */
            type?: pulumi.Input<string>;
        }
        /**
         * image represents an OCI object (a container image or artifact) pulled and mounted on the kubelet's host machine.
         * The volume is resolved at pod startup depending on which PullPolicy value is provided:
         *
         * - Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
         * - Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
         * - IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
         *
         * The volume gets re-resolved if the pod gets deleted and recreated, which means that new remote content will become available on pod recreation.
         * A failure to resolve or pull the image during pod startup will block containers from starting and may add significant latency. Failures will be retried using normal volume backoff and will be reported on the pod reason and message.
         * The types of objects that may be mounted by this volume are defined by the container runtime implementation on a host machine and at minimum must include all valid types supported by the container image field.
         * The OCI object gets mounted in a single directory (spec.containers[*].volumeMounts.mountPath) by merging the manifest layers in the same way as for container images.
         * The volume will be mounted read-only (ro) and non-executable files (noexec).
         * Sub path mounts for containers are not supported (spec.containers[*].volumeMounts.subpath) before 1.33.
         * The field spec.securityContext.fsGroupChangePolicy has no effect on this volume type.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesImage {
            /**
             * Policy for pulling OCI objects. Possible values are:
             * Always: the kubelet always attempts to pull the reference. Container creation will fail If the pull fails.
             * Never: the kubelet never pulls the reference and only uses a local image or artifact. Container creation will fail if the reference isn't present.
             * IfNotPresent: the kubelet pulls if the reference isn't already present on disk. Container creation will fail if the reference isn't present and the pull fails.
             * Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
             */
            pullPolicy?: pulumi.Input<string>;
            /**
             * Required: Image or artifact reference to be used.
             * Behaves in the same way as pod.spec.containers[*].image.
             * Pull secrets will be assembled in the same way as for the container image by looking up node credentials, SA image pull secrets, and pod spec image pull secrets.
             * More info: https://kubernetes.io/docs/concepts/containers/images
             * This field is optional to allow higher level config management to default or override
             * container images in workload controllers like Deployments and StatefulSets.
             */
            reference?: pulumi.Input<string>;
        }
        /**
         * iscsi represents an ISCSI Disk resource that is attached to a
         * kubelet's host machine and then exposed to the pod.
         * More info: https://examples.k8s.io/volumes/iscsi/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsi {
            /**
             * chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
             */
            chapAuthDiscovery?: pulumi.Input<boolean>;
            /**
             * chapAuthSession defines whether support iSCSI Session CHAP authentication
             */
            chapAuthSession?: pulumi.Input<boolean>;
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
             */
            fsType?: pulumi.Input<string>;
            /**
             * initiatorName is the custom iSCSI Initiator Name.
             * If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
             * <target portal>:<volume name> will be created for the connection.
             */
            initiatorName?: pulumi.Input<string>;
            /**
             * iqn is the target iSCSI Qualified Name.
             */
            iqn?: pulumi.Input<string>;
            /**
             * iscsiInterface is the interface Name that uses an iSCSI transport.
             * Defaults to 'default' (tcp).
             */
            iscsiInterface?: pulumi.Input<string>;
            /**
             * lun represents iSCSI Target Lun number.
             */
            lun?: pulumi.Input<number>;
            /**
             * portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
             * is other than default (typically TCP ports 860 and 3260).
             */
            portals?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef>;
            /**
             * targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
             * is other than default (typically TCP ports 860 and 3260).
             */
            targetPortal?: pulumi.Input<string>;
        }
        /**
         * secretRef is the CHAP Secret for iSCSI target and initiator authentication
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesIscsiSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * nfs represents an NFS mount on the host that shares a pod's lifetime
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesNfs {
            /**
             * path that is exported by the NFS server.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            path?: pulumi.Input<string>;
            /**
             * readOnly here will force the NFS export to be mounted with read-only permissions.
             * Defaults to false.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * server is the hostname or IP address of the NFS server.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
             */
            server?: pulumi.Input<string>;
        }
        /**
         * persistentVolumeClaimVolumeSource represents a reference to a
         * PersistentVolumeClaim in the same namespace.
         * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPersistentVolumeClaim {
            /**
             * claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
             * More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
             */
            claimName?: pulumi.Input<string>;
            /**
             * readOnly Will force the ReadOnly setting in VolumeMounts.
             * Default false.
             */
            readOnly?: pulumi.Input<boolean>;
        }
        /**
         * photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine.
         * Deprecated: PhotonPersistentDisk is deprecated and the in-tree photonPersistentDisk type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPhotonPersistentDisk {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * pdID is the ID that identifies Photon Controller persistent disk
             */
            pdID?: pulumi.Input<string>;
        }
        /**
         * portworxVolume represents a portworx volume attached and mounted on kubelets host machine.
         * Deprecated: PortworxVolume is deprecated. All operations for the in-tree portworxVolume type
         * are redirected to the pxd.portworx.com CSI driver when the CSIMigrationPortworx feature-gate
         * is on.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesPortworxVolume {
            /**
             * fSType represents the filesystem type to mount
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * volumeID uniquely identifies a Portworx volume
             */
            volumeID?: pulumi.Input<string>;
        }
        /**
         * projected items for all in one resources secrets, configmaps, and downward API
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjected {
            /**
             * defaultMode are the mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * sources is the list of volume projections. Each entry in this list
             * handles one source.
             */
            sources?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources>[]>;
        }
        /**
         * Projection that may be projected along with other supported volume types.
         * Exactly one of these fields must be set.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSources {
            clusterTrustBundle?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle>;
            configMap?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap>;
            downwardAPI?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPI>;
            secret?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret>;
            serviceAccountToken?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken>;
        }
        /**
         * ClusterTrustBundle allows a pod to access the `.spec.trustBundle` field
         * of ClusterTrustBundle objects in an auto-updating file.
         *
         * Alpha, gated by the ClusterTrustBundleProjection feature gate.
         *
         * ClusterTrustBundle objects can either be selected by name, or by the
         * combination of signer name and a label selector.
         *
         * Kubelet performs aggressive normalization of the PEM contents written
         * into the pod filesystem.  Esoteric PEM features such as inter-block
         * comments and block headers are stripped.  Certificates are deduplicated.
         * The ordering of certificates within the file is arbitrary, and Kubelet
         * may change the order over time.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundle {
            labelSelector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector>;
            /**
             * Select a single ClusterTrustBundle by object name.  Mutually-exclusive
             * with signerName and labelSelector.
             */
            name?: pulumi.Input<string>;
            /**
             * If true, don't block pod startup if the referenced ClusterTrustBundle(s)
             * aren't available.  If using name, then the named ClusterTrustBundle is
             * allowed not to exist.  If using signerName, then the combination of
             * signerName and labelSelector is allowed to match zero
             * ClusterTrustBundles.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * Relative path from the volume root to write the bundle.
             */
            path?: pulumi.Input<string>;
            /**
             * Select all ClusterTrustBundles that match this signer name.
             * Mutually-exclusive with name.  The contents of all selected
             * ClusterTrustBundles will be unified and deduplicated.
             */
            signerName?: pulumi.Input<string>;
        }
        /**
         * Select all ClusterTrustBundles that match this label selector.  Only has
         * effect if signerName is set.  Mutually-exclusive with name.  If unset,
         * interpreted as "match nothing".  If set but empty, interpreted as "match
         * everything".
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesClusterTrustBundleLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * configMap information about the configMap data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMap {
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * ConfigMap will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the ConfigMap,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional specify whether the ConfigMap or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesConfigMapItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * downwardAPI information about the downwardAPI data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPI {
            /**
             * Items is a list of DownwardAPIVolume file
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItems>[]>;
        }
        /**
         * DownwardAPIVolumeFile represents information to create the file containing the pod field
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItems {
            fieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsFieldRef>;
            /**
             * Optional: mode bits used to set permissions on this file, must be an octal value
             * between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
             */
            path?: pulumi.Input<string>;
            resourceFieldRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef>;
        }
        /**
         * Required: Selects a field of the pod: only annotations, labels, name, namespace and uid are supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsFieldRef {
            /**
             * Version of the schema the FieldPath is written in terms of, defaults to "v1".
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * Path of the field to select in the specified API version.
             */
            fieldPath?: pulumi.Input<string>;
        }
        /**
         * Selects a resource of the container: only resources limits and requests
         * (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesDownwardAPIItemsResourceFieldRef {
            /**
             * Container name: required for volumes, optional for env vars
             */
            containerName?: pulumi.Input<string>;
            /**
             * Specifies the output format of the exposed resources, defaults to "1"
             */
            divisor?: pulumi.Input<number | string>;
            /**
             * Required: resource to select
             */
            resource?: pulumi.Input<string>;
        }
        /**
         * secret information about the secret data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecret {
            /**
             * items if unspecified, each key-value pair in the Data field of the referenced
             * Secret will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the Secret,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems>[]>;
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
            /**
             * optional field specify whether the Secret or its key must be defined
             */
            optional?: pulumi.Input<boolean>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesSecretItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * serviceAccountToken is information about the serviceAccountToken data to project
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesProjectedSourcesServiceAccountToken {
            /**
             * audience is the intended audience of the token. A recipient of a token
             * must identify itself with an identifier specified in the audience of the
             * token, and otherwise should reject the token. The audience defaults to the
             * identifier of the apiserver.
             */
            audience?: pulumi.Input<string>;
            /**
             * expirationSeconds is the requested duration of validity of the service
             * account token. As the token approaches expiration, the kubelet volume
             * plugin will proactively rotate the service account token. The kubelet will
             * start trying to rotate the token if the token is older than 80 percent of
             * its time to live or if the token is older than 24 hours.Defaults to 1 hour
             * and must be at least 10 minutes.
             */
            expirationSeconds?: pulumi.Input<number>;
            /**
             * path is the path relative to the mount point of the file to project the
             * token into.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * quobyte represents a Quobyte mount on the host that shares a pod's lifetime.
         * Deprecated: Quobyte is deprecated and the in-tree quobyte type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesQuobyte {
            /**
             * group to map volume access to
             * Default is no group
             */
            group?: pulumi.Input<string>;
            /**
             * readOnly here will force the Quobyte volume to be mounted with read-only permissions.
             * Defaults to false.
             */
            readOnly?: pulumi.Input<boolean>;
            /**
             * registry represents a single or multiple Quobyte Registry services
             * specified as a string as host:port pair (multiple entries are separated with commas)
             * which acts as the central registry for volumes
             */
            registry?: pulumi.Input<string>;
            /**
             * tenant owning the given Quobyte volume in the Backend
             * Used with dynamically provisioned Quobyte volumes, value is set by the plugin
             */
            tenant?: pulumi.Input<string>;
            /**
             * user to map volume access to
             * Defaults to serivceaccount user
             */
            user?: pulumi.Input<string>;
            /**
             * volume is a string that references an already created Quobyte volume by name.
             */
            volume?: pulumi.Input<string>;
        }
        /**
         * rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
         * Deprecated: RBD is deprecated and the in-tree rbd type is no longer supported.
         * More info: https://examples.k8s.io/volumes/rbd/README.md
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbd {
            /**
             * fsType is the filesystem type of the volume that you want to mount.
             * Tip: Ensure that the filesystem type is supported by the host operating system.
             * Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
             */
            fsType?: pulumi.Input<string>;
            /**
             * image is the rados image name.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            image?: pulumi.Input<string>;
            /**
             * keyring is the path to key ring for RBDUser.
             * Default is /etc/ceph/keyring.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            keyring?: pulumi.Input<string>;
            /**
             * monitors is a collection of Ceph monitors.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            monitors?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * pool is the rados pool name.
             * Default is rbd.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            pool?: pulumi.Input<string>;
            /**
             * readOnly here will force the ReadOnly setting in VolumeMounts.
             * Defaults to false.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef>;
            /**
             * user is the rados user name.
             * Default is admin.
             * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
             */
            user?: pulumi.Input<string>;
        }
        /**
         * secretRef is name of the authentication secret for RBDUser. If provided
         * overrides keyring.
         * Default is nil.
         * More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesRbdSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
         * Deprecated: ScaleIO is deprecated and the in-tree scaleIO type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIO {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs".
             * Default is "xfs".
             */
            fsType?: pulumi.Input<string>;
            /**
             * gateway is the host address of the ScaleIO API Gateway.
             */
            gateway?: pulumi.Input<string>;
            /**
             * protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
             */
            protectionDomain?: pulumi.Input<string>;
            /**
             * readOnly Defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIOSecretRef>;
            /**
             * sslEnabled Flag enable/disable SSL communication with Gateway, default false
             */
            sslEnabled?: pulumi.Input<boolean>;
            /**
             * storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
             * Default is ThinProvisioned.
             */
            storageMode?: pulumi.Input<string>;
            /**
             * storagePool is the ScaleIO Storage Pool associated with the protection domain.
             */
            storagePool?: pulumi.Input<string>;
            /**
             * system is the name of the storage system as configured in ScaleIO.
             */
            system?: pulumi.Input<string>;
            /**
             * volumeName is the name of a volume already created in the ScaleIO system
             * that is associated with this volume source.
             */
            volumeName?: pulumi.Input<string>;
        }
        /**
         * secretRef references to the secret for ScaleIO user and other
         * sensitive information. If this is not provided, Login operation will fail.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesScaleIOSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * secret represents a secret that should populate this volume.
         * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecret {
            /**
             * defaultMode is Optional: mode bits used to set permissions on created files by default.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values
             * for mode bits. Defaults to 0644.
             * Directories within the path are not affected by this setting.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            defaultMode?: pulumi.Input<number>;
            /**
             * items If unspecified, each key-value pair in the Data field of the referenced
             * Secret will be projected into the volume as a file whose name is the
             * key and content is the value. If specified, the listed keys will be
             * projected into the specified paths, and unlisted keys will not be
             * present. If a key is specified which is not present in the Secret,
             * the volume setup will error unless it is marked optional. Paths must be
             * relative and may not contain the '..' path or start with '..'.
             */
            items?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems>[]>;
            /**
             * optional field specify whether the Secret or its keys must be defined
             */
            optional?: pulumi.Input<boolean>;
            /**
             * secretName is the name of the secret in the pod's namespace to use.
             * More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
             */
            secretName?: pulumi.Input<string>;
        }
        /**
         * Maps a string key to a path within a volume.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesSecretItems {
            /**
             * key is the key to project.
             */
            key?: pulumi.Input<string>;
            /**
             * mode is Optional: mode bits used to set permissions on this file.
             * Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
             * YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
             * If not specified, the volume defaultMode will be used.
             * This might be in conflict with other options that affect the file
             * mode, like fsGroup, and the result can be other mode bits set.
             */
            mode?: pulumi.Input<number>;
            /**
             * path is the relative path of the file to map the key to.
             * May not be an absolute path.
             * May not contain the path element '..'.
             * May not start with the string '..'.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
         * Deprecated: StorageOS is deprecated and the in-tree storageos type is no longer supported.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageos {
            /**
             * fsType is the filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * readOnly defaults to false (read/write). ReadOnly here will force
             * the ReadOnly setting in VolumeMounts.
             */
            readOnly?: pulumi.Input<boolean>;
            secretRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef>;
            /**
             * volumeName is the human-readable name of the StorageOS volume.  Volume
             * names are only unique within a namespace.
             */
            volumeName?: pulumi.Input<string>;
            /**
             * volumeNamespace specifies the scope of the volume within StorageOS.  If no
             * namespace is specified then the Pod's namespace will be used.  This allows the
             * Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
             * Set VolumeName to any name to override the default behaviour.
             * Set to "default" if you are not using namespaces within StorageOS.
             * Namespaces that do not pre-exist within StorageOS will be created.
             */
            volumeNamespace?: pulumi.Input<string>;
        }
        /**
         * secretRef specifies the secret to use for obtaining the StorageOS API
         * credentials.  If not specified, default values will be attempted.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesStorageosSecretRef {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine.
         * Deprecated: VsphereVolume is deprecated. All operations for the in-tree vsphereVolume type
         * are redirected to the csi.vsphere.vmware.com CSI driver.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentPodVolumesVsphereVolume {
            /**
             * fsType is filesystem type to mount.
             * Must be a filesystem type supported by the host operating system.
             * Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
             */
            fsType?: pulumi.Input<string>;
            /**
             * storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
             */
            storagePolicyID?: pulumi.Input<string>;
            /**
             * storagePolicyName is the storage Policy Based Management (SPBM) profile name.
             */
            storagePolicyName?: pulumi.Input<string>;
            /**
             * volumePath is the path that identifies vSphere volume vmdk
             */
            volumePath?: pulumi.Input<string>;
        }
        /**
         * The deployment strategy to use to replace existing pods with new ones.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategy {
            rollingUpdate?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate>;
            /**
             * Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Rolling update config params. Present only if DeploymentStrategyType =
         * RollingUpdate.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyDeploymentStrategyRollingUpdate {
            /**
             * The maximum number of pods that can be scheduled above the desired number of
             * pods.
             * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
             * This can not be 0 if MaxUnavailable is 0.
             * Absolute number is calculated from percentage by rounding up.
             * Defaults to 25%.
             * Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
             * the rolling update starts, such that the total number of old and new pods do not exceed
             * 130% of desired pods. Once old pods have been killed,
             * new ReplicaSet can be scaled up further, ensuring that total number of pods running
             * at any time during the update is at most 130% of desired pods.
             */
            maxSurge?: pulumi.Input<number | string>;
            /**
             * The maximum number of pods that can be unavailable during the update.
             * Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
             * Absolute number is calculated from percentage by rounding down.
             * This can not be 0 if MaxSurge is 0.
             * Defaults to 25%.
             * Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
             * immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
             * can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
             * that the total number of pods available at all times during the update is at
             * least 70% of desired pods.
             */
            maxUnavailable?: pulumi.Input<number | string>;
        }
        /**
         * EnvoyHpa defines the Horizontal Pod Autoscaler settings for Envoy Proxy Deployment.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpa {
            behavior?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior>;
            /**
             * maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up.
             * It cannot be less that minReplicas.
             */
            maxReplicas?: pulumi.Input<number>;
            /**
             * metrics contains the specifications for which to use to calculate the
             * desired replica count (the maximum replica count across all metrics will
             * be used).
             * If left empty, it defaults to being based on CPU utilization with average on 80% usage.
             */
            metrics?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics>[]>;
            /**
             * minReplicas is the lower limit for the number of replicas to which the autoscaler
             * can scale down. It defaults to 1 replica.
             */
            minReplicas?: pulumi.Input<number>;
            /**
             * Name of the horizontalPodAutoScaler.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
            patch?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaPatch>;
        }
        /**
         * behavior configures the scaling behavior of the target
         * in both Up and Down directions (scaleUp and scaleDown fields respectively).
         * If not set, the default HPAScalingRules for scale up and scale down are used.
         * See k8s.io.autoscaling.v2.HorizontalPodAutoScalerBehavior.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehavior {
            scaleDown?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown>;
            scaleUp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp>;
        }
        /**
         * scaleDown is scaling policy for scaling Down.
         * If not set, the default value is to allow to scale down to minReplicas pods, with a
         * 300 second stabilization window (i.e., the highest recommendation for
         * the last 300sec is used).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDown {
            /**
             * policies is a list of potential scaling polices which can be used during scaling.
             * If not set, use the default values:
             * - For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.
             * - For scale down: allow all pods to be removed in a 15s window.
             */
            policies?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies>[]>;
            /**
             * selectPolicy is used to specify which policy should be used.
             * If not set, the default value Max is used.
             */
            selectPolicy?: pulumi.Input<string>;
            /**
             * stabilizationWindowSeconds is the number of seconds for which past recommendations should be
             * considered while scaling up or scaling down.
             * StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
             * If not set, use the default values:
             * - For scale up: 0 (i.e. no stabilization is done).
             * - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
             */
            stabilizationWindowSeconds?: pulumi.Input<number>;
            /**
             * tolerance is the tolerance on the ratio between the current and desired
             * metric value under which no updates are made to the desired number of
             * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
             * set, the default cluster-wide tolerance is applied (by default 10%).
             *
             * For example, if autoscaling is configured with a memory consumption target of 100Mi,
             * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
             * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
             *
             * This is an alpha field and requires enabling the HPAConfigurableTolerance
             * feature gate.
             */
            tolerance?: pulumi.Input<number | string>;
        }
        /**
         * HPAScalingPolicy is a single policy which must hold true for a specified past interval.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleDownPolicies {
            /**
             * periodSeconds specifies the window of time for which the policy should hold true.
             * PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * type is used to specify the scaling policy.
             */
            type?: pulumi.Input<string>;
            /**
             * value contains the amount of change which is permitted by the policy.
             * It must be greater than zero
             */
            value?: pulumi.Input<number>;
        }
        /**
         * scaleUp is scaling policy for scaling Up.
         * If not set, the default value is the higher of:
         *   * increase no more than 4 pods per 60 seconds
         *   * double the number of pods per 60 seconds
         * No stabilization is used.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUp {
            /**
             * policies is a list of potential scaling polices which can be used during scaling.
             * If not set, use the default values:
             * - For scale up: allow doubling the number of pods, or an absolute change of 4 pods in a 15s window.
             * - For scale down: allow all pods to be removed in a 15s window.
             */
            policies?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies>[]>;
            /**
             * selectPolicy is used to specify which policy should be used.
             * If not set, the default value Max is used.
             */
            selectPolicy?: pulumi.Input<string>;
            /**
             * stabilizationWindowSeconds is the number of seconds for which past recommendations should be
             * considered while scaling up or scaling down.
             * StabilizationWindowSeconds must be greater than or equal to zero and less than or equal to 3600 (one hour).
             * If not set, use the default values:
             * - For scale up: 0 (i.e. no stabilization is done).
             * - For scale down: 300 (i.e. the stabilization window is 300 seconds long).
             */
            stabilizationWindowSeconds?: pulumi.Input<number>;
            /**
             * tolerance is the tolerance on the ratio between the current and desired
             * metric value under which no updates are made to the desired number of
             * replicas (e.g. 0.01 for 1%). Must be greater than or equal to zero. If not
             * set, the default cluster-wide tolerance is applied (by default 10%).
             *
             * For example, if autoscaling is configured with a memory consumption target of 100Mi,
             * and scale-down and scale-up tolerances of 5% and 1% respectively, scaling will be
             * triggered when the actual consumption falls below 95Mi or exceeds 101Mi.
             *
             * This is an alpha field and requires enabling the HPAConfigurableTolerance
             * feature gate.
             */
            tolerance?: pulumi.Input<number | string>;
        }
        /**
         * HPAScalingPolicy is a single policy which must hold true for a specified past interval.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaBehaviorScaleUpPolicies {
            /**
             * periodSeconds specifies the window of time for which the policy should hold true.
             * PeriodSeconds must be greater than zero and less than or equal to 1800 (30 min).
             */
            periodSeconds?: pulumi.Input<number>;
            /**
             * type is used to specify the scaling policy.
             */
            type?: pulumi.Input<string>;
            /**
             * value contains the amount of change which is permitted by the policy.
             * It must be greater than zero
             */
            value?: pulumi.Input<number>;
        }
        /**
         * MetricSpec specifies how to scale based on a single metric
         * (only `type` and one other matching field should be set at once).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetrics {
            containerResource?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource>;
            external?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal>;
            object?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject>;
            pods?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods>;
            resource?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource>;
            /**
             * type is the type of metric source.  It should be one of "ContainerResource", "External",
             * "Object", "Pods" or "Resource", each mapping to a matching field in the object.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * containerResource refers to a resource metric (such as those specified in
         * requests and limits) known to Kubernetes describing a single container in
         * each pod of the current scale target (e.g. CPU or memory). Such metrics are
         * built in to Kubernetes, and have special scaling options on top of those
         * available to normal per-pod metrics using the "pods" source.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResource {
            /**
             * container is the name of the container in the pods of the scaling target
             */
            container?: pulumi.Input<string>;
            /**
             * name is the name of the resource in question.
             */
            name?: pulumi.Input<string>;
            target?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget>;
        }
        /**
         * target specifies the target value for the given metric
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsContainerResourceTarget {
            /**
             * averageUtilization is the target value of the average of the
             * resource metric across all relevant pods, represented as a percentage of
             * the requested value of the resource for the pods.
             * Currently only valid for Resource metric source type
             */
            averageUtilization?: pulumi.Input<number>;
            /**
             * averageValue is the target value of the average of the
             * metric across all relevant pods (as a quantity)
             */
            averageValue?: pulumi.Input<number | string>;
            /**
             * type represents whether the metric type is Utilization, Value, or AverageValue
             */
            type?: pulumi.Input<string>;
            /**
             * value is the target value of the metric (as a quantity).
             */
            value?: pulumi.Input<number | string>;
        }
        /**
         * external refers to a global metric that is not associated
         * with any Kubernetes object. It allows autoscaling based on information
         * coming from components running outside of cluster
         * (for example length of queue in cloud messaging service, or
         * QPS from loadbalancer running outside of cluster).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternal {
            metric?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric>;
            target?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget>;
        }
        /**
         * metric identifies the target metric by name and selector
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetric {
            /**
             * name is the name of the given metric
             */
            name?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector>;
        }
        /**
         * selector is the string-encoded form of a standard kubernetes label selector for the given metric
         * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
         * When unset, just the metricName will be used to gather metrics.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalMetricSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * target specifies the target value for the given metric
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsExternalTarget {
            /**
             * averageUtilization is the target value of the average of the
             * resource metric across all relevant pods, represented as a percentage of
             * the requested value of the resource for the pods.
             * Currently only valid for Resource metric source type
             */
            averageUtilization?: pulumi.Input<number>;
            /**
             * averageValue is the target value of the average of the
             * metric across all relevant pods (as a quantity)
             */
            averageValue?: pulumi.Input<number | string>;
            /**
             * type represents whether the metric type is Utilization, Value, or AverageValue
             */
            type?: pulumi.Input<string>;
            /**
             * value is the target value of the metric (as a quantity).
             */
            value?: pulumi.Input<number | string>;
        }
        /**
         * object refers to a metric describing a single kubernetes object
         * (for example, hits-per-second on an Ingress object).
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObject {
            describedObject?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject>;
            metric?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric>;
            target?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget>;
        }
        /**
         * describedObject specifies the descriptions of a object,such as kind,name apiVersion
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectDescribedObject {
            /**
             * apiVersion is the API version of the referent
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * kind is the kind of the referent; More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * name is the name of the referent; More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * metric identifies the target metric by name and selector
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetric {
            /**
             * name is the name of the given metric
             */
            name?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector>;
        }
        /**
         * selector is the string-encoded form of a standard kubernetes label selector for the given metric
         * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
         * When unset, just the metricName will be used to gather metrics.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectMetricSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * target specifies the target value for the given metric
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsObjectTarget {
            /**
             * averageUtilization is the target value of the average of the
             * resource metric across all relevant pods, represented as a percentage of
             * the requested value of the resource for the pods.
             * Currently only valid for Resource metric source type
             */
            averageUtilization?: pulumi.Input<number>;
            /**
             * averageValue is the target value of the average of the
             * metric across all relevant pods (as a quantity)
             */
            averageValue?: pulumi.Input<number | string>;
            /**
             * type represents whether the metric type is Utilization, Value, or AverageValue
             */
            type?: pulumi.Input<string>;
            /**
             * value is the target value of the metric (as a quantity).
             */
            value?: pulumi.Input<number | string>;
        }
        /**
         * pods refers to a metric describing each pod in the current scale target
         * (for example, transactions-processed-per-second).  The values will be
         * averaged together before being compared to the target value.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPods {
            metric?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric>;
            target?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget>;
        }
        /**
         * metric identifies the target metric by name and selector
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetric {
            /**
             * name is the name of the given metric
             */
            name?: pulumi.Input<string>;
            selector?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector>;
        }
        /**
         * selector is the string-encoded form of a standard kubernetes label selector for the given metric
         * When set, it is passed as an additional parameter to the metrics server for more specific metrics scoping.
         * When unset, just the metricName will be used to gather metrics.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsMetricSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * target specifies the target value for the given metric
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsPodsTarget {
            /**
             * averageUtilization is the target value of the average of the
             * resource metric across all relevant pods, represented as a percentage of
             * the requested value of the resource for the pods.
             * Currently only valid for Resource metric source type
             */
            averageUtilization?: pulumi.Input<number>;
            /**
             * averageValue is the target value of the average of the
             * metric across all relevant pods (as a quantity)
             */
            averageValue?: pulumi.Input<number | string>;
            /**
             * type represents whether the metric type is Utilization, Value, or AverageValue
             */
            type?: pulumi.Input<string>;
            /**
             * value is the target value of the metric (as a quantity).
             */
            value?: pulumi.Input<number | string>;
        }
        /**
         * resource refers to a resource metric (such as those specified in
         * requests and limits) known to Kubernetes describing each pod in the
         * current scale target (e.g. CPU or memory). Such metrics are built in to
         * Kubernetes, and have special scaling options on top of those available
         * to normal per-pod metrics using the "pods" source.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResource {
            /**
             * name is the name of the resource in question.
             */
            name?: pulumi.Input<string>;
            target?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget>;
        }
        /**
         * target specifies the target value for the given metric
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaMetricsResourceTarget {
            /**
             * averageUtilization is the target value of the average of the
             * resource metric across all relevant pods, represented as a percentage of
             * the requested value of the resource for the pods.
             * Currently only valid for Resource metric source type
             */
            averageUtilization?: pulumi.Input<number>;
            /**
             * averageValue is the target value of the average of the
             * metric across all relevant pods (as a quantity)
             */
            averageValue?: pulumi.Input<number | string>;
            /**
             * type represents whether the metric type is Utilization, Value, or AverageValue
             */
            type?: pulumi.Input<string>;
            /**
             * value is the target value of the metric (as a quantity).
             */
            value?: pulumi.Input<number | string>;
        }
        /**
         * Patch defines how to perform the patch operation to the HorizontalPodAutoscaler
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyHpaPatch {
            /**
             * Type is the type of merge operation to perform
             *
             * By default, StrategicMerge is used as the patch type.
             */
            type?: pulumi.Input<string>;
            /**
             * Object contains the raw configuration for merged object
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * EnvoyPDB allows to control the pod disruption budget of an Envoy Proxy.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyPDB {
            /**
             * MaxUnavailable specifies the maximum amount of pods (can be expressed as integers or as a percentage) that can be unavailable at all times during voluntary disruptions,
             * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
             * and resilience during maintenance operations. Cannot be combined with minAvailable.
             */
            maxUnavailable?: pulumi.Input<number | string>;
            /**
             * MinAvailable specifies the minimum amount of pods (can be expressed as integers or as a percentage) that must be available at all times during voluntary disruptions,
             * such as node drains or updates. This setting ensures that your envoy proxy maintains a certain level of availability
             * and resilience during maintenance operations. Cannot be combined with maxUnavailable.
             */
            minAvailable?: pulumi.Input<number | string>;
            /**
             * Name of the podDisruptionBudget.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
            patch?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDBPatch>;
        }
        /**
         * Patch defines how to perform the patch operation to the PodDisruptionBudget
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyPDBPatch {
            /**
             * Type is the type of merge operation to perform
             *
             * By default, StrategicMerge is used as the patch type.
             */
            type?: pulumi.Input<string>;
            /**
             * Object contains the raw configuration for merged object
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * EnvoyService defines the desired state of the Envoy service resource.
         * If unspecified, default settings for the managed Envoy service resource
         * are applied.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyService {
            /**
             * AllocateLoadBalancerNodePorts defines if NodePorts will be automatically allocated for
             * services with type LoadBalancer. Default is "true". It may be set to "false" if the cluster
             * load-balancer does not rely on NodePorts. If the caller requests specific NodePorts (by specifying a
             * value), those requests will be respected, regardless of this field. This field may only be set for
             * services with type LoadBalancer and will be cleared if the type is changed to any other type.
             */
            allocateLoadBalancerNodePorts?: pulumi.Input<boolean>;
            /**
             * Annotations that should be appended to the service.
             * By default, no annotations are appended.
             */
            annotations?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * ExternalTrafficPolicy determines the externalTrafficPolicy for the Envoy Service. Valid options
             * are Local and Cluster. Default is "Local". "Local" means traffic will only go to pods on the node
             * receiving the traffic. "Cluster" means connections are loadbalanced to all pods in the cluster.
             */
            externalTrafficPolicy?: pulumi.Input<string>;
            /**
             * Labels that should be appended to the service.
             * By default, no labels are appended.
             */
            labels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * LoadBalancerClass, when specified, allows for choosing the LoadBalancer provider
             * implementation if more than one are available or is otherwise expected to be specified
             */
            loadBalancerClass?: pulumi.Input<string>;
            /**
             * LoadBalancerIP defines the IP Address of the underlying load balancer service. This field
             * may be ignored if the load balancer provider does not support this feature.
             * This field has been deprecated in Kubernetes, but it is still used for setting the IP Address in some cloud
             * providers such as GCP.
             */
            loadBalancerIP?: pulumi.Input<string>;
            /**
             * LoadBalancerSourceRanges defines a list of allowed IP addresses which will be configured as
             * firewall rules on the platform providers load balancer. This is not guaranteed to be working as
             * it happens outside of kubernetes and has to be supported and handled by the platform provider.
             * This field may only be set for services with type LoadBalancer and will be cleared if the type
             * is changed to any other type.
             */
            loadBalancerSourceRanges?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Name of the service.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
            patch?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServicePatch>;
            /**
             * Type determines how the Service is exposed. Defaults to LoadBalancer.
             * Valid options are ClusterIP, LoadBalancer and NodePort.
             * "LoadBalancer" means a service will be exposed via an external load balancer (if the cloud provider supports it).
             * "ClusterIP" means a service will only be accessible inside the cluster, via the cluster IP.
             * "NodePort" means a service will be exposed on a static Port on all Nodes of the cluster.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EnvoyServiceAccount defines the desired state of the Envoy service account resource.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyServiceAccount {
            /**
             * Name of the Service Account.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * EnvoyServiceAccount defines the desired state of the Envoy service account resource.
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyServiceAccountPatch {
            /**
             * Name of the Service Account.
             * When unset, this defaults to an autogenerated name.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Patch defines how to perform the patch operation to the service
         */
        interface EnvoyProxySpecProviderKubernetesEnvoyServicePatch {
            /**
             * Type is the type of merge operation to perform
             *
             * By default, StrategicMerge is used as the patch type.
             */
            type?: pulumi.Input<string>;
            /**
             * Object contains the raw configuration for merged object
             */
            value?: pulumi.Input<{
                [key: string]: any;
            }>;
        }
        /**
         * Kubernetes defines the desired state of the Kubernetes resource provider.
         * Kubernetes provides infrastructure resources for running the data plane,
         * e.g. Envoy proxy. If unspecified and type is "Kubernetes", default settings
         * for managed Kubernetes resources are applied.
         */
        interface EnvoyProxySpecProviderKubernetesPatch {
            envoyDaemonSet?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDaemonSetPatch>;
            envoyDeployment?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyDeploymentPatch>;
            envoyHpa?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyHpaPatch>;
            envoyPDB?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyPDBPatch>;
            envoyService?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServicePatch>;
            envoyServiceAccount?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesEnvoyServiceAccountPatch>;
            /**
             * UseListenerPortAsContainerPort disables the port shifting feature in the Envoy Proxy.
             * When set to false (default value), if the service port is a privileged port (1-1023), add a constant to the value converting it into an ephemeral port.
             * This allows the container to bind to the port without needing a CAP_NET_BIND_SERVICE capability.
             */
            useListenerPortAsContainerPort?: pulumi.Input<boolean>;
        }
        /**
         * Provider defines the desired resource provider and provider-specific configuration.
         * If unspecified, the "Kubernetes" resource provider is used with default configuration
         * parameters.
         */
        interface EnvoyProxySpecProviderPatch {
            kubernetes?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecProviderKubernetesPatch>;
            /**
             * Type is the type of resource provider to use. A resource provider provides
             * infrastructure resources for running the data plane, e.g. Envoy proxy, and
             * optional auxiliary control planes. Supported types are "Kubernetes".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Shutdown defines configuration for graceful envoy shutdown process.
         */
        interface EnvoyProxySpecShutdown {
            /**
             * DrainTimeout defines the graceful drain timeout. This should be less than the pod's terminationGracePeriodSeconds.
             * If unspecified, defaults to 60 seconds.
             */
            drainTimeout?: pulumi.Input<string>;
            /**
             * MinDrainDuration defines the minimum drain duration allowing time for endpoint deprogramming to complete.
             * If unspecified, defaults to 10 seconds.
             */
            minDrainDuration?: pulumi.Input<string>;
        }
        /**
         * Shutdown defines configuration for graceful envoy shutdown process.
         */
        interface EnvoyProxySpecShutdownPatch {
            /**
             * DrainTimeout defines the graceful drain timeout. This should be less than the pod's terminationGracePeriodSeconds.
             * If unspecified, defaults to 60 seconds.
             */
            drainTimeout?: pulumi.Input<string>;
            /**
             * MinDrainDuration defines the minimum drain duration allowing time for endpoint deprogramming to complete.
             * If unspecified, defaults to 10 seconds.
             */
            minDrainDuration?: pulumi.Input<string>;
        }
        /**
         * Telemetry defines telemetry parameters for managed proxies.
         */
        interface EnvoyProxySpecTelemetry {
            accessLog?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLog>;
            metrics?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetrics>;
            tracing?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracing>;
        }
        /**
         * AccessLogs defines accesslog parameters for managed proxies.
         * If unspecified, will send default format to stdout.
         */
        interface EnvoyProxySpecTelemetryAccessLog {
            /**
             * Disable disables access logging for managed proxies if set to true.
             */
            disable?: pulumi.Input<boolean>;
            /**
             * Settings defines accesslog settings for managed proxies.
             * If unspecified, will send default format to stdout.
             */
            settings?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettings>[]>;
        }
        /**
         * AccessLogs defines accesslog parameters for managed proxies.
         * If unspecified, will send default format to stdout.
         */
        interface EnvoyProxySpecTelemetryAccessLogPatch {
            /**
             * Disable disables access logging for managed proxies if set to true.
             */
            disable?: pulumi.Input<boolean>;
            /**
             * Settings defines accesslog settings for managed proxies.
             * If unspecified, will send default format to stdout.
             */
            settings?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsPatch>[]>;
        }
        interface EnvoyProxySpecTelemetryAccessLogSettings {
            format?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsFormat>;
            /**
             * Matches defines the match conditions for accesslog in CEL expression.
             * An accesslog will be emitted only when one or more match conditions are evaluated to true.
             * Invalid [CEL](https://www.envoyproxy.io/docs/envoy/latest/xds/type/v3/cel.proto.html#common-expression-language-cel-proto) expressions will be ignored.
             */
            matches?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Sinks defines the sinks of accesslog.
             */
            sinks?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinks>[]>;
            /**
             * Type defines the component emitting the accesslog, such as Listener and Route.
             * If type not defined, the setting would apply to:
             * (1) All Routes.
             * (2) Listeners if and only if Envoy does not find a matching route for a request.
             * If type is defined, the accesslog settings would apply to the relevant component (as-is).
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Format defines the format of accesslog.
         * This will be ignored if sink type is ALS.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsFormat {
            /**
             * JSON is additional attributes that describe the specific event occurrence.
             * Structured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)
             * can be used as values for fields within the Struct.
             * It's required when the format type is "JSON".
             */
            json?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Text defines the text accesslog format, following Envoy accesslog formatting,
             * It's required when the format type is "Text".
             * Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the format.
             * The [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of accesslog format.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Format defines the format of accesslog.
         * This will be ignored if sink type is ALS.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsFormatPatch {
            /**
             * JSON is additional attributes that describe the specific event occurrence.
             * Structured format for the envoy access logs. Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators)
             * can be used as values for fields within the Struct.
             * It's required when the format type is "JSON".
             */
            json?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Text defines the text accesslog format, following Envoy accesslog formatting,
             * It's required when the format type is "Text".
             * Envoy [command operators](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#command-operators) may be used in the format.
             * The [format string documentation](https://www.envoyproxy.io/docs/envoy/latest/configuration/observability/access_log/usage#config-access-log-format-strings) provides more information.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of accesslog format.
             */
            type?: pulumi.Input<string>;
        }
        interface EnvoyProxySpecTelemetryAccessLogSettingsPatch {
            format?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsFormatPatch>;
            /**
             * Matches defines the match conditions for accesslog in CEL expression.
             * An accesslog will be emitted only when one or more match conditions are evaluated to true.
             * Invalid [CEL](https://www.envoyproxy.io/docs/envoy/latest/xds/type/v3/cel.proto.html#common-expression-language-cel-proto) expressions will be ignored.
             */
            matches?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Sinks defines the sinks of accesslog.
             */
            sinks?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksPatch>[]>;
            /**
             * Type defines the component emitting the accesslog, such as Listener and Route.
             * If type not defined, the setting would apply to:
             * (1) All Routes.
             * (2) Listeners if and only if Envoy does not find a matching route for a request.
             * If type is defined, the accesslog settings would apply to the relevant component (as-is).
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ProxyAccessLogSink defines the sink of accesslog.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinks {
            als?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAls>;
            file?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksFile>;
            openTelemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry>;
            /**
             * Type defines the type of accesslog sink.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ALS defines the gRPC Access Log Service (ALS) sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAls {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp>;
            /**
             * LogName defines the friendly name of the access log to be returned in
             * StreamAccessLogsMessage.Identifier. This allows the access log server
             * to differentiate between different access logs coming from the same Envoy.
             */
            logName?: pulumi.Input<string>;
            /**
             * Type defines the type of accesslog. Supported types are "HTTP" and "TCP".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * HTTP defines additional configuration specific to HTTP access logs.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttp {
            /**
             * RequestHeaders defines request headers to include in log entries sent to the access log service.
             */
            requestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ResponseHeaders defines response headers to include in log entries sent to the access log service.
             */
            responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ResponseTrailers defines response trailers to include in log entries sent to the access log service.
             */
            responseTrailers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * HTTP defines additional configuration specific to HTTP access logs.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttpPatch {
            /**
             * RequestHeaders defines request headers to include in log entries sent to the access log service.
             */
            requestHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ResponseHeaders defines response headers to include in log entries sent to the access log service.
             */
            responseHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ResponseTrailers defines response trailers to include in log entries sent to the access log service.
             */
            responseTrailers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * ALS defines the gRPC Access Log Service (ALS) sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsBackendSettingsPatch>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsHttpPatch>;
            /**
             * LogName defines the friendly name of the access log to be returned in
             * StreamAccessLogsMessage.Identifier. This allows the access log server
             * to differentiate between different access logs coming from the same Envoy.
             */
            logName?: pulumi.Input<string>;
            /**
             * Type defines the type of accesslog. Supported types are "HTTP" and "TCP".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * File defines the file accesslog sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksFile {
            /**
             * Path defines the file path used to expose envoy access log(e.g. /dev/stdout).
             */
            path?: pulumi.Input<string>;
        }
        /**
         * File defines the file accesslog sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksFilePatch {
            /**
             * Path defines the file path used to expose envoy access log(e.g. /dev/stdout).
             */
            path?: pulumi.Input<string>;
        }
        /**
         * OpenTelemetry defines the OpenTelemetry accesslog sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetry {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings>;
            /**
             * Host define the extension service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the extension service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
            /**
             * Resources is a set of labels that describe the source of a log entry, including envoy node info.
             * It's recommended to follow [semantic conventions](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/).
             */
            resources?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * OpenTelemetry defines the OpenTelemetry accesslog sink.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryBackendSettingsPatch>;
            /**
             * Host define the extension service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the extension service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
            /**
             * Resources is a set of labels that describe the source of a log entry, including envoy node info.
             * It's recommended to follow [semantic conventions](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/).
             */
            resources?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * ProxyAccessLogSink defines the sink of accesslog.
         */
        interface EnvoyProxySpecTelemetryAccessLogSettingsSinksPatch {
            als?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksAlsPatch>;
            file?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksFilePatch>;
            openTelemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogSettingsSinksOpenTelemetryPatch>;
            /**
             * Type defines the type of accesslog sink.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Metrics defines metrics configuration for managed proxies.
         */
        interface EnvoyProxySpecTelemetryMetrics {
            /**
             * ClusterStatName defines the value of cluster alt_stat_name, determining how cluster stats are named.
             * For more details, see envoy docs: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html
             * The supported operators for this pattern are:
             * %ROUTE_NAME%: name of Gateway API xRoute resource
             * %ROUTE_NAMESPACE%: namespace of Gateway API xRoute resource
             * %ROUTE_KIND%: kind of Gateway API xRoute resource
             * %ROUTE_RULE_NAME%: name of the Gateway API xRoute section
             * %ROUTE_RULE_NUMBER%: name of the Gateway API xRoute section
             * %BACKEND_REFS%: names of all backends referenced in <NAMESPACE>/<NAME>|<NAMESPACE>/<NAME>|... format
             * Only xDS Clusters created for HTTPRoute and GRPCRoute are currently supported.
             * Default: %ROUTE_KIND%/%ROUTE_NAMESPACE%/%ROUTE_NAME%/rule/%ROUTE_RULE_NUMBER%
             * Example: httproute/my-ns/my-route/rule/0
             */
            clusterStatName?: pulumi.Input<string>;
            /**
             * EnablePerEndpointStats enables per endpoint envoy stats metrics.
             * Please use with caution.
             */
            enablePerEndpointStats?: pulumi.Input<boolean>;
            /**
             * EnableRequestResponseSizesStats enables publishing of histograms tracking header and body sizes of requests and responses.
             */
            enableRequestResponseSizesStats?: pulumi.Input<boolean>;
            /**
             * EnableVirtualHostStats enables envoy stat metrics for virtual hosts.
             */
            enableVirtualHostStats?: pulumi.Input<boolean>;
            /**
             * Matches defines configuration for selecting specific metrics instead of generating all metrics stats
             * that are enabled by default. This helps reduce CPU and memory overhead in Envoy, but eliminating some stats
             * may after critical functionality. Here are the stats that we strongly recommend not disabling:
             * `cluster_manager.warming_clusters`, `cluster.<cluster_name>.membership_total`,`cluster.<cluster_name>.membership_healthy`,
             * `cluster.<cluster_name>.membership_degraded`，reference  https://github.com/envoyproxy/envoy/issues/9856,
             * https://github.com/envoyproxy/envoy/issues/14610
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsMatches>[]>;
            prometheus?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheus>;
            /**
             * Sinks defines the metric sinks where metrics are sent to.
             */
            sinks?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinks>[]>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface EnvoyProxySpecTelemetryMetricsMatches {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * StringMatch defines how to match any strings.
         * This is a general purpose match condition that can be used by other EG APIs
         * that need to match against a string.
         */
        interface EnvoyProxySpecTelemetryMetricsMatchesPatch {
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Metrics defines metrics configuration for managed proxies.
         */
        interface EnvoyProxySpecTelemetryMetricsPatch {
            /**
             * ClusterStatName defines the value of cluster alt_stat_name, determining how cluster stats are named.
             * For more details, see envoy docs: https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto.html
             * The supported operators for this pattern are:
             * %ROUTE_NAME%: name of Gateway API xRoute resource
             * %ROUTE_NAMESPACE%: namespace of Gateway API xRoute resource
             * %ROUTE_KIND%: kind of Gateway API xRoute resource
             * %ROUTE_RULE_NAME%: name of the Gateway API xRoute section
             * %ROUTE_RULE_NUMBER%: name of the Gateway API xRoute section
             * %BACKEND_REFS%: names of all backends referenced in <NAMESPACE>/<NAME>|<NAMESPACE>/<NAME>|... format
             * Only xDS Clusters created for HTTPRoute and GRPCRoute are currently supported.
             * Default: %ROUTE_KIND%/%ROUTE_NAMESPACE%/%ROUTE_NAME%/rule/%ROUTE_RULE_NUMBER%
             * Example: httproute/my-ns/my-route/rule/0
             */
            clusterStatName?: pulumi.Input<string>;
            /**
             * EnablePerEndpointStats enables per endpoint envoy stats metrics.
             * Please use with caution.
             */
            enablePerEndpointStats?: pulumi.Input<boolean>;
            /**
             * EnableRequestResponseSizesStats enables publishing of histograms tracking header and body sizes of requests and responses.
             */
            enableRequestResponseSizesStats?: pulumi.Input<boolean>;
            /**
             * EnableVirtualHostStats enables envoy stat metrics for virtual hosts.
             */
            enableVirtualHostStats?: pulumi.Input<boolean>;
            /**
             * Matches defines configuration for selecting specific metrics instead of generating all metrics stats
             * that are enabled by default. This helps reduce CPU and memory overhead in Envoy, but eliminating some stats
             * may after critical functionality. Here are the stats that we strongly recommend not disabling:
             * `cluster_manager.warming_clusters`, `cluster.<cluster_name>.membership_total`,`cluster.<cluster_name>.membership_healthy`,
             * `cluster.<cluster_name>.membership_degraded`，reference  https://github.com/envoyproxy/envoy/issues/9856,
             * https://github.com/envoyproxy/envoy/issues/14610
             */
            matches?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsMatchesPatch>[]>;
            prometheus?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheusPatch>;
            /**
             * Sinks defines the metric sinks where metrics are sent to.
             */
            sinks?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksPatch>[]>;
        }
        /**
         * Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.
         */
        interface EnvoyProxySpecTelemetryMetricsPrometheus {
            compression?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheusCompression>;
            /**
             * Disable the Prometheus endpoint.
             */
            disable?: pulumi.Input<boolean>;
        }
        /**
         * Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.
         */
        interface EnvoyProxySpecTelemetryMetricsPrometheusCompression {
            /**
             * The configuration for Brotli compressor.
             */
            brotli?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * The configuration for GZIP compressor.
             */
            gzip?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CompressorType defines the compressor type to use for compression.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Configure the compression on Prometheus endpoint. Compression is useful in situations when bandwidth is scarce and large payloads can be effectively compressed at the expense of higher CPU load.
         */
        interface EnvoyProxySpecTelemetryMetricsPrometheusCompressionPatch {
            /**
             * The configuration for Brotli compressor.
             */
            brotli?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * The configuration for GZIP compressor.
             */
            gzip?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CompressorType defines the compressor type to use for compression.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Prometheus defines the configuration for Admin endpoint `/stats/prometheus`.
         */
        interface EnvoyProxySpecTelemetryMetricsPrometheusPatch {
            compression?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsPrometheusCompressionPatch>;
            /**
             * Disable the Prometheus endpoint.
             */
            disable?: pulumi.Input<boolean>;
        }
        /**
         * ProxyMetricSink defines the sink of metrics.
         * Default metrics sink is OpenTelemetry.
         */
        interface EnvoyProxySpecTelemetryMetricsSinks {
            openTelemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry>;
            /**
             * Type defines the metric sink type.
             * EG currently only supports OpenTelemetry.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * OpenTelemetry defines the configuration for OpenTelemetry sink.
         * It's required if the sink type is OpenTelemetry.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetry {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings>;
            /**
             * Host define the service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * OpenTelemetry defines the configuration for OpenTelemetry sink.
         * It's required if the sink type is OpenTelemetry.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryBackendSettingsPatch>;
            /**
             * Host define the service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * ProxyMetricSink defines the sink of metrics.
         * Default metrics sink is OpenTelemetry.
         */
        interface EnvoyProxySpecTelemetryMetricsSinksPatch {
            openTelemetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsSinksOpenTelemetryPatch>;
            /**
             * Type defines the metric sink type.
             * EG currently only supports OpenTelemetry.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Telemetry defines telemetry parameters for managed proxies.
         */
        interface EnvoyProxySpecTelemetryPatch {
            accessLog?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryAccessLogPatch>;
            metrics?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryMetricsPatch>;
            tracing?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingPatch>;
        }
        /**
         * Tracing defines tracing configuration for managed proxies.
         * If unspecified, will not send tracing data.
         */
        interface EnvoyProxySpecTelemetryTracing {
            /**
             * CustomTags defines the custom tags to add to each span.
             * If provider is kubernetes, pod name and namespace are added by default.
             */
            customTags?: pulumi.Input<{
                [key: string]: pulumi.Input<{
                    [key: string]: pulumi.Input<string>;
                }>;
            }>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProvider>;
            samplingFraction?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingSamplingFraction>;
            /**
             * SamplingRate controls the rate at which traffic will be
             * selected for tracing if no prior sampling decision has been made.
             * Defaults to 100, valid values [0-100]. 100 indicates 100% sampling.
             *
             * Only one of SamplingRate or SamplingFraction may be specified.
             * If neither field is specified, all requests will be sampled.
             */
            samplingRate?: pulumi.Input<number>;
        }
        /**
         * Tracing defines tracing configuration for managed proxies.
         * If unspecified, will not send tracing data.
         */
        interface EnvoyProxySpecTelemetryTracingPatch {
            /**
             * CustomTags defines the custom tags to add to each span.
             * If provider is kubernetes, pod name and namespace are added by default.
             */
            customTags?: pulumi.Input<{
                [key: string]: pulumi.Input<{
                    [key: string]: pulumi.Input<string>;
                }>;
            }>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderPatch>;
            samplingFraction?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingSamplingFractionPatch>;
            /**
             * SamplingRate controls the rate at which traffic will be
             * selected for tracing if no prior sampling decision has been made.
             * Defaults to 100, valid values [0-100]. 100 indicates 100% sampling.
             *
             * Only one of SamplingRate or SamplingFraction may be specified.
             * If neither field is specified, all requests will be sampled.
             */
            samplingRate?: pulumi.Input<number>;
        }
        /**
         * Provider defines the tracing provider.
         */
        interface EnvoyProxySpecTelemetryTracingProvider {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettings>;
            /**
             * Host define the provider service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the provider service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
            /**
             * ServiceName defines the service name to use in tracing configuration.
             * If not set, Envoy Gateway will use a default service name set as
             * "name.namespace" (e.g., "my-gateway.default").
             * Note: This field is only supported for OpenTelemetry and Datadog tracing providers.
             * For Zipkin, the service name in traces is always derived from the Envoy --service-cluster flag
             * (typically "namespace/name" format). Setting this field has no effect for Zipkin.
             */
            serviceName?: pulumi.Input<string>;
            /**
             * Type defines the tracing provider type.
             */
            type?: pulumi.Input<string>;
            zipkin?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderZipkin>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface EnvoyProxySpecTelemetryTracingProviderBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Provider defines the tracing provider.
         */
        interface EnvoyProxySpecTelemetryTracingProviderPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderBackendSettingsPatch>;
            /**
             * Host define the provider service hostname.
             * Deprecated: Use BackendRefs instead.
             */
            host?: pulumi.Input<string>;
            /**
             * Port defines the port the provider service is exposed on.
             * Deprecated: Use BackendRefs instead.
             */
            port?: pulumi.Input<number>;
            /**
             * ServiceName defines the service name to use in tracing configuration.
             * If not set, Envoy Gateway will use a default service name set as
             * "name.namespace" (e.g., "my-gateway.default").
             * Note: This field is only supported for OpenTelemetry and Datadog tracing providers.
             * For Zipkin, the service name in traces is always derived from the Envoy --service-cluster flag
             * (typically "namespace/name" format). Setting this field has no effect for Zipkin.
             */
            serviceName?: pulumi.Input<string>;
            /**
             * Type defines the tracing provider type.
             */
            type?: pulumi.Input<string>;
            zipkin?: pulumi.Input<inputs.gateway.v1alpha1.EnvoyProxySpecTelemetryTracingProviderZipkinPatch>;
        }
        /**
         * Zipkin defines the Zipkin tracing provider configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderZipkin {
            /**
             * DisableSharedSpanContext determines whether the default Envoy behaviour of
             * client and server spans sharing the same span context should be disabled.
             */
            disableSharedSpanContext?: pulumi.Input<boolean>;
            /**
             * Enable128BitTraceID determines whether a 128bit trace id will be used
             * when creating a new trace instance. If set to false, a 64bit trace
             * id will be used.
             */
            enable128BitTraceId?: pulumi.Input<boolean>;
        }
        /**
         * Zipkin defines the Zipkin tracing provider configuration
         */
        interface EnvoyProxySpecTelemetryTracingProviderZipkinPatch {
            /**
             * DisableSharedSpanContext determines whether the default Envoy behaviour of
             * client and server spans sharing the same span context should be disabled.
             */
            disableSharedSpanContext?: pulumi.Input<boolean>;
            /**
             * Enable128BitTraceID determines whether a 128bit trace id will be used
             * when creating a new trace instance. If set to false, a 64bit trace
             * id will be used.
             */
            enable128BitTraceId?: pulumi.Input<boolean>;
        }
        /**
         * SamplingFraction represents the fraction of requests that should be
         * selected for tracing if no prior sampling decision has been made.
         *
         * Only one of SamplingRate or SamplingFraction may be specified.
         * If neither field is specified, all requests will be sampled.
         */
        interface EnvoyProxySpecTelemetryTracingSamplingFraction {
            denominator?: pulumi.Input<number>;
            numerator?: pulumi.Input<number>;
        }
        /**
         * SamplingFraction represents the fraction of requests that should be
         * selected for tracing if no prior sampling decision has been made.
         *
         * Only one of SamplingRate or SamplingFraction may be specified.
         * If neither field is specified, all requests will be sampled.
         */
        interface EnvoyProxySpecTelemetryTracingSamplingFractionPatch {
            denominator?: pulumi.Input<number>;
            numerator?: pulumi.Input<number>;
        }
        /**
         * HTTPRouteFilter is a custom Envoy Gateway HTTPRouteFilter which provides extended
         * traffic processing options such as path regex rewrite, direct response and more.
         */
        interface HTTPRouteFilter {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"HTTPRouteFilter">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpec>;
        }
        /**
         * Spec defines the desired state of HTTPRouteFilter.
         */
        interface HTTPRouteFilterSpec {
            credentialInjection?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjection>;
            directResponse?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponse>;
            urlRewrite?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewrite>;
        }
        /**
         * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
         * This is useful when the backend service requires credentials in the request, and the original
         * request does not contain them. The filter can inject credentials into the request before forwarding
         * it to the backend service.
         */
        interface HTTPRouteFilterSpecCredentialInjection {
            credential?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredential>;
            /**
             * Header is the name of the header where the credentials are injected.
             * If not specified, the credentials are injected into the Authorization header.
             */
            header?: pulumi.Input<string>;
            /**
             * Whether to overwrite the value or not if the injected headers already exist.
             * If not specified, the default value is false.
             */
            overwrite?: pulumi.Input<boolean>;
        }
        /**
         * Credential is the credential to be injected.
         */
        interface HTTPRouteFilterSpecCredentialInjectionCredential {
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredentialValueRef>;
        }
        /**
         * Credential is the credential to be injected.
         */
        interface HTTPRouteFilterSpecCredentialInjectionCredentialPatch {
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredentialValueRefPatch>;
        }
        /**
         * ValueRef is a reference to the secret containing the credentials to be injected.
         * This is an Opaque secret. The credential should be stored in the key
         * "credential", and the value should be the credential to be injected.
         * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
         * for bearer token, the value should be "Bearer <token>".
         * Note: The secret must be in the same namespace as the HTTPRouteFilter.
         */
        interface HTTPRouteFilterSpecCredentialInjectionCredentialValueRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * ValueRef is a reference to the secret containing the credentials to be injected.
         * This is an Opaque secret. The credential should be stored in the key
         * "credential", and the value should be the credential to be injected.
         * For example, for basic authentication, the value should be "Basic <base64 encoded username:password>".
         * for bearer token, the value should be "Bearer <token>".
         * Note: The secret must be in the same namespace as the HTTPRouteFilter.
         */
        interface HTTPRouteFilterSpecCredentialInjectionCredentialValueRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * HTTPCredentialInjectionFilter defines the configuration to inject credentials into the request.
         * This is useful when the backend service requires credentials in the request, and the original
         * request does not contain them. The filter can inject credentials into the request before forwarding
         * it to the backend service.
         */
        interface HTTPRouteFilterSpecCredentialInjectionPatch {
            credential?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjectionCredentialPatch>;
            /**
             * Header is the name of the header where the credentials are injected.
             * If not specified, the credentials are injected into the Authorization header.
             */
            header?: pulumi.Input<string>;
            /**
             * Whether to overwrite the value or not if the injected headers already exist.
             * If not specified, the default value is false.
             */
            overwrite?: pulumi.Input<boolean>;
        }
        /**
         * HTTPDirectResponseFilter defines the configuration to return a fixed response.
         */
        interface HTTPRouteFilterSpecDirectResponse {
            body?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponseBody>;
            /**
             * Content Type of the response. This will be set in the Content-Type header.
             */
            contentType?: pulumi.Input<string>;
            /**
             * Status Code of the HTTP response
             * If unset, defaults to 200.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Body of the Response
         */
        interface HTTPRouteFilterSpecDirectResponseBody {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponseBodyValueRef>;
        }
        /**
         * Body of the Response
         */
        interface HTTPRouteFilterSpecDirectResponseBodyPatch {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponseBodyValueRefPatch>;
        }
        /**
         * ValueRef contains the contents of the body
         * specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         *
         * The value of key `response.body` in the ConfigMap will be used as the response body.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface HTTPRouteFilterSpecDirectResponseBodyValueRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ValueRef contains the contents of the body
         * specified as a local object reference.
         * Only a reference to ConfigMap is supported.
         *
         * The value of key `response.body` in the ConfigMap will be used as the response body.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface HTTPRouteFilterSpecDirectResponseBodyValueRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * HTTPDirectResponseFilter defines the configuration to return a fixed response.
         */
        interface HTTPRouteFilterSpecDirectResponsePatch {
            body?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponseBodyPatch>;
            /**
             * Content Type of the response. This will be set in the Content-Type header.
             */
            contentType?: pulumi.Input<string>;
            /**
             * Status Code of the HTTP response
             * If unset, defaults to 200.
             */
            statusCode?: pulumi.Input<number>;
        }
        /**
         * Spec defines the desired state of HTTPRouteFilter.
         */
        interface HTTPRouteFilterSpecPatch {
            credentialInjection?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecCredentialInjectionPatch>;
            directResponse?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecDirectResponsePatch>;
            urlRewrite?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewritePatch>;
        }
        /**
         * HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host
         */
        interface HTTPRouteFilterSpecUrlRewrite {
            hostname?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewriteHostname>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewritePath>;
        }
        /**
         * Hostname is the value to be used to replace the Host header value during
         * forwarding.
         */
        interface HTTPRouteFilterSpecUrlRewriteHostname {
            /**
             * Header is the name of the header whose value would be used to rewrite the Host header
             */
            header?: pulumi.Input<string>;
            /**
             * HTTPPathModifierType defines the type of Hostname rewrite.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Hostname is the value to be used to replace the Host header value during
         * forwarding.
         */
        interface HTTPRouteFilterSpecUrlRewriteHostnamePatch {
            /**
             * Header is the name of the header whose value would be used to rewrite the Host header
             */
            header?: pulumi.Input<string>;
            /**
             * HTTPPathModifierType defines the type of Hostname rewrite.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTPURLRewriteFilter define rewrites of HTTP URL components such as path and host
         */
        interface HTTPRouteFilterSpecUrlRewritePatch {
            hostname?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewriteHostnamePatch>;
            path?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewritePathPatch>;
        }
        /**
         * Path defines a path rewrite.
         */
        interface HTTPRouteFilterSpecUrlRewritePath {
            replaceRegexMatch?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatch>;
            /**
             * HTTPPathModifierType defines the type of path redirect or rewrite.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Path defines a path rewrite.
         */
        interface HTTPRouteFilterSpecUrlRewritePathPatch {
            replaceRegexMatch?: pulumi.Input<inputs.gateway.v1alpha1.HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatchPatch>;
            /**
             * HTTPPathModifierType defines the type of path redirect or rewrite.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
         * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
         * Some examples:
         * (1) replaceRegexMatch:
         *       pattern: ^/service/([^/]+)(/.*)$
         *       substitution: \2/instance/\1
         *     Would transform /service/foo/v1/api into /v1/api/instance/foo.
         * (2) replaceRegexMatch:
         *       pattern: one
         *       substitution: two
         *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
         * (3) replaceRegexMatch:
         *       pattern: ^(.*?)one(.*)$
         *       substitution: \1two\2
         *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
         * (3) replaceRegexMatch:
         *       pattern: (?i)/xxx/
         *       substitution: /yyy/
         *     Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
         */
        interface HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatch {
            /**
             * Pattern matches a regular expression against the value of the HTTP Path.The regex string must
             * adhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.
             */
            pattern?: pulumi.Input<string>;
            /**
             * Substitution is an expression that replaces the matched portion.The expression may include numbered
             * capture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.
             */
            substitution?: pulumi.Input<string>;
        }
        /**
         * ReplaceRegexMatch defines a path regex rewrite. The path portions matched by the regex pattern are replaced by the defined substitution.
         * https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/route/v3/route_components.proto#envoy-v3-api-field-config-route-v3-routeaction-regex-rewrite
         * Some examples:
         * (1) replaceRegexMatch:
         *       pattern: ^/service/([^/]+)(/.*)$
         *       substitution: \2/instance/\1
         *     Would transform /service/foo/v1/api into /v1/api/instance/foo.
         * (2) replaceRegexMatch:
         *       pattern: one
         *       substitution: two
         *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/two/zzz.
         * (3) replaceRegexMatch:
         *       pattern: ^(.*?)one(.*)$
         *       substitution: \1two\2
         *     Would transform /xxx/one/yyy/one/zzz into /xxx/two/yyy/one/zzz.
         * (3) replaceRegexMatch:
         *       pattern: (?i)/xxx/
         *       substitution: /yyy/
         *     Would transform path /aaa/XxX/bbb into /aaa/yyy/bbb (case-insensitive).
         */
        interface HTTPRouteFilterSpecUrlRewritePathReplaceRegexMatchPatch {
            /**
             * Pattern matches a regular expression against the value of the HTTP Path.The regex string must
             * adhere to the syntax documented in https://github.com/google/re2/wiki/Syntax.
             */
            pattern?: pulumi.Input<string>;
            /**
             * Substitution is an expression that replaces the matched portion.The expression may include numbered
             * capture groups that adhere to syntax documented in https://github.com/google/re2/wiki/Syntax.
             */
            substitution?: pulumi.Input<string>;
        }
        /**
         * SecurityPolicy allows the user to configure various security settings for a
         * Gateway.
         */
        interface SecurityPolicy {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"gateway.envoyproxy.io/v1alpha1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"SecurityPolicy">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpec>;
            status?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicyStatus>;
        }
        /**
         * Spec defines the desired state of SecurityPolicy.
         */
        interface SecurityPolicySpec {
            apiKeyAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuth>;
            authorization?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorization>;
            basicAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecBasicAuth>;
            cors?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecCors>;
            extAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuth>;
            jwt?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwt>;
            oidc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidc>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetRef>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetRefs>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetSelectors>[]>;
        }
        /**
         * APIKeyAuth defines the configuration for the API Key Authentication.
         */
        interface SecurityPolicySpecApiKeyAuth {
            /**
             * CredentialRefs is the Kubernetes secret which contains the API keys.
             * This is an Opaque secret.
             * Each API key is stored in the key representing the client id.
             * If the secrets have a key for a duplicated client, the first one will be used.
             */
            credentialRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuthCredentialRefs>[]>;
            /**
             * ExtractFrom is where to fetch the key from the coming request.
             * The value from the first source that has a key will be used.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuthExtractFrom>[]>;
            /**
             * ForwardClientIDHeader is the name of the header to forward the client identity to the backend
             * service. The header will be added to the request with the client id as the value.
             */
            forwardClientIDHeader?: pulumi.Input<string>;
            /**
             * Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service.
             */
            sanitize?: pulumi.Input<boolean>;
        }
        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface SecurityPolicySpecApiKeyAuthCredentialRefs {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * SecretObjectReference identifies an API object including its namespace,
         * defaulting to Secret.
         *
         * The API object must be valid in the cluster; the Group and Kind must
         * be registered in the cluster for this reference to be valid.
         *
         * References to objects with invalid Group and Kind are not valid, and must
         * be rejected by the implementation, with appropriate Conditions set
         * on the containing object.
         */
        interface SecurityPolicySpecApiKeyAuthCredentialRefsPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * ExtractFrom is where to fetch the key from the coming request.
         * Only one of header, param or cookie is supposed to be specified.
         */
        interface SecurityPolicySpecApiKeyAuthExtractFrom {
            /**
             * Cookies is the names of the cookie to fetch the key from.
             * If multiple cookies are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            cookies?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers is the names of the header to fetch the key from.
             * If multiple headers are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Params is the names of the query parameter to fetch the key from.
             * If multiple params are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            params?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * ExtractFrom is where to fetch the key from the coming request.
         * Only one of header, param or cookie is supposed to be specified.
         */
        interface SecurityPolicySpecApiKeyAuthExtractFromPatch {
            /**
             * Cookies is the names of the cookie to fetch the key from.
             * If multiple cookies are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            cookies?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers is the names of the header to fetch the key from.
             * If multiple headers are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            headers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Params is the names of the query parameter to fetch the key from.
             * If multiple params are specified, envoy will look for the api key in the order of the list.
             * This field is optional, but only one of headers, params or cookies is supposed to be specified.
             */
            params?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * APIKeyAuth defines the configuration for the API Key Authentication.
         */
        interface SecurityPolicySpecApiKeyAuthPatch {
            /**
             * CredentialRefs is the Kubernetes secret which contains the API keys.
             * This is an Opaque secret.
             * Each API key is stored in the key representing the client id.
             * If the secrets have a key for a duplicated client, the first one will be used.
             */
            credentialRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuthCredentialRefsPatch>[]>;
            /**
             * ExtractFrom is where to fetch the key from the coming request.
             * The value from the first source that has a key will be used.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuthExtractFromPatch>[]>;
            /**
             * ForwardClientIDHeader is the name of the header to forward the client identity to the backend
             * service. The header will be added to the request with the client id as the value.
             */
            forwardClientIDHeader?: pulumi.Input<string>;
            /**
             * Sanitize indicates whether to remove the API key from the request before forwarding it to the backend service.
             */
            sanitize?: pulumi.Input<boolean>;
        }
        /**
         * Authorization defines the authorization configuration.
         */
        interface SecurityPolicySpecAuthorization {
            /**
             * DefaultAction defines the default action to be taken if no rules match.
             * If not specified, the default action is Deny.
             */
            defaultAction?: pulumi.Input<string>;
            /**
             * Rules defines a list of authorization rules.
             * These rules are evaluated in order, the first matching rule will be applied,
             * and the rest will be skipped.
             *
             * For example, if there are two rules: the first rule allows the request
             * and the second rule denies it, when a request matches both rules, it will be allowed.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRules>[]>;
        }
        /**
         * Authorization defines the authorization configuration.
         */
        interface SecurityPolicySpecAuthorizationPatch {
            /**
             * DefaultAction defines the default action to be taken if no rules match.
             * If not specified, the default action is Deny.
             */
            defaultAction?: pulumi.Input<string>;
            /**
             * Rules defines a list of authorization rules.
             * These rules are evaluated in order, the first matching rule will be applied,
             * and the rest will be skipped.
             *
             * For example, if there are two rules: the first rule allows the request
             * and the second rule denies it, when a request matches both rules, it will be allowed.
             */
            rules?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPatch>[]>;
        }
        /**
         * AuthorizationRule defines a single authorization rule.
         */
        interface SecurityPolicySpecAuthorizationRules {
            /**
             * Action defines the action to be taken if the rule matches.
             */
            action?: pulumi.Input<string>;
            /**
             * Name is a user-friendly name for the rule.
             * If not specified, Envoy Gateway will generate a unique name for the rule.
             */
            name?: pulumi.Input<string>;
            operation?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesOperation>;
            principal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipal>;
        }
        /**
         * Operation specifies the operation of a request, such as HTTP methods.
         * If not specified, all operations are matched on.
         */
        interface SecurityPolicySpecAuthorizationRulesOperation {
            /**
             * Methods are the HTTP methods of the request.
             * If multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.
             */
            methods?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Operation specifies the operation of a request, such as HTTP methods.
         * If not specified, all operations are matched on.
         */
        interface SecurityPolicySpecAuthorizationRulesOperationPatch {
            /**
             * Methods are the HTTP methods of the request.
             * If multiple methods are specified, all specified methods are allowed or denied, based on the action of the rule.
             */
            methods?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * AuthorizationRule defines a single authorization rule.
         */
        interface SecurityPolicySpecAuthorizationRulesPatch {
            /**
             * Action defines the action to be taken if the rule matches.
             */
            action?: pulumi.Input<string>;
            /**
             * Name is a user-friendly name for the rule.
             * If not specified, Envoy Gateway will generate a unique name for the rule.
             */
            name?: pulumi.Input<string>;
            operation?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesOperationPatch>;
            principal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalPatch>;
        }
        /**
         * Principal specifies the client identity of a request.
         * If there are multiple principal types, all principals must match for the rule to match.
         * For example, if there are two principals: one for client IP and one for JWT claim,
         * the rule will match only if both the client IP and the JWT claim match.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipal {
            /**
             * ClientCIDRs are the IP CIDR ranges of the client.
             * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
             *
             * If multiple CIDR ranges are specified, one of the CIDR ranges must match
             * the client IP for the rule to match.
             *
             * The client IP is inferred from the X-Forwarded-For header, a custom header,
             * or the proxy protocol.
             * You can use the `ClientIPDetection` or the `ProxyProtocol` field in
             * the `ClientTrafficPolicy` to configure how the client IP is detected.
             */
            clientCIDRs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers authorize the request based on user identity extracted from custom headers.
             * If multiple headers are specified, all headers must match for the rule to match.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalHeaders>[]>;
            jwt?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwt>;
        }
        /**
         * AuthorizationHeaderMatch specifies how to match against the value of an HTTP header within a authorization rule.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalHeaders {
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Values are the values that the header must match.
             * If multiple values are specified, the rule will match if any of the values match.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * AuthorizationHeaderMatch specifies how to match against the value of an HTTP header within a authorization rule.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalHeadersPatch {
            /**
             * Name of the HTTP header.
             * The header name is case-insensitive unless PreserveHeaderCase is set to true.
             * For example, "Foo" and "foo" are considered the same header.
             */
            name?: pulumi.Input<string>;
            /**
             * Values are the values that the header must match.
             * If multiple values are specified, the rule will match if any of the values match.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * JWT authorize the request based on the JWT claims and scopes.
         * Note: in order to use JWT claims for authorization, you must configure the
         * JWT authentication in the same `SecurityPolicy`.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalJwt {
            /**
             * Claims are the claims in a JWT token.
             *
             * If multiple claims are specified, all claims must match for the rule to match.
             * For example, if there are two claims: one for the audience and one for the issuer,
             * the rule will match only if both the audience and the issuer match.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims>[]>;
            /**
             * Provider is the name of the JWT provider that used to verify the JWT token.
             * In order to use JWT claims for authorization, you must configure the JWT
             * authentication with the same provider in the same `SecurityPolicy`.
             */
            provider?: pulumi.Input<string>;
            /**
             * Scopes are a special type of claim in a JWT token that represents the permissions of the client.
             *
             * The value of the scopes field should be a space delimited string that is expected in the scope parameter,
             * as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.
             *
             * If multiple scopes are specified, all scopes must match for the rule to match.
             */
            scopes?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * JWTClaim specifies a claim in a JWT token.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalJwtClaims {
            /**
             * Name is the name of the claim.
             * If it is a nested claim, use a dot (.) separated string as the name to
             * represent the full path to the claim.
             * For example, if the claim is in the "department" field in the "organization" field,
             * the name should be "organization.department".
             */
            name?: pulumi.Input<string>;
            /**
             * ValueType is the type of the claim value.
             * Only String and StringArray types are supported for now.
             */
            valueType?: pulumi.Input<string>;
            /**
             * Values are the values that the claim must match.
             * If the claim is a string type, the specified value must match exactly.
             * If the claim is a string array type, the specified value must match one of the values in the array.
             * If multiple values are specified, one of the values must match for the rule to match.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * JWTClaim specifies a claim in a JWT token.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalJwtClaimsPatch {
            /**
             * Name is the name of the claim.
             * If it is a nested claim, use a dot (.) separated string as the name to
             * represent the full path to the claim.
             * For example, if the claim is in the "department" field in the "organization" field,
             * the name should be "organization.department".
             */
            name?: pulumi.Input<string>;
            /**
             * ValueType is the type of the claim value.
             * Only String and StringArray types are supported for now.
             */
            valueType?: pulumi.Input<string>;
            /**
             * Values are the values that the claim must match.
             * If the claim is a string type, the specified value must match exactly.
             * If the claim is a string array type, the specified value must match one of the values in the array.
             * If multiple values are specified, one of the values must match for the rule to match.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * JWT authorize the request based on the JWT claims and scopes.
         * Note: in order to use JWT claims for authorization, you must configure the
         * JWT authentication in the same `SecurityPolicy`.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalJwtPatch {
            /**
             * Claims are the claims in a JWT token.
             *
             * If multiple claims are specified, all claims must match for the rule to match.
             * For example, if there are two claims: one for the audience and one for the issuer,
             * the rule will match only if both the audience and the issuer match.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwtClaimsPatch>[]>;
            /**
             * Provider is the name of the JWT provider that used to verify the JWT token.
             * In order to use JWT claims for authorization, you must configure the JWT
             * authentication with the same provider in the same `SecurityPolicy`.
             */
            provider?: pulumi.Input<string>;
            /**
             * Scopes are a special type of claim in a JWT token that represents the permissions of the client.
             *
             * The value of the scopes field should be a space delimited string that is expected in the scope parameter,
             * as defined in RFC 6749: https://datatracker.ietf.org/doc/html/rfc6749#page-23.
             *
             * If multiple scopes are specified, all scopes must match for the rule to match.
             */
            scopes?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * Principal specifies the client identity of a request.
         * If there are multiple principal types, all principals must match for the rule to match.
         * For example, if there are two principals: one for client IP and one for JWT claim,
         * the rule will match only if both the client IP and the JWT claim match.
         */
        interface SecurityPolicySpecAuthorizationRulesPrincipalPatch {
            /**
             * ClientCIDRs are the IP CIDR ranges of the client.
             * Valid examples are "192.168.1.0/24" or "2001:db8::/64"
             *
             * If multiple CIDR ranges are specified, one of the CIDR ranges must match
             * the client IP for the rule to match.
             *
             * The client IP is inferred from the X-Forwarded-For header, a custom header,
             * or the proxy protocol.
             * You can use the `ClientIPDetection` or the `ProxyProtocol` field in
             * the `ClientTrafficPolicy` to configure how the client IP is detected.
             */
            clientCIDRs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers authorize the request based on user identity extracted from custom headers.
             * If multiple headers are specified, all headers must match for the rule to match.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalHeadersPatch>[]>;
            jwt?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationRulesPrincipalJwtPatch>;
        }
        /**
         * BasicAuth defines the configuration for the HTTP Basic Authentication.
         */
        interface SecurityPolicySpecBasicAuth {
            /**
             * This field specifies the header name to forward a successfully authenticated user to
             * the backend. The header will be added to the request with the username as the value.
             *
             * If it is not specified, the username will not be forwarded.
             */
            forwardUsernameHeader?: pulumi.Input<string>;
            users?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecBasicAuthUsers>;
        }
        /**
         * BasicAuth defines the configuration for the HTTP Basic Authentication.
         */
        interface SecurityPolicySpecBasicAuthPatch {
            /**
             * This field specifies the header name to forward a successfully authenticated user to
             * the backend. The header will be added to the request with the username as the value.
             *
             * If it is not specified, the username will not be forwarded.
             */
            forwardUsernameHeader?: pulumi.Input<string>;
            users?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecBasicAuthUsersPatch>;
        }
        /**
         * The Kubernetes secret which contains the username-password pairs in
         * htpasswd format, used to verify user credentials in the "Authorization"
         * header.
         *
         * This is an Opaque secret. The username-password pairs should be stored in
         * the key ".htpasswd". As the key name indicates, the value needs to be the
         * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
         * Right now, only SHA hash algorithm is supported.
         * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
         * for more details.
         *
         * Note: The secret must be in the same namespace as the SecurityPolicy.
         */
        interface SecurityPolicySpecBasicAuthUsers {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * The Kubernetes secret which contains the username-password pairs in
         * htpasswd format, used to verify user credentials in the "Authorization"
         * header.
         *
         * This is an Opaque secret. The username-password pairs should be stored in
         * the key ".htpasswd". As the key name indicates, the value needs to be the
         * htpasswd format, for example: "user1:{SHA}hashed_user1_password".
         * Right now, only SHA hash algorithm is supported.
         * Reference to https://httpd.apache.org/docs/2.4/programs/htpasswd.html
         * for more details.
         *
         * Note: The secret must be in the same namespace as the SecurityPolicy.
         */
        interface SecurityPolicySpecBasicAuthUsersPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * CORS defines the configuration for Cross-Origin Resource Sharing (CORS).
         */
        interface SecurityPolicySpecCors {
            /**
             * AllowCredentials indicates whether a request can include user credentials
             * like cookies, authentication headers, or TLS client certificates.
             * It specifies the value in the Access-Control-Allow-Credentials CORS response header.
             */
            allowCredentials?: pulumi.Input<boolean>;
            /**
             * AllowHeaders defines the headers that are allowed to be sent with requests.
             * It specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..
             * The value "*" allows any header to be sent.
             */
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * AllowMethods defines the methods that are allowed to make requests.
             * It specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..
             * The value "*" allows any method to be used.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * AllowOrigins defines the origins that are allowed to make requests.
             * It specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.
             * The value "*" allows any origin to make requests.
             */
            allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ExposeHeaders defines which response headers should be made accessible to
             * scripts running in the browser.
             * It specifies the headers in the Access-Control-Expose-Headers CORS response header..
             * The value "*" allows any header to be exposed.
             */
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MaxAge defines how long the results of a preflight request can be cached.
             * It specifies the value in the Access-Control-Max-Age CORS response header..
             */
            maxAge?: pulumi.Input<string>;
        }
        /**
         * CORS defines the configuration for Cross-Origin Resource Sharing (CORS).
         */
        interface SecurityPolicySpecCorsPatch {
            /**
             * AllowCredentials indicates whether a request can include user credentials
             * like cookies, authentication headers, or TLS client certificates.
             * It specifies the value in the Access-Control-Allow-Credentials CORS response header.
             */
            allowCredentials?: pulumi.Input<boolean>;
            /**
             * AllowHeaders defines the headers that are allowed to be sent with requests.
             * It specifies the allowed headers in the Access-Control-Allow-Headers CORS response header..
             * The value "*" allows any header to be sent.
             */
            allowHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * AllowMethods defines the methods that are allowed to make requests.
             * It specifies the allowed methods in the Access-Control-Allow-Methods CORS response header..
             * The value "*" allows any method to be used.
             */
            allowMethods?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * AllowOrigins defines the origins that are allowed to make requests.
             * It specifies the allowed origins in the Access-Control-Allow-Origin CORS response header.
             * The value "*" allows any origin to make requests.
             */
            allowOrigins?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ExposeHeaders defines which response headers should be made accessible to
             * scripts running in the browser.
             * It specifies the headers in the Access-Control-Expose-Headers CORS response header..
             * The value "*" allows any header to be exposed.
             */
            exposeHeaders?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MaxAge defines how long the results of a preflight request can be cached.
             * It specifies the value in the Access-Control-Max-Age CORS response header..
             */
            maxAge?: pulumi.Input<string>;
        }
        /**
         * ExtAuth defines the configuration for External Authorization.
         */
        interface SecurityPolicySpecExtAuth {
            bodyToExtAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthBodyToExtAuth>;
            /**
             * FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.
             * If FailOpen is set to true, the system allows the traffic to pass through.
             * Otherwise, if it is set to false or not set (defaulting to false),
             * the system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.
             * This setting determines whether to prioritize accessibility over strict security in case of authorization service failure.
             *
             * If set to true, the External Authorization will also be bypassed if its configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpc>;
            /**
             * HeadersToExtAuth defines the client request headers that will be included
             * in the request to the external authorization service.
             * Note: If not specified, the default behavior for gRPC and HTTP external
             * authorization services is different due to backward compatibility reasons.
             * All headers will be included in the check request to a gRPC authorization server.
             * Only the following headers will be included in the check request to an HTTP
             * authorization server: Host, Method, Path, Content-Length, and Authorization.
             * And these headers will always be included to the check request to an HTTP
             * authorization server by default, no matter whether they are specified
             * in HeadersToExtAuth or not.
             */
            headersToExtAuth?: pulumi.Input<pulumi.Input<string>[]>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttp>;
            /**
             * RecomputeRoute clears the route cache and recalculates the routing decision.
             * This field must be enabled if the headers added or modified by the ExtAuth are used for
             * route matching decisions. If the recomputation selects a new route, features targeting
             * the new matched route will be applied.
             */
            recomputeRoute?: pulumi.Input<boolean>;
        }
        /**
         * BodyToExtAuth defines the Body to Ext Auth configuration.
         */
        interface SecurityPolicySpecExtAuthBodyToExtAuth {
            /**
             * MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.
             * Envoy will return HTTP 413 and will not initiate the authorization process when buffer
             * reaches the number set in this field.
             * Note that this setting will have precedence over failOpen mode.
             */
            maxRequestBytes?: pulumi.Input<number>;
        }
        /**
         * BodyToExtAuth defines the Body to Ext Auth configuration.
         */
        interface SecurityPolicySpecExtAuthBodyToExtAuthPatch {
            /**
             * MaxRequestBytes is the maximum size of a message body that the filter will hold in memory.
             * Envoy will return HTTP 413 and will not initiate the authorization process when buffer
             * reaches the number set in this field.
             * Note that this setting will have precedence over failOpen mode.
             */
            maxRequestBytes?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the gRPC External Authorization service.
         * Either GRPCService or HTTPService must be specified,
         * and only one of them can be provided.
         */
        interface SecurityPolicySpecExtAuthGrpc {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettings>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecExtAuthGrpcBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the gRPC External Authorization service.
         * Either GRPCService or HTTPService must be specified,
         * and only one of them can be provided.
         */
        interface SecurityPolicySpecExtAuthGrpcPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcBackendSettingsPatch>;
        }
        /**
         * HTTP defines the HTTP External Authorization service.
         * Either GRPCService or HTTPService must be specified,
         * and only one of them can be provided.
         */
        interface SecurityPolicySpecExtAuthHttp {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettings>;
            /**
             * HeadersToBackend are the authorization response headers that will be added
             * to the original client request before sending it to the backend server.
             * Note that coexisting headers will be overridden.
             * If not specified, no authorization response headers will be added to the
             * original client request.
             */
            headersToBackend?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Path is the path of the HTTP External Authorization service.
             * If path is specified, the authorization request will be sent to that path,
             * or else the authorization request will use the path of the original request.
             *
             * Please note that the original request path will be appended to the path specified here.
             * For example, if the original request path is "/hello", and the path specified here is "/auth",
             * then the path of the authorization request will be "/auth/hello". If the path is not specified,
             * the path of the authorization request will be "/hello".
             */
            path?: pulumi.Input<string>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecExtAuthHttpBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecExtAuthHttpBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecExtAuthHttpBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecExtAuthHttpBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecExtAuthHttpBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the HTTP External Authorization service.
         * Either GRPCService or HTTPService must be specified,
         * and only one of them can be provided.
         */
        interface SecurityPolicySpecExtAuthHttpPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpBackendSettingsPatch>;
            /**
             * HeadersToBackend are the authorization response headers that will be added
             * to the original client request before sending it to the backend server.
             * Note that coexisting headers will be overridden.
             * If not specified, no authorization response headers will be added to the
             * original client request.
             */
            headersToBackend?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Path is the path of the HTTP External Authorization service.
             * If path is specified, the authorization request will be sent to that path,
             * or else the authorization request will use the path of the original request.
             *
             * Please note that the original request path will be appended to the path specified here.
             * For example, if the original request path is "/hello", and the path specified here is "/auth",
             * then the path of the authorization request will be "/auth/hello". If the path is not specified,
             * the path of the authorization request will be "/hello".
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExtAuth defines the configuration for External Authorization.
         */
        interface SecurityPolicySpecExtAuthPatch {
            bodyToExtAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthBodyToExtAuthPatch>;
            /**
             * FailOpen is a switch used to control the behavior when a response from the External Authorization service cannot be obtained.
             * If FailOpen is set to true, the system allows the traffic to pass through.
             * Otherwise, if it is set to false or not set (defaulting to false),
             * the system blocks the traffic and returns a HTTP 5xx error, reflecting a fail-closed approach.
             * This setting determines whether to prioritize accessibility over strict security in case of authorization service failure.
             *
             * If set to true, the External Authorization will also be bypassed if its configuration is invalid.
             */
            failOpen?: pulumi.Input<boolean>;
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthGrpcPatch>;
            /**
             * HeadersToExtAuth defines the client request headers that will be included
             * in the request to the external authorization service.
             * Note: If not specified, the default behavior for gRPC and HTTP external
             * authorization services is different due to backward compatibility reasons.
             * All headers will be included in the check request to a gRPC authorization server.
             * Only the following headers will be included in the check request to an HTTP
             * authorization server: Host, Method, Path, Content-Length, and Authorization.
             * And these headers will always be included to the check request to an HTTP
             * authorization server by default, no matter whether they are specified
             * in HeadersToExtAuth or not.
             */
            headersToExtAuth?: pulumi.Input<pulumi.Input<string>[]>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthHttpPatch>;
            /**
             * RecomputeRoute clears the route cache and recalculates the routing decision.
             * This field must be enabled if the headers added or modified by the ExtAuth are used for
             * route matching decisions. If the recomputation selects a new route, features targeting
             * the new matched route will be applied.
             */
            recomputeRoute?: pulumi.Input<boolean>;
        }
        /**
         * JWT defines the configuration for JSON Web Token (JWT) authentication.
         */
        interface SecurityPolicySpecJwt {
            /**
             * Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.
             * Note: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * Providers defines the JSON Web Token (JWT) authentication provider type.
             * When multiple JWT providers are specified, the JWT is considered valid if
             * any of the providers successfully validate the JWT. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProviders>[]>;
        }
        /**
         * JWT defines the configuration for JSON Web Token (JWT) authentication.
         */
        interface SecurityPolicySpecJwtPatch {
            /**
             * Optional determines whether a missing JWT is acceptable, defaulting to false if not specified.
             * Note: Even if optional is set to true, JWT authentication will still fail if an invalid JWT is presented.
             */
            optional?: pulumi.Input<boolean>;
            /**
             * Providers defines the JSON Web Token (JWT) authentication provider type.
             * When multiple JWT providers are specified, the JWT is considered valid if
             * any of the providers successfully validate the JWT. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/jwt_authn_filter.html.
             */
            providers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersPatch>[]>;
        }
        /**
         * JWTProvider defines how a JSON Web Token (JWT) can be verified.
         */
        interface SecurityPolicySpecJwtProviders {
            /**
             * Audiences is a list of JWT audiences allowed access. For additional details, see
             * https://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences
             * are not checked.
             */
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers
             * For examples, following config:
             * The claim must be of type; string, int, double, bool. Array type claims are not supported
             */
            claimToHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersClaimToHeaders>[]>;
            extractFrom?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersExtractFrom>;
            /**
             * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
             * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
             * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
             * the JWT issuer is not checked.
             */
            issuer?: pulumi.Input<string>;
            localJWKS?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKS>;
            /**
             * Name defines a unique name for the JWT provider. A name can have a variety of forms,
             * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
             */
            name?: pulumi.Input<string>;
            /**
             * RecomputeRoute clears the route cache and recalculates the routing decision.
             * This field must be enabled if the headers generated from the claim are used for
             * route matching decisions. If the recomputation selects a new route, features targeting
             * the new matched route will be applied.
             */
            recomputeRoute?: pulumi.Input<boolean>;
            remoteJWKS?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKS>;
        }
        /**
         * ClaimToHeader defines a configuration to convert JWT claims into HTTP headers
         */
        interface SecurityPolicySpecJwtProvidersClaimToHeaders {
            /**
             * Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type
             * (eg. "claim.nested.key", "sub"). The nested claim name must use dot "."
             * to separate the JSON name path.
             */
            claim?: pulumi.Input<string>;
            /**
             * Header defines the name of the HTTP request header that the JWT Claim will be saved into.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * ClaimToHeader defines a configuration to convert JWT claims into HTTP headers
         */
        interface SecurityPolicySpecJwtProvidersClaimToHeadersPatch {
            /**
             * Claim is the JWT Claim that should be saved into the header : it can be a nested claim of type
             * (eg. "claim.nested.key", "sub"). The nested claim name must use dot "."
             * to separate the JSON name path.
             */
            claim?: pulumi.Input<string>;
            /**
             * Header defines the name of the HTTP request header that the JWT Claim will be saved into.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * ExtractFrom defines different ways to extract the JWT token from HTTP request.
         * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
         * or access_token from query parameters.
         */
        interface SecurityPolicySpecJwtProvidersExtractFrom {
            /**
             * Cookies represents a list of cookie names to extract the JWT token from.
             */
            cookies?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers represents a list of HTTP request headers to extract the JWT token from.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersExtractFromHeaders>[]>;
            /**
             * Params represents a list of query parameters to extract the JWT token from.
             */
            params?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * JWTHeaderExtractor defines an HTTP header location to extract JWT token
         */
        interface SecurityPolicySpecJwtProvidersExtractFromHeaders {
            /**
             * Name is the HTTP header name to retrieve the token
             */
            name?: pulumi.Input<string>;
            /**
             * ValuePrefix is the prefix that should be stripped before extracting the token.
             * The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
             * For example, "Authorization: Bearer <TOKEN>", then the ValuePrefix="Bearer " with a space at the end.
             */
            valuePrefix?: pulumi.Input<string>;
        }
        /**
         * JWTHeaderExtractor defines an HTTP header location to extract JWT token
         */
        interface SecurityPolicySpecJwtProvidersExtractFromHeadersPatch {
            /**
             * Name is the HTTP header name to retrieve the token
             */
            name?: pulumi.Input<string>;
            /**
             * ValuePrefix is the prefix that should be stripped before extracting the token.
             * The format would be used by Envoy like "{ValuePrefix}<TOKEN>".
             * For example, "Authorization: Bearer <TOKEN>", then the ValuePrefix="Bearer " with a space at the end.
             */
            valuePrefix?: pulumi.Input<string>;
        }
        /**
         * ExtractFrom defines different ways to extract the JWT token from HTTP request.
         * If empty, it defaults to extract JWT token from the Authorization HTTP request header using Bearer schema
         * or access_token from query parameters.
         */
        interface SecurityPolicySpecJwtProvidersExtractFromPatch {
            /**
             * Cookies represents a list of cookie names to extract the JWT token from.
             */
            cookies?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Headers represents a list of HTTP request headers to extract the JWT token from.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersExtractFromHeadersPatch>[]>;
            /**
             * Params represents a list of query parameters to extract the JWT token from.
             */
            params?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source.
         */
        interface SecurityPolicySpecJwtProvidersLocalJWKS {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKSValueRef>;
        }
        /**
         * LocalJWKS defines how to get the JSON Web Key Sets (JWKS) from a local source.
         */
        interface SecurityPolicySpecJwtProvidersLocalJWKSPatch {
            /**
             * Inline contains the value as an inline string.
             */
            inline?: pulumi.Input<string>;
            /**
             * Type is the type of method to use to read the body value.
             * Valid values are Inline and ValueRef, default is Inline.
             */
            type?: pulumi.Input<string>;
            valueRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKSValueRefPatch>;
        }
        /**
         * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
         *
         * The value of key `jwks` in the ConfigMap will be used.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface SecurityPolicySpecJwtProvidersLocalJWKSValueRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ValueRef is a reference to a local ConfigMap that contains the JSON Web Key Sets (JWKS).
         *
         * The value of key `jwks` in the ConfigMap will be used.
         * If the key is not found, the first value in the ConfigMap will be used.
         */
        interface SecurityPolicySpecJwtProvidersLocalJWKSValueRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "HTTPRoute" or "Service".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * JWTProvider defines how a JSON Web Token (JWT) can be verified.
         */
        interface SecurityPolicySpecJwtProvidersPatch {
            /**
             * Audiences is a list of JWT audiences allowed access. For additional details, see
             * https://tools.ietf.org/html/rfc7519#section-4.1.3. If not provided, JWT audiences
             * are not checked.
             */
            audiences?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * ClaimToHeaders is a list of JWT claims that must be extracted into HTTP request headers
             * For examples, following config:
             * The claim must be of type; string, int, double, bool. Array type claims are not supported
             */
            claimToHeaders?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersClaimToHeadersPatch>[]>;
            extractFrom?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersExtractFromPatch>;
            /**
             * Issuer is the principal that issued the JWT and takes the form of a URL or email address.
             * For additional details, see https://tools.ietf.org/html/rfc7519#section-4.1.1 for
             * URL format and https://rfc-editor.org/rfc/rfc5322.html for email format. If not provided,
             * the JWT issuer is not checked.
             */
            issuer?: pulumi.Input<string>;
            localJWKS?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersLocalJWKSPatch>;
            /**
             * Name defines a unique name for the JWT provider. A name can have a variety of forms,
             * including RFC1123 subdomains, RFC 1123 labels, or RFC 1035 labels.
             */
            name?: pulumi.Input<string>;
            /**
             * RecomputeRoute clears the route cache and recalculates the routing decision.
             * This field must be enabled if the headers generated from the claim are used for
             * route matching decisions. If the recomputation selects a new route, features targeting
             * the new matched route will be applied.
             */
            recomputeRoute?: pulumi.Input<boolean>;
            remoteJWKS?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSPatch>;
        }
        /**
         * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
         * HTTP/HTTPS endpoint.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKS {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettings>;
            /**
             * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
             * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
             */
            uri?: pulumi.Input<string>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * RemoteJWKS defines how to fetch and cache JSON Web Key Sets (JWKS) from a remote
         * HTTP/HTTPS endpoint.
         */
        interface SecurityPolicySpecJwtProvidersRemoteJWKSPatch {
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtProvidersRemoteJWKSBackendSettingsPatch>;
            /**
             * URI is the HTTPS URI to fetch the JWKS. Envoy's system trust bundle is used to validate the server certificate.
             * If a custom trust bundle is needed, it can be specified in a BackendTLSConfig resource and target the BackendRefs.
             */
            uri?: pulumi.Input<string>;
        }
        /**
         * OIDC defines the configuration for the OpenID Connect (OIDC) authentication.
         */
        interface SecurityPolicySpecOidc {
            /**
             * The client ID to be used in the OIDC
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             *
             * Only one of clientID or clientIDRef must be set.
             */
            clientID?: pulumi.Input<string>;
            clientIDRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcClientIDRef>;
            clientSecret?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcClientSecret>;
            cookieConfig?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcCookieConfig>;
            /**
             * The optional domain to set the access and ID token cookies on.
             * If not set, the cookies will default to the host of the request, not including the subdomains.
             * If set, the cookies will be set on the specified domain and all subdomains.
             * This means that requests to any subdomain will not require reauthentication after users log in to the parent domain.
             */
            cookieDomain?: pulumi.Input<string>;
            cookieNames?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcCookieNames>;
            /**
             * DefaultRefreshTokenTTL is the default lifetime of the refresh token.
             * This field is only used when the exp (expiration time) claim is omitted in
             * the refresh token or the refresh token is not JWT.
             *
             * If not specified, defaults to 604800s (one week).
             * Note: this field is only applicable when the "refreshToken" field is set to true.
             */
            defaultRefreshTokenTTL?: pulumi.Input<string>;
            /**
             * DefaultTokenTTL is the default lifetime of the id token and access token.
             * Please note that Envoy will always use the expiry time from the response
             * of the authorization server if it is provided. This field is only used when
             * the expiry time is not provided by the authorization.
             *
             * If not specified, defaults to 0. In this case, the "expires_in" field in
             * the authorization response must be set by the authorization server, or the
             * OAuth flow will fail.
             */
            defaultTokenTTL?: pulumi.Input<string>;
            denyRedirect?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcDenyRedirect>;
            /**
             * ForwardAccessToken indicates whether the Envoy should forward the access token
             * via the Authorization header Bearer scheme to the upstream.
             * If not specified, defaults to false.
             */
            forwardAccessToken?: pulumi.Input<boolean>;
            /**
             * The path to log a user out, clearing their credential cookies.
             *
             * If not specified, uses a default logout path "/logout"
             */
            logoutPath?: pulumi.Input<string>;
            /**
             * Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless
             * explicitly stated otherwise in the extractFrom field, this will be the "Authorization: Bearer ..." header.
             *
             * The passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC
             * redirects and wish to directly supply a token instead.
             *
             * If not specified, defaults to false.
             */
            passThroughAuthHeader?: pulumi.Input<boolean>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProvider>;
            /**
             * The redirect URL to be used in the OIDC
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, uses the default redirect URI "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
             */
            redirectURL?: pulumi.Input<string>;
            /**
             * RefreshToken indicates whether the Envoy should automatically refresh the
             * id token and access token when they expire.
             * When set to true, the Envoy will use the refresh token to get a new id token
             * and access token when they expire.
             *
             * If not specified, defaults to false.
             */
            refreshToken?: pulumi.Input<boolean>;
            /**
             * The OIDC resources to be used in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             */
            resources?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The OIDC scopes to be used in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * The "openid" scope is always added to the list of scopes if not already
             * specified.
             */
            scopes?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * The Kubernetes secret which contains the client ID to be used in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         * Exactly one of clientID or clientIDRef must be set.
         * This is an Opaque secret. The client ID should be stored in the key "client-id".
         *
         * Only one of clientID or clientIDRef must be set.
         */
        interface SecurityPolicySpecOidcClientIDRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * The Kubernetes secret which contains the client ID to be used in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         * Exactly one of clientID or clientIDRef must be set.
         * This is an Opaque secret. The client ID should be stored in the key "client-id".
         *
         * Only one of clientID or clientIDRef must be set.
         */
        interface SecurityPolicySpecOidcClientIDRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * The Kubernetes secret which contains the OIDC client secret to be used in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         *
         * This is an Opaque secret. The client secret should be stored in the key
         * "client-secret".
         */
        interface SecurityPolicySpecOidcClientSecret {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * The Kubernetes secret which contains the OIDC client secret to be used in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         *
         * This is an Opaque secret. The client secret should be stored in the key
         * "client-secret".
         */
        interface SecurityPolicySpecOidcClientSecretPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent. For example "Secret".
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referenced object. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
        }
        /**
         * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
         * By default, its unset.
         */
        interface SecurityPolicySpecOidcCookieConfig {
            sameSite?: pulumi.Input<string>;
        }
        /**
         * CookieConfigs allows setting the SameSite attribute for OIDC cookies.
         * By default, its unset.
         */
        interface SecurityPolicySpecOidcCookieConfigPatch {
            sameSite?: pulumi.Input<string>;
        }
        /**
         * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         * If not specified, uses a randomly generated suffix
         */
        interface SecurityPolicySpecOidcCookieNames {
            /**
             * The name of the cookie used to store the AccessToken in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, defaults to "AccessToken-(randomly generated uid)"
             */
            accessToken?: pulumi.Input<string>;
            /**
             * The name of the cookie used to store the IdToken in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, defaults to "IdToken-(randomly generated uid)"
             */
            idToken?: pulumi.Input<string>;
        }
        /**
         * The optional cookie name overrides to be used for Bearer and IdToken cookies in the
         * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
         * If not specified, uses a randomly generated suffix
         */
        interface SecurityPolicySpecOidcCookieNamesPatch {
            /**
             * The name of the cookie used to store the AccessToken in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, defaults to "AccessToken-(randomly generated uid)"
             */
            accessToken?: pulumi.Input<string>;
            /**
             * The name of the cookie used to store the IdToken in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, defaults to "IdToken-(randomly generated uid)"
             */
            idToken?: pulumi.Input<string>;
        }
        /**
         * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
         * This behavior can be useful for AJAX or machine requests.
         */
        interface SecurityPolicySpecOidcDenyRedirect {
            /**
             * Defines the headers to match against the request to deny redirect to the OIDC Provider.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcDenyRedirectHeaders>[]>;
        }
        /**
         * OIDCDenyRedirectHeader defines how a header is matched
         */
        interface SecurityPolicySpecOidcDenyRedirectHeaders {
            /**
             * Specifies the name of the header in the request.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * OIDCDenyRedirectHeader defines how a header is matched
         */
        interface SecurityPolicySpecOidcDenyRedirectHeadersPatch {
            /**
             * Specifies the name of the header in the request.
             */
            name?: pulumi.Input<string>;
            /**
             * Type specifies how to match against a string.
             */
            type?: pulumi.Input<string>;
            /**
             * Value specifies the string value that the match must have.
             */
            value?: pulumi.Input<string>;
        }
        /**
         * Any request that matches any of the provided matchers (with either tokens that are expired or missing tokens) will not be redirected to the OIDC Provider.
         * This behavior can be useful for AJAX or machine requests.
         */
        interface SecurityPolicySpecOidcDenyRedirectPatch {
            /**
             * Defines the headers to match against the request to deny redirect to the OIDC Provider.
             */
            headers?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcDenyRedirectHeadersPatch>[]>;
        }
        /**
         * OIDC defines the configuration for the OpenID Connect (OIDC) authentication.
         */
        interface SecurityPolicySpecOidcPatch {
            /**
             * The client ID to be used in the OIDC
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             *
             * Only one of clientID or clientIDRef must be set.
             */
            clientID?: pulumi.Input<string>;
            clientIDRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcClientIDRefPatch>;
            clientSecret?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcClientSecretPatch>;
            cookieConfig?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcCookieConfigPatch>;
            /**
             * The optional domain to set the access and ID token cookies on.
             * If not set, the cookies will default to the host of the request, not including the subdomains.
             * If set, the cookies will be set on the specified domain and all subdomains.
             * This means that requests to any subdomain will not require reauthentication after users log in to the parent domain.
             */
            cookieDomain?: pulumi.Input<string>;
            cookieNames?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcCookieNamesPatch>;
            /**
             * DefaultRefreshTokenTTL is the default lifetime of the refresh token.
             * This field is only used when the exp (expiration time) claim is omitted in
             * the refresh token or the refresh token is not JWT.
             *
             * If not specified, defaults to 604800s (one week).
             * Note: this field is only applicable when the "refreshToken" field is set to true.
             */
            defaultRefreshTokenTTL?: pulumi.Input<string>;
            /**
             * DefaultTokenTTL is the default lifetime of the id token and access token.
             * Please note that Envoy will always use the expiry time from the response
             * of the authorization server if it is provided. This field is only used when
             * the expiry time is not provided by the authorization.
             *
             * If not specified, defaults to 0. In this case, the "expires_in" field in
             * the authorization response must be set by the authorization server, or the
             * OAuth flow will fail.
             */
            defaultTokenTTL?: pulumi.Input<string>;
            denyRedirect?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcDenyRedirectPatch>;
            /**
             * ForwardAccessToken indicates whether the Envoy should forward the access token
             * via the Authorization header Bearer scheme to the upstream.
             * If not specified, defaults to false.
             */
            forwardAccessToken?: pulumi.Input<boolean>;
            /**
             * The path to log a user out, clearing their credential cookies.
             *
             * If not specified, uses a default logout path "/logout"
             */
            logoutPath?: pulumi.Input<string>;
            /**
             * Skips OIDC authentication when the request contains a header that will be extracted by the JWT filter. Unless
             * explicitly stated otherwise in the extractFrom field, this will be the "Authorization: Bearer ..." header.
             *
             * The passThroughAuthHeader option is typically used for non-browser clients that may not be able to handle OIDC
             * redirects and wish to directly supply a token instead.
             *
             * If not specified, defaults to false.
             */
            passThroughAuthHeader?: pulumi.Input<boolean>;
            provider?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderPatch>;
            /**
             * The redirect URL to be used in the OIDC
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * If not specified, uses the default redirect URI "%REQ(x-forwarded-proto)%://%REQ(:authority)%/oauth2/callback"
             */
            redirectURL?: pulumi.Input<string>;
            /**
             * RefreshToken indicates whether the Envoy should automatically refresh the
             * id token and access token when they expire.
             * When set to true, the Envoy will use the refresh token to get a new id token
             * and access token when they expire.
             *
             * If not specified, defaults to false.
             */
            refreshToken?: pulumi.Input<boolean>;
            /**
             * The OIDC resources to be used in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             */
            resources?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The OIDC scopes to be used in the
             * [Authentication Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest).
             * The "openid" scope is always added to the list of scopes if not already
             * specified.
             */
            scopes?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * The OIDC Provider configuration.
         */
        interface SecurityPolicySpecOidcProvider {
            /**
             * The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
             * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
             */
            authorizationEndpoint?: pulumi.Input<string>;
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendRef>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendRefs>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettings>;
            /**
             * The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).
             *
             * If the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.
             * EG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.
             */
            endSessionEndpoint?: pulumi.Input<string>;
            /**
             * The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
             * Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST
             * be https, a host component, and optionally, port and path components and
             * no query or fragment components.
             */
            issuer?: pulumi.Input<string>;
            /**
             * The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
             * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
             */
            tokenEndpoint?: pulumi.Input<string>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecOidcProviderBackendRef {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef references a Kubernetes object that represents the
         * backend server to which the authorization request will be sent.
         *
         * Deprecated: Use BackendRefs instead.
         */
        interface SecurityPolicySpecOidcProviderBackendRefPatch {
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecOidcProviderBackendRefs {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendRef defines how an ObjectReference that is specific to BackendRef.
         */
        interface SecurityPolicySpecOidcProviderBackendRefsPatch {
            /**
             * Fallback indicates whether the backend is designated as a fallback.
             * Multiple fallback backends can be configured.
             * It is highly recommended to configure active or passive health checks to ensure that failover can be detected
             * when the active backends become unhealthy and to automatically readjust once the primary backends are healthy again.
             * The overprovisioning factor is set to 1.4, meaning the fallback backends will only start receiving traffic when
             * the health of the active backends falls below 72%.
             */
            fallback?: pulumi.Input<boolean>;
            /**
             * Group is the group of the referent. For example, "gateway.networking.k8s.io".
             * When unspecified or empty string, core API group is inferred.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the Kubernetes resource kind of the referent. For example
             * "Service".
             *
             * Defaults to "Service" when not specified.
             *
             * ExternalName services can refer to CNAME DNS records that may live
             * outside of the cluster and as such are difficult to reason about in
             * terms of conformance. They also may not be safe to forward to (see
             * CVE-2021-25740 for more information). Implementations SHOULD NOT
             * support ExternalName Services.
             *
             * Support: Core (Services with a type other than ExternalName)
             *
             * Support: Implementation-specific (Services with type ExternalName)
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the backend. When unspecified, the local
             * namespace is inferred.
             *
             * Note that when a namespace different than the local namespace is specified,
             * a ReferenceGrant object is required in the referent namespace to allow that
             * namespace's owner to accept the reference. See the ReferenceGrant
             * documentation for details.
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port specifies the destination port number to use for this resource.
             * Port is required when the referent is a Kubernetes Service. In this
             * case, the port number is the service port number, not the target port.
             * For other resources, destination port might be derived from the referent
             * resource or this field.
             */
            port?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecOidcProviderBackendSettings {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnection>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsDns>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheck>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHttp2>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetry>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeout>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreaker {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint>;
        }
        /**
         * Circuit Breaker settings for the upstream connections and requests.
         * If not set, circuit breakers will be enabled with the default thresholds
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPatch {
            /**
             * The maximum number of connections that Envoy will establish to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
            /**
             * The maximum number of parallel requests that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRequests?: pulumi.Input<number>;
            /**
             * The maximum number of parallel retries that Envoy will make to the referenced backend defined within a xRoute rule.
             */
            maxParallelRetries?: pulumi.Input<number>;
            /**
             * The maximum number of pending requests that Envoy will queue to the referenced backend defined within a xRoute rule.
             */
            maxPendingRequests?: pulumi.Input<number>;
            /**
             * The maximum number of requests that Envoy will make over a single connection to the referenced backend defined within a xRoute rule.
             * Default: unlimited.
             */
            maxRequestsPerConnection?: pulumi.Input<number>;
            perEndpoint?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpointPatch>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpoint {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * PerEndpoint defines Circuit Breakers that will apply per-endpoint for an upstream cluster
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPerEndpointPatch {
            /**
             * MaxConnections configures the maximum number of connections that Envoy will establish per-endpoint to the referenced backend defined within a xRoute rule.
             */
            maxConnections?: pulumi.Input<number>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsConnection {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * Connection includes backend connection settings.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsConnectionPatch {
            /**
             * BufferLimit Soft limit on size of the cluster’s connections read and write buffers.
             * BufferLimit applies to connection streaming (maybe non-streaming) channel between processes, it's in user space.
             * If unspecified, an implementation defined default is applied (32768 bytes).
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note: that when the suffix is not provided, the value is interpreted as bytes.
             */
            bufferLimit?: pulumi.Input<number | string>;
            /**
             * SocketBufferLimit provides configuration for the maximum buffer size in bytes for each socket
             * to backend.
             * SocketBufferLimit applies to socket streaming channel between TCP/IP stacks, it's in kernel space.
             * For example, 20Mi, 1Gi, 256Ki etc.
             * Note that when the suffix is not provided, the value is interpreted as bytes.
             */
            socketBufferLimit?: pulumi.Input<number | string>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsDns {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * DNS includes dns resolution settings.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsDnsPatch {
            /**
             * DNSRefreshRate specifies the rate at which DNS records should be refreshed.
             * Defaults to 30 seconds.
             */
            dnsRefreshRate?: pulumi.Input<string>;
            /**
             * LookupFamily determines how Envoy would resolve DNS for Routes where the backend is specified as a fully qualified domain name (FQDN).
             * If set, this configuration overrides other defaults.
             */
            lookupFamily?: pulumi.Input<string>;
            /**
             * RespectDNSTTL indicates whether the DNS Time-To-Live (TTL) should be respected.
             * If the value is set to true, the DNS refresh rate will be set to the resource record’s TTL.
             * Defaults to true.
             */
            respectDnsTtl?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheck {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActive {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpc {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * GRPC defines the configuration of the GRPC health checker.
         * It's optional, and can only be used if the specified type is GRPC.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpcPatch {
            /**
             * Service to send in the health check request.
             * If this is not specified, then the health check request applies to the entire
             * server and not to a specific service.
             */
            service?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttp {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponse {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * ExpectedResponse defines a list of HTTP expected responses to match.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponsePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * HTTP defines the configuration of http health checker.
         * It's required while the health checker type is HTTP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpPatch {
            expectedResponse?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpExpectedResponsePatch>;
            /**
             * ExpectedStatuses defines a list of HTTP response statuses considered healthy.
             * Defaults to 200 only
             */
            expectedStatuses?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Hostname defines the HTTP host that will be requested during health checking.
             * Default: HTTPRoute or GRPCRoute hostname.
             */
            hostname?: pulumi.Input<string>;
            /**
             * Method defines the HTTP method used for health checking.
             * Defaults to GET
             */
            method?: pulumi.Input<string>;
            /**
             * Path defines the HTTP path that will be requested during health checking.
             */
            path?: pulumi.Input<string>;
        }
        /**
         * Active health check configuration
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActivePatch {
            grpc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveGrpcPatch>;
            /**
             * HealthyThreshold defines the number of healthy health checks required before a backend host is marked healthy.
             */
            healthyThreshold?: pulumi.Input<number>;
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveHttpPatch>;
            /**
             * InitialJitter defines the maximum time Envoy will wait before the first health check.
             * Envoy will randomly select a value between 0 and the initial jitter value.
             */
            initialJitter?: pulumi.Input<string>;
            /**
             * Interval defines the time between active health checks.
             */
            interval?: pulumi.Input<string>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpPatch>;
            /**
             * Timeout defines the time to wait for a health check response.
             */
            timeout?: pulumi.Input<string>;
            /**
             * Type defines the type of health checker.
             */
            type?: pulumi.Input<string>;
            /**
             * UnhealthyThreshold defines the number of unhealthy health checks required before a backend host is marked unhealthy.
             */
            unhealthyThreshold?: pulumi.Input<number>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcp {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend>;
        }
        /**
         * TCP defines the configuration of tcp health checker.
         * It's required while the health checker type is TCP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpPatch {
            receive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceivePatch>;
            send?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSendPatch>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceive {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Receive defines the expected response payload.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpReceivePatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSend {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Send defines the request payload.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActiveTcpSendPatch {
            /**
             * Binary payload base64 encoded.
             */
            binary?: pulumi.Input<string>;
            /**
             * Text payload in plain text.
             */
            text?: pulumi.Input<string>;
            /**
             * Type defines the type of the payload.
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassive {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * Passive passive check configuration
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassivePatch {
            /**
             * BaseEjectionTime defines the base duration for which a host will be ejected on consecutive failures.
             */
            baseEjectionTime?: pulumi.Input<string>;
            /**
             * Consecutive5xxErrors sets the number of consecutive 5xx errors triggering ejection.
             */
            consecutive5XxErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveGatewayErrors sets the number of consecutive gateway errors triggering ejection.
             */
            consecutiveGatewayErrors?: pulumi.Input<number>;
            /**
             * ConsecutiveLocalOriginFailures sets the number of consecutive local origin failures triggering ejection.
             * Parameter takes effect only when split_external_local_origin_errors is set to true.
             */
            consecutiveLocalOriginFailures?: pulumi.Input<number>;
            /**
             * Interval defines the time between passive health checks.
             */
            interval?: pulumi.Input<string>;
            /**
             * MaxEjectionPercent sets the maximum percentage of hosts in a cluster that can be ejected.
             */
            maxEjectionPercent?: pulumi.Input<number>;
            /**
             * SplitExternalLocalOriginErrors enables splitting of errors between external and local origin.
             */
            splitExternalLocalOriginErrors?: pulumi.Input<boolean>;
        }
        /**
         * HealthCheck allows gateway to perform active health checking on backends.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPatch {
            active?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckActivePatch>;
            /**
             * When number of unhealthy endpoints for a backend reaches this threshold
             * Envoy will disregard health status and balance across all endpoints.
             * It's designed to prevent a situation in which host failures cascade throughout the cluster
             * as load increases. If not set, the default value is 50%. To disable panic mode, set value to `0`.
             */
            panicThreshold?: pulumi.Input<number>;
            passive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPassivePatch>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHttp2 {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * HTTP2 provides HTTP/2 configuration for backend connections.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsHttp2Patch {
            /**
             * InitialConnectionWindowSize sets the initial window size for HTTP/2 connections.
             * If not set, the default value is 1 MiB.
             */
            initialConnectionWindowSize?: pulumi.Input<number | string>;
            /**
             * InitialStreamWindowSize sets the initial window size for HTTP/2 streams.
             * If not set, the default value is 64 KiB(64*1024).
             */
            initialStreamWindowSize?: pulumi.Input<number | string>;
            /**
             * MaxConcurrentStreams sets the maximum number of concurrent streams allowed per connection.
             * If not set, the default value is 100.
             */
            maxConcurrentStreams?: pulumi.Input<number>;
            /**
             * OnInvalidMessage determines if Envoy will terminate the connection or just the offending stream in the event of HTTP messaging error
             * It's recommended for L2 Envoy deployments to set this value to TerminateStream.
             * https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/level_two
             * Default: TerminateConnection
             */
            onInvalidMessage?: pulumi.Input<string>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancer {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHash {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookie {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Cookie configures the cookie hash policy when the consistent hash type is set to Cookie.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookiePatch {
            /**
             * Additional Attributes to set for the generated cookie.
             */
            attributes?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * Name of the cookie to hash.
             * If this cookie does not exist in the request, Envoy will generate a cookie and set
             * the TTL on the response back to the client based on Layer 4
             * attributes of the backend endpoint, to ensure that these future requests
             * go to the same backend endpoint. Make sure to set the TTL field for this case.
             */
            name?: pulumi.Input<string>;
            /**
             * TTL of the generated cookie if the cookie is not present. This value sets the
             * Max-Age attribute value.
             */
            ttl?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeader {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * Header configures the header hash policy when the consistent hash type is set to Header.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaderPatch {
            /**
             * Name of the header to hash.
             */
            name?: pulumi.Input<string>;
        }
        /**
         * ConsistentHash defines the configuration when the load balancer type is
         * set to ConsistentHash
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashPatch {
            cookie?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashCookiePatch>;
            header?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashHeaderPatch>;
            /**
             * The table size for consistent hashing, must be prime number limited to 5000011.
             */
            tableSize?: pulumi.Input<number>;
            /**
             * ConsistentHashType defines the type of input to hash on. Valid Type values are
             * "SourceIP",
             * "Header",
             * "Cookie".
             */
            type?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverride {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom>[]>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFrom {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverrideExtractFrom defines a source to extract endpoint override information from.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch {
            /**
             * Header defines the header to get the override endpoint addresses.
             * The header value must specify at least one endpoint in `IP:Port` format or multiple endpoints in `IP:Port,IP:Port,...` format.
             * For example `10.0.0.5:8080` or `[2600:4040:5204::1574:24ae]:80`.
             * The IPv6 address is enclosed in square brackets.
             */
            header?: pulumi.Input<string>;
        }
        /**
         * EndpointOverride defines the configuration for endpoint override.
         * When specified, the load balancer will attempt to route requests to endpoints
         * based on the override information extracted from request headers or metadata.
         *  If the override endpoints are not available, the configured load balancer policy will be used as fallback.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverridePatch {
            /**
             * ExtractFrom defines the sources to extract endpoint override information from.
             */
            extractFrom?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverrideExtractFromPatch>[]>;
        }
        /**
         * LoadBalancer policy to apply when routing traffic from the gateway to
         * the backend endpoints. Defaults to `LeastRequest`.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerPatch {
            consistentHash?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerConsistentHashPatch>;
            endpointOverride?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerEndpointOverridePatch>;
            slowStart?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStartPatch>;
            /**
             * Type decides the type of Load Balancer policy.
             * Valid LoadBalancerType values are
             * "ConsistentHash",
             * "LeastRequest",
             * "Random",
             * "RoundRobin".
             */
            type?: pulumi.Input<string>;
            zoneAware?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePatch>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStart {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * SlowStart defines the configuration related to the slow start load balancer policy.
         * If set, during slow start window, traffic sent to the newly added hosts will gradually increase.
         * Currently this is only supported for RoundRobin and LeastRequest load balancers
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerSlowStartPatch {
            /**
             * Window defines the duration of the warm up period for newly added host.
             * During slow start window, traffic sent to the newly added hosts will gradually increase.
             * Currently only supports linear growth of traffic. For additional details,
             * see https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#config-cluster-v3-cluster-slowstartconfig
             */
            window?: pulumi.Input<string>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAware {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal>;
        }
        /**
         * ZoneAware defines the configuration related to the distribution of requests between locality zones.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePatch {
            preferLocal?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalPatch>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocal {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForce {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * ForceLocalZone defines override configuration for forcing all traffic to stay within the local zone instead of the default behavior
         * which maintains equal distribution among upstream endpoints while sending as much traffic as possible locally.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch {
            /**
             * MinEndpointsInZoneThreshold is the minimum number of upstream endpoints in the local zone required to honor the forceLocalZone
             * override. This is useful for protecting zones with fewer endpoints.
             */
            minEndpointsInZoneThreshold?: pulumi.Input<number>;
        }
        /**
         * PreferLocalZone configures zone-aware routing to prefer sending traffic to the local locality zone.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalPatch {
            force?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerZoneAwarePreferLocalForcePatch>;
            /**
             * MinEndpointsThreshold is the minimum number of total upstream endpoints across all zones required to enable zone-aware routing.
             */
            minEndpointsThreshold?: pulumi.Input<number>;
        }
        /**
         * BackendSettings holds configuration for managing the connection
         * to the backend.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsPatch {
            circuitBreaker?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsCircuitBreakerPatch>;
            connection?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsConnectionPatch>;
            dns?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsDnsPatch>;
            healthCheck?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHealthCheckPatch>;
            http2?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsHttp2Patch>;
            loadBalancer?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsLoadBalancerPatch>;
            proxyProtocol?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsProxyProtocolPatch>;
            retry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPatch>;
            tcpKeepalive?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalivePatch>;
            timeout?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutPatch>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsProxyProtocol {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * ProxyProtocol enables the Proxy Protocol when communicating with the backend.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsProxyProtocolPatch {
            /**
             * Version of ProxyProtol
             * Valid ProxyProtocolVersion values are
             * "V1"
             * "V2"
             */
            version?: pulumi.Input<string>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetry {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn>;
        }
        /**
         * Retry provides more advanced usage, allowing users to customize the number of retries, retry fallback strategy, and retry triggering conditions.
         * If not set, retry will be disabled.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryPatch {
            /**
             * NumAttemptsPerPriority defines the number of requests (initial attempt + retries)
             * that should be sent to the same priority before switching to a different one.
             * If not specified or set to 0, all requests are sent to the highest priority that is healthy.
             */
            numAttemptsPerPriority?: pulumi.Input<number>;
            /**
             * NumRetries is the number of retries to be attempted. Defaults to 2.
             */
            numRetries?: pulumi.Input<number>;
            perRetry?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryPatch>;
            retryOn?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOnPatch>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetry {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOff {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * Backoff is the backoff policy to be applied per retry attempt. gateway uses a fully jittered exponential
         * back-off algorithm for retries. For additional details,
         * see https://www.envoyproxy.io/docs/envoy/latest/configuration/http/http_filters/router_filter#config-http-filters-router-x-envoy-max-retries
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOffPatch {
            /**
             * BaseInterval is the base interval between retries.
             */
            baseInterval?: pulumi.Input<string>;
            /**
             * MaxInterval is the maximum interval between retries. This parameter is optional, but must be greater than or equal to the base_interval if set.
             * The default is 10 times the base_interval
             */
            maxInterval?: pulumi.Input<string>;
        }
        /**
         * PerRetry is the retry policy to be applied per retry attempt.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryPatch {
            backOff?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsRetryPerRetryBackOffPatch>;
            /**
             * Timeout is the timeout per retry attempt.
             */
            timeout?: pulumi.Input<string>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOn {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * RetryOn specifies the retry trigger condition.
         *
         * If not specified, the default is to retry on connect-failure,refused-stream,unavailable,cancelled,retriable-status-codes(503).
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsRetryRetryOnPatch {
            /**
             * HttpStatusCodes specifies the http status codes to be retried.
             * The retriable-status-codes trigger must also be configured for these status codes to trigger a retry.
             */
            httpStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Triggers specifies the retry trigger condition(Http/Grpc).
             */
            triggers?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalive {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * TcpKeepalive settings associated with the upstream client connection.
         * Disabled by default.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTcpKeepalivePatch {
            /**
             * The duration a connection needs to be idle before keep-alive
             * probes start being sent.
             * The duration format is
             * Defaults to `7200s`.
             */
            idleTime?: pulumi.Input<string>;
            /**
             * The duration between keep-alive probes.
             * Defaults to `75s`.
             */
            interval?: pulumi.Input<string>;
            /**
             * The total number of unacknowledged probes to send before deciding
             * the connection is dead.
             * Defaults to 9.
             */
            probes?: pulumi.Input<number>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeout {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttp {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for HTTP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttpPatch {
            /**
             * The idle timeout for an HTTP connection. Idle time is defined as a period in which there are no active requests in the connection.
             * Default: 1 hour.
             */
            connectionIdleTimeout?: pulumi.Input<string>;
            /**
             * The maximum duration of an HTTP connection.
             * Default: unlimited.
             */
            maxConnectionDuration?: pulumi.Input<string>;
            /**
             * RequestTimeout is the time until which entire response is received from the upstream.
             */
            requestTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for the backend connections.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutPatch {
            http?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutHttpPatch>;
            tcp?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcpPatch>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcp {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * Timeout settings for TCP.
         */
        interface SecurityPolicySpecOidcProviderBackendSettingsTimeoutTcpPatch {
            /**
             * The timeout for network connection establishment, including TCP and TLS handshakes.
             * Default: 10 seconds.
             */
            connectTimeout?: pulumi.Input<string>;
        }
        /**
         * The OIDC Provider configuration.
         */
        interface SecurityPolicySpecOidcProviderPatch {
            /**
             * The OIDC Provider's [authorization endpoint](https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint).
             * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
             */
            authorizationEndpoint?: pulumi.Input<string>;
            backendRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendRefPatch>;
            /**
             * BackendRefs references a Kubernetes object that represents the
             * backend server to which the authorization request will be sent.
             */
            backendRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendRefsPatch>[]>;
            backendSettings?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcProviderBackendSettingsPatch>;
            /**
             * The OIDC Provider's [end session endpoint](https://openid.net/specs/openid-connect-core-1_0.html#RPLogout).
             *
             * If the end session endpoint is provided, EG will use it to log out the user from the OIDC Provider when the user accesses the logout path.
             * EG will also try to discover the end session endpoint from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse) when authorizationEndpoint or tokenEndpoint is not provided.
             */
            endSessionEndpoint?: pulumi.Input<string>;
            /**
             * The OIDC Provider's [issuer identifier](https://openid.net/specs/openid-connect-discovery-1_0.html#IssuerDiscovery).
             * Issuer MUST be a URI RFC 3986 [RFC3986] with a scheme component that MUST
             * be https, a host component, and optionally, port and path components and
             * no query or fragment components.
             */
            issuer?: pulumi.Input<string>;
            /**
             * The OIDC Provider's [token endpoint](https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint).
             * If not provided, EG will try to discover it from the provider's [Well-Known Configuration Endpoint](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse).
             */
            tokenEndpoint?: pulumi.Input<string>;
        }
        /**
         * Spec defines the desired state of SecurityPolicy.
         */
        interface SecurityPolicySpecPatch {
            apiKeyAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecApiKeyAuthPatch>;
            authorization?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecAuthorizationPatch>;
            basicAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecBasicAuthPatch>;
            cors?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecCorsPatch>;
            extAuth?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecExtAuthPatch>;
            jwt?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecJwtPatch>;
            oidc?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecOidcPatch>;
            targetRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetRefPatch>;
            /**
             * TargetRefs are the names of the Gateway resources this policy
             * is being attached to.
             */
            targetRefs?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetRefsPatch>[]>;
            /**
             * TargetSelectors allow targeting resources for this policy based on labels
             */
            targetSelectors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetSelectorsPatch>[]>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface SecurityPolicySpecTargetRef {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * TargetRef is the name of the resource this policy is being attached to.
         * This policy and the TargetRef MUST be in the same namespace for this
         * Policy to have effect
         *
         * Deprecated: use targetRefs/targetSelectors instead
         */
        interface SecurityPolicySpecTargetRefPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface SecurityPolicySpecTargetRefs {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * LocalPolicyTargetReferenceWithSectionName identifies an API object to apply a
         * direct policy to. This should be used as part of Policy resources that can
         * target single resources. For more information on how this policy attachment
         * mode works, and a sample Policy resource, refer to the policy attachment
         * documentation for Gateway API.
         *
         * Note: This should only be used for direct policy attachment when references
         * to SectionName are actually needed. In all other cases,
         * LocalPolicyTargetReference should be used.
         */
        interface SecurityPolicySpecTargetRefsPatch {
            /**
             * Group is the group of the target resource.
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the target resource.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the target resource.
             */
            name?: pulumi.Input<string>;
            /**
             * SectionName is the name of a section within the target resource. When
             * unspecified, this targetRef targets the entire resource. In the following
             * resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name
             * * HTTPRoute: HTTPRouteRule name
             * * Service: Port name
             *
             * If a SectionName is specified, but does not exist on the targeted object,
             * the Policy must fail to attach, and the policy implementation should record
             * a `ResolvedRefs` or similar Condition in the Policy's status.
             */
            sectionName?: pulumi.Input<string>;
        }
        interface SecurityPolicySpecTargetSelectors {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetSelectorsMatchExpressions>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface SecurityPolicySpecTargetSelectorsMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        interface SecurityPolicySpecTargetSelectorsMatchExpressionsPatch {
            /**
             * key is the label key that the selector applies to.
             */
            key?: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator?: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }
        interface SecurityPolicySpecTargetSelectorsPatch {
            /**
             * Group is the group that this selector targets. Defaults to gateway.networking.k8s.io
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is the resource kind that this selector targets.
             */
            kind?: pulumi.Input<string>;
            /**
             * MatchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicySpecTargetSelectorsMatchExpressionsPatch>[]>;
            /**
             * MatchLabels are the set of label selectors for identifying the targeted resource
             */
            matchLabels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
        }
        /**
         * Status defines the current status of SecurityPolicy.
         */
        interface SecurityPolicyStatus {
            /**
             * Ancestors is a list of ancestor resources (usually Gateways) that are
             * associated with the policy, and the status of the policy with respect to
             * each ancestor. When this policy attaches to a parent, the controller that
             * manages the parent and the ancestors MUST add an entry to this list when
             * the controller first sees the policy and SHOULD update the entry as
             * appropriate when the relevant ancestor is modified.
             *
             * Note that choosing the relevant ancestor is left to the Policy designers;
             * an important part of Policy design is designing the right object level at
             * which to namespace this status.
             *
             * Note also that implementations MUST ONLY populate ancestor status for
             * the Ancestor resources they are responsible for. Implementations MUST
             * use the ControllerName field to uniquely identify the entries in this list
             * that they are responsible for.
             *
             * Note that to achieve this, the list of PolicyAncestorStatus structs
             * MUST be treated as a map with a composite key, made up of the AncestorRef
             * and ControllerName fields combined.
             *
             * A maximum of 16 ancestors will be represented in this list. An empty list
             * means the Policy is not relevant for any ancestors.
             *
             * If this slice is full, implementations MUST NOT add further entries.
             * Instead they MUST consider the policy unimplementable and signal that
             * on any related resources such as the ancestor that would be referenced
             * here. For example, if this list was full on BackendTLSPolicy, no
             * additional Gateways would be able to reference the Service targeted by
             * the BackendTLSPolicy.
             */
            ancestors?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicyStatusAncestors>[]>;
        }
        /**
         * PolicyAncestorStatus describes the status of a route with respect to an
         * associated Ancestor.
         *
         * Ancestors refer to objects that are either the Target of a policy or above it
         * in terms of object hierarchy. For example, if a policy targets a Service, the
         * Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
         * the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
         * useful object to place Policy status on, so we recommend that implementations
         * SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
         * have a _very_ good reason otherwise.
         *
         * In the context of policy attachment, the Ancestor is used to distinguish which
         * resource results in a distinct application of this policy. For example, if a policy
         * targets a Service, it may have a distinct result per attached Gateway.
         *
         * Policies targeting the same resource may have different effects depending on the
         * ancestors of those resources. For example, different Gateways targeting the same
         * Service may have different capabilities, especially if they have different underlying
         * implementations.
         *
         * For example, in BackendTLSPolicy, the Policy attaches to a Service that is
         * used as a backend in a HTTPRoute that is itself attached to a Gateway.
         * In this case, the relevant object for status is the Gateway, and that is the
         * ancestor object referred to in this status.
         *
         * Note that a parent is also an ancestor, so for objects where the parent is the
         * relevant object for status, this struct SHOULD still be used.
         *
         * This struct is intended to be used in a slice that's effectively a map,
         * with a composite key made up of the AncestorRef and the ControllerName.
         */
        interface SecurityPolicyStatusAncestors {
            ancestorRef?: pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicyStatusAncestorsAncestorRef>;
            /**
             * Conditions describes the status of the Policy with respect to the given Ancestor.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.gateway.v1alpha1.SecurityPolicyStatusAncestorsConditions>[]>;
            /**
             * ControllerName is a domain/path string that indicates the name of the
             * controller that wrote this status. This corresponds with the
             * controllerName field on GatewayClass.
             *
             * Example: "example.net/gateway-controller".
             *
             * The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
             * valid Kubernetes names
             * (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
             *
             * Controllers MUST populate this field when writing status. Controllers should ensure that
             * entries to status populated with their ControllerName are cleaned up when they are no
             * longer necessary.
             */
            controllerName?: pulumi.Input<string>;
        }
        /**
         * AncestorRef corresponds with a ParentRef in the spec that this
         * PolicyAncestorStatus struct describes the status of.
         */
        interface SecurityPolicyStatusAncestorsAncestorRef {
            /**
             * Group is the group of the referent.
             * When unspecified, "gateway.networking.k8s.io" is inferred.
             * To set the core API group (such as for a "Service" kind referent),
             * Group must be explicitly set to "" (empty string).
             *
             * Support: Core
             */
            group?: pulumi.Input<string>;
            /**
             * Kind is kind of the referent.
             *
             * There are two kinds of parent resources with "Core" support:
             *
             * * Gateway (Gateway conformance profile)
             * * Service (Mesh conformance profile, ClusterIP Services only)
             *
             * Support for other resources is Implementation-Specific.
             */
            kind?: pulumi.Input<string>;
            /**
             * Name is the name of the referent.
             *
             * Support: Core
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace is the namespace of the referent. When unspecified, this refers
             * to the local namespace of the Route.
             *
             * Note that there are specific rules for ParentRefs which cross namespace
             * boundaries. Cross-namespace references are only valid if they are explicitly
             * allowed by something in the namespace they are referring to. For example:
             * Gateway has the AllowedRoutes field, and ReferenceGrant provides a
             * generic way to enable any other kind of cross-namespace reference.
             *
             * <gateway:experimental:description>
             * ParentRefs from a Route to a Service in the same namespace are "producer"
             * routes, which apply default routing rules to inbound connections from
             * any namespace to the Service.
             *
             * ParentRefs from a Route to a Service in a different namespace are
             * "consumer" routes, and these routing rules are only applied to outbound
             * connections originating from the same namespace as the Route, for which
             * the intended destination of the connections are a Service targeted as a
             * ParentRef of the Route.
             * </gateway:experimental:description>
             *
             * Support: Core
             */
            namespace?: pulumi.Input<string>;
            /**
             * Port is the network port this Route targets. It can be interpreted
             * differently based on the type of parent resource.
             *
             * When the parent resource is a Gateway, this targets all listeners
             * listening on the specified port that also support this kind of Route(and
             * select this Route). It's not recommended to set `Port` unless the
             * networking behaviors specified in a Route must apply to a specific port
             * as opposed to a listener(s) whose port(s) may be changed. When both Port
             * and SectionName are specified, the name and port of the selected listener
             * must match both specified values.
             *
             * <gateway:experimental:description>
             * When the parent resource is a Service, this targets a specific port in the
             * Service spec. When both Port (experimental) and SectionName are specified,
             * the name and port of the selected port must match both specified values.
             * </gateway:experimental:description>
             *
             * Implementations MAY choose to support other parent resources.
             * Implementations supporting other types of parent resources MUST clearly
             * document how/if Port is interpreted.
             *
             * For the purpose of status, an attachment is considered successful as
             * long as the parent resource accepts it partially. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
             * from the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route,
             * the Route MUST be considered detached from the Gateway.
             *
             * Support: Extended
             */
            port?: pulumi.Input<number>;
            /**
             * SectionName is the name of a section within the target resource. In the
             * following resources, SectionName is interpreted as the following:
             *
             * * Gateway: Listener name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             * * Service: Port name. When both Port (experimental) and SectionName
             * are specified, the name and port of the selected listener must match
             * both specified values.
             *
             * Implementations MAY choose to support attaching Routes to other resources.
             * If that is the case, they MUST clearly document how SectionName is
             * interpreted.
             *
             * When unspecified (empty string), this will reference the entire resource.
             * For the purpose of status, an attachment is considered successful if at
             * least one section in the parent resource accepts it. For example, Gateway
             * listeners can restrict which Routes can attach to them by Route kind,
             * namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
             * the referencing Route, the Route MUST be considered successfully
             * attached. If no Gateway listeners accept attachment from this Route, the
             * Route MUST be considered detached from the Gateway.
             *
             * Support: Core
             */
            sectionName?: pulumi.Input<string>;
        }
        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        interface SecurityPolicyStatusAncestorsConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message?: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason?: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type?: pulumi.Input<string>;
        }
    }
}
export declare namespace meta {
    namespace v1 {
        /**
         * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
         */
        interface ListMeta {
            /**
             * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
             */
            continue?: pulumi.Input<string>;
            /**
             * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
             */
            remainingItemCount?: pulumi.Input<number>;
            /**
             * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
        }
        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        interface ManagedFieldsEntry {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }
        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        interface ManagedFieldsEntryPatch {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }
        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        interface ObjectMeta {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntry>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReference>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }
        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        interface ObjectMetaPatch {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{
                [key: string]: pulumi.Input<string>;
            }>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntryPatch>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReferencePatch>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }
        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        interface OwnerReference {
            /**
             * API version of the referent.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: pulumi.Input<string>;
        }
        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        interface OwnerReferencePatch {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }
    }
}
